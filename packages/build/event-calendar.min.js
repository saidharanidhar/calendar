/*!
EventCalendar v2.7.0
https://github.com/vkurko/calendar
New Package - 19-Jul-2024
*/
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var EventCalendar = (function () {
	'use strict';

	/** @returns {void} */
	function noop() {}
	const identity = x => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign$1(tar, src) {
	  // @ts-ignore
	  for (const k in src) tar[k] = src[k];
	  return /** @type {T & S} */tar;
	}

	/** @returns {void} */
	function add_location(element, file, line, column, char) {
	  element.__svelte_meta = {
	    loc: {
	      file,
	      line,
	      column,
	      char
	    }
	  };
	}
	function run(fn) {
	  return fn();
	}
	function blank_object() {
	  return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
	  fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
	  return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
	  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
	}

	/** @returns {boolean} */
	function is_empty(obj) {
	  return Object.keys(obj).length === 0;
	}

	/** @returns {void} */
	function validate_store(store, name) {
	  if (store != null && typeof store.subscribe !== 'function') {
	    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
	  }
	}
	function subscribe(store) {
	  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    callbacks[_key - 1] = arguments[_key];
	  }
	  if (store == null) {
	    for (const callback of callbacks) {
	      callback(undefined);
	    }
	    return noop;
	  }
	  const unsub = store.subscribe(...callbacks);
	  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * https://svelte.dev/docs/svelte-store#get
	 * @template T
	 * @param {import('../store/public.js').Readable<T>} store
	 * @returns {T}
	 */
	function get_store_value(store) {
	  let value;
	  subscribe(store, _ => value = _)();
	  return value;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
	  component.$$.on_destroy.push(subscribe(store, callback));
	}
	function create_slot(definition, ctx, $$scope, fn) {
	  if (definition) {
	    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	    return definition[0](slot_ctx);
	  }
	}
	function get_slot_context(definition, ctx, $$scope, fn) {
	  return definition[1] && fn ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
	}
	function get_slot_changes(definition, $$scope, dirty, fn) {
	  if (definition[2] && fn) {
	    const lets = definition[2](fn(dirty));
	    if ($$scope.dirty === undefined) {
	      return lets;
	    }
	    if (typeof lets === 'object') {
	      const merged = [];
	      const len = Math.max($$scope.dirty.length, lets.length);
	      for (let i = 0; i < len; i += 1) {
	        merged[i] = $$scope.dirty[i] | lets[i];
	      }
	      return merged;
	    }
	    return $$scope.dirty | lets;
	  }
	  return $$scope.dirty;
	}

	/** @returns {void} */
	function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
	  if (slot_changes) {
	    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	    slot.p(slot_context, slot_changes);
	  }
	}

	/** @returns {any[] | -1} */
	function get_all_dirty_from_scope($$scope) {
	  if ($$scope.ctx.length > 32) {
	    const dirty = [];
	    const length = $$scope.ctx.length / 32;
	    for (let i = 0; i < length; i++) {
	      dirty[i] = -1;
	    }
	    return dirty;
	  }
	  return -1;
	}
	function set_store_value(store, ret, value) {
	  store.set(value);
	  return ret;
	}
	function action_destroyer(action_result) {
	  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	/** @type {typeof globalThis} */
	const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis :
	// @ts-ignore Node typings have this
	global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
	  target.appendChild(node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
	  target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
	  if (node.parentNode) {
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
	  for (let i = 0; i < iterations.length; i += 1) {
	    if (iterations[i]) iterations[i].d(detaching);
	  }
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
	  return document.createElement(name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
	  return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
	  return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
	  return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
	  node.addEventListener(event, handler, options);
	  return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function stop_propagation(fn) {
	  return function (event) {
	    event.stopPropagation();
	    // @ts-ignore
	    return fn.call(this, event);
	  };
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
	  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
	  return Array.from(element.childNodes);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
	  input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
	  if (value == null) {
	    node.style.removeProperty(key);
	  } else {
	    node.style.setProperty(key, value, '');
	  }
	}

	/**
	 * @returns {void} */
	function select_option(select, value, mounting) {
	  for (let i = 0; i < select.options.length; i += 1) {
	    const option = select.options[i];
	    if (option.__value === value) {
	      option.selected = true;
	      return;
	    }
	  }
	  if (!mounting || value !== undefined) {
	    select.selectedIndex = -1; // no option should be selected
	  }
	}
	function select_value(select) {
	  const selected_option = select.querySelector(':checked');
	  return selected_option && selected_option.__value;
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail) {
	  let {
	    bubbles = false,
	    cancelable = false
	  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  return new CustomEvent(type, {
	    detail,
	    bubbles,
	    cancelable
	  });
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
	  current_component = component;
	}
	function get_current_component() {
	  if (!current_component) throw new Error('Function called outside component initialization');
	  return current_component;
	}

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#beforeupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
	  get_current_component().$$.before_update.push(fn);
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
	  get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
	  get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
	  const component = get_current_component();
	  return function (type, detail) {
	    let {
	      cancelable = false
	    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    const callbacks = component.$$.callbacks[type];
	    if (callbacks) {
	      // TODO are there situations where events could be dispatched
	      // in a server (non-DOM) environment?
	      const event = custom_event( /** @type {string} */type, detail, {
	        cancelable
	      });
	      callbacks.slice().forEach(fn => {
	        fn.call(component, event);
	      });
	      return !event.defaultPrevented;
	    }
	    return true;
	  };
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#setcontext
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
	  get_current_component().$$.context.set(key, context);
	  return context;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * https://svelte.dev/docs/svelte#getcontext
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
	  return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
	  const callbacks = component.$$.callbacks[event.type];
	  if (callbacks) {
	    // @ts-ignore
	    callbacks.slice().forEach(fn => fn.call(this, event));
	  }
	}

	const dirty_components = [];
	const binding_callbacks = [];
	let render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = /* @__PURE__ */Promise.resolve();
	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
	  if (!update_scheduled) {
	    update_scheduled = true;
	    resolved_promise.then(flush);
	  }
	}

	/** @returns {Promise<void>} */
	function tick() {
	  schedule_update();
	  return resolved_promise;
	}

	/** @returns {void} */
	function add_render_callback(fn) {
	  render_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();
	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
	  // Do not reenter flush while dirty components are updated, as this can
	  // result in an infinite loop. Instead, let the inner flush handle it.
	  // Reentrancy is ok afterwards for bindings etc.
	  if (flushidx !== 0) {
	    return;
	  }
	  const saved_component = current_component;
	  do {
	    // first, call beforeUpdate functions
	    // and update components
	    try {
	      while (flushidx < dirty_components.length) {
	        const component = dirty_components[flushidx];
	        flushidx++;
	        set_current_component(component);
	        update(component.$$);
	      }
	    } catch (e) {
	      // reset dirty state to not end up in a deadlocked state and then rethrow
	      dirty_components.length = 0;
	      flushidx = 0;
	      throw e;
	    }
	    set_current_component(null);
	    dirty_components.length = 0;
	    flushidx = 0;
	    while (binding_callbacks.length) binding_callbacks.pop()();
	    // then, once components are updated, call
	    // afterUpdate functions. This may cause
	    // subsequent updates...
	    for (let i = 0; i < render_callbacks.length; i += 1) {
	      const callback = render_callbacks[i];
	      if (!seen_callbacks.has(callback)) {
	        // ...so guard against infinite loops
	        seen_callbacks.add(callback);
	        callback();
	      }
	    }
	    render_callbacks.length = 0;
	  } while (dirty_components.length);
	  while (flush_callbacks.length) {
	    flush_callbacks.pop()();
	  }
	  update_scheduled = false;
	  seen_callbacks.clear();
	  set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
	  if ($$.fragment !== null) {
	    $$.update();
	    run_all($$.before_update);
	    const dirty = $$.dirty;
	    $$.dirty = [-1];
	    $$.fragment && $$.fragment.p($$.ctx, dirty);
	    $$.after_update.forEach(add_render_callback);
	  }
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
	  const filtered = [];
	  const targets = [];
	  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
	  targets.forEach(c => c());
	  render_callbacks = filtered;
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
	  outros = {
	    r: 0,
	    c: [],
	    p: outros // parent group
	  };
	}

	/**
	 * @returns {void} */
	function check_outros() {
	  if (!outros.r) {
	    run_all(outros.c);
	  }
	  outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
	  if (block && block.i) {
	    outroing.delete(block);
	    block.i(local);
	  }
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
	  if (block && block.o) {
	    if (outroing.has(block)) return;
	    outroing.add(block);
	    outros.c.push(() => {
	      outroing.delete(block);
	      if (callback) {
	        if (detach) block.d(1);
	        callback();
	      }
	    });
	    block.o(local);
	  } else if (callback) {
	    callback();
	  }
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
	  return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);
	}

	// keyed each functions:

	/** @returns {void} */
	function destroy_block(block, lookup) {
	  block.d(1);
	  lookup.delete(block.key);
	}

	/** @returns {void} */
	function outro_and_destroy_block(block, lookup) {
	  transition_out(block, 1, 1, () => {
	    lookup.delete(block.key);
	  });
	}

	/** @returns {any[]} */
	function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
	  let o = old_blocks.length;
	  let n = list.length;
	  let i = o;
	  const old_indexes = {};
	  while (i--) old_indexes[old_blocks[i].key] = i;
	  const new_blocks = [];
	  const new_lookup = new Map();
	  const deltas = new Map();
	  const updates = [];
	  i = n;
	  while (i--) {
	    const child_ctx = get_context(ctx, list, i);
	    const key = get_key(child_ctx);
	    let block = lookup.get(key);
	    if (!block) {
	      block = create_each_block(key, child_ctx);
	      block.c();
	    } else {
	      // defer updates until all the DOM shuffling is done
	      updates.push(() => block.p(child_ctx, dirty));
	    }
	    new_lookup.set(key, new_blocks[i] = block);
	    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
	  }
	  const will_move = new Set();
	  const did_move = new Set();
	  /** @returns {void} */
	  function insert(block) {
	    transition_in(block, 1);
	    block.m(node, next);
	    lookup.set(block.key, block);
	    next = block.first;
	    n--;
	  }
	  while (o && n) {
	    const new_block = new_blocks[n - 1];
	    const old_block = old_blocks[o - 1];
	    const new_key = new_block.key;
	    const old_key = old_block.key;
	    if (new_block === old_block) {
	      // do nothing
	      next = new_block.first;
	      o--;
	      n--;
	    } else if (!new_lookup.has(old_key)) {
	      // remove old block
	      destroy(old_block, lookup);
	      o--;
	    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
	      insert(new_block);
	    } else if (did_move.has(old_key)) {
	      o--;
	    } else if (deltas.get(new_key) > deltas.get(old_key)) {
	      did_move.add(new_key);
	      insert(new_block);
	    } else {
	      will_move.add(old_key);
	      o--;
	    }
	  }
	  while (o--) {
	    const old_block = old_blocks[o];
	    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
	  }
	  while (n) insert(new_blocks[n - 1]);
	  run_all(updates);
	  return new_blocks;
	}

	/** @returns {void} */
	function validate_each_keys(ctx, list, get_context, get_key) {
	  const keys = new Map();
	  for (let i = 0; i < list.length; i++) {
	    const key = get_key(get_context(ctx, list, i));
	    if (keys.has(key)) {
	      let value = '';
	      try {
	        value = `with value '${String(key)}' `;
	      } catch (e) {
	        // can't stringify
	      }
	      throw new Error(`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(key)} and ${i} ${value}are duplicates`);
	    }
	    keys.set(key, i);
	  }
	}

	/** @returns {void} */
	function create_component(block) {
	  block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
	  const {
	    fragment,
	    after_update
	  } = component.$$;
	  fragment && fragment.m(target, anchor);
	  // onMount happens before the initial afterUpdate
	  add_render_callback(() => {
	    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
	    // if the component was destroyed immediately
	    // it will update the `$$.on_destroy` reference to `null`.
	    // the destructured on_destroy may still reference to the old array
	    if (component.$$.on_destroy) {
	      component.$$.on_destroy.push(...new_on_destroy);
	    } else {
	      // Edge case - component was destroyed immediately,
	      // most likely as a result of a binding initialising
	      run_all(new_on_destroy);
	    }
	    component.$$.on_mount = [];
	  });
	  after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
	  const $$ = component.$$;
	  if ($$.fragment !== null) {
	    flush_render_callbacks($$.after_update);
	    run_all($$.on_destroy);
	    $$.fragment && $$.fragment.d(detaching);
	    // TODO null out other refs, including component.$$ (but need to
	    // preserve final state?)
	    $$.on_destroy = $$.fragment = null;
	    $$.ctx = [];
	  }
	}

	/** @returns {void} */
	function make_dirty(component, i) {
	  if (component.$$.dirty[0] === -1) {
	    dirty_components.push(component);
	    schedule_update();
	    component.$$.dirty.fill(0);
	  }
	  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(component, options, instance, create_fragment, not_equal, props) {
	  let append_styles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
	  let dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
	  const parent_component = current_component;
	  set_current_component(component);
	  /** @type {import('./private.js').T$$} */
	  const $$ = component.$$ = {
	    fragment: null,
	    ctx: [],
	    // state
	    props,
	    update: noop,
	    not_equal,
	    bound: blank_object(),
	    // lifecycle
	    on_mount: [],
	    on_destroy: [],
	    on_disconnect: [],
	    before_update: [],
	    after_update: [],
	    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	    // everything else
	    callbacks: blank_object(),
	    dirty,
	    skip_bound: false,
	    root: options.target || parent_component.$$.root
	  };
	  append_styles && append_styles($$.root);
	  let ready = false;
	  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
	    const value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;
	    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
	      if (ready) make_dirty(component, i);
	    }
	    return ret;
	  }) : [];
	  $$.update();
	  ready = true;
	  run_all($$.before_update);
	  // `false` as a special case of no DOM component
	  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	  if (options.target) {
	    if (options.hydrate) {
	      // TODO: what is the correct type here?
	      // @ts-expect-error
	      const nodes = children(options.target);
	      $$.fragment && $$.fragment.l(nodes);
	      nodes.forEach(detach);
	    } else {
	      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	      $$.fragment && $$.fragment.c();
	    }
	    if (options.intro) transition_in(component.$$.fragment);
	    mount_component(component, options.target, options.anchor);
	    flush();
	  }
	  set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
	  /**
	   * ### PRIVATE API
	   *
	   * Do not use, may change at any time
	   *
	   * @type {any}
	   */
	  $$ = undefined;
	  /**
	   * ### PRIVATE API
	   *
	   * Do not use, may change at any time
	   *
	   * @type {any}
	   */
	  $$set = undefined;

	  /** @returns {void} */
	  $destroy() {
	    destroy_component(this, 1);
	    this.$destroy = noop;
	  }

	  /**
	   * @template {Extract<keyof Events, string>} K
	   * @param {K} type
	   * @param {((e: Events[K]) => void) | null | undefined} callback
	   * @returns {() => void}
	   */
	  $on(type, callback) {
	    if (!is_function(callback)) {
	      return noop;
	    }
	    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
	    callbacks.push(callback);
	    return () => {
	      const index = callbacks.indexOf(callback);
	      if (index !== -1) callbacks.splice(index, 1);
	    };
	  }

	  /**
	   * @param {Partial<Props>} props
	   * @returns {void}
	   */
	  $set(props) {
	    if (this.$$set && !is_empty(props)) {
	      this.$$.skip_bound = true;
	      this.$$set(props);
	      this.$$.skip_bound = false;
	    }
	  }
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var fails$9 = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var fails$8 = fails$9;

	var functionBindNative = !fails$8(function () {
	  // eslint-disable-next-line es/no-function-prototype-bind -- safe
	  var test = (function () { /* empty */ }).bind();
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});

	var NATIVE_BIND$3 = functionBindNative;

	var FunctionPrototype$2 = Function.prototype;
	var call$6 = FunctionPrototype$2.call;
	var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$2.bind.bind(call$6, call$6);

	var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function (fn) {
	  return function () {
	    return call$6.apply(fn, arguments);
	  };
	};

	var uncurryThis$9 = functionUncurryThis;

	var toString$5 = uncurryThis$9({}.toString);
	var stringSlice$1 = uncurryThis$9(''.slice);

	var classofRaw$2 = function (it) {
	  return stringSlice$1(toString$5(it), 8, -1);
	};

	var uncurryThis$8 = functionUncurryThis;
	var fails$7 = fails$9;
	var classof$5 = classofRaw$2;

	var $Object$5 = Object;
	var split = uncurryThis$8(''.split);

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails$7(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !$Object$5('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classof$5(it) == 'String' ? split(it, '') : $Object$5(it);
	} : $Object$5;

	// we can't use just `it == null` since of `document.all` special case
	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
	var isNullOrUndefined$3 = function (it) {
	  return it === null || it === undefined;
	};

	var isNullOrUndefined$2 = isNullOrUndefined$3;

	var $TypeError$5 = TypeError;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible$3 = function (it) {
	  if (isNullOrUndefined$2(it)) throw $TypeError$5("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings
	var IndexedObject = indexedObject;
	var requireObjectCoercible$2 = requireObjectCoercible$3;

	var toIndexedObject$5 = function (it) {
	  return IndexedObject(requireObjectCoercible$2(it));
	};

	var iterators = {};

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global$c =
	  // eslint-disable-next-line es/no-global-this -- safe
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  // eslint-disable-next-line no-restricted-globals -- safe
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || commonjsGlobal || Function('return this')();

	var documentAll$2 = typeof document == 'object' && document.all;

	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
	// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
	var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;

	var documentAll_1 = {
	  all: documentAll$2,
	  IS_HTMLDDA: IS_HTMLDDA
	};

	var $documentAll$1 = documentAll_1;

	var documentAll$1 = $documentAll$1.all;

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable$b = $documentAll$1.IS_HTMLDDA ? function (argument) {
	  return typeof argument == 'function' || argument === documentAll$1;
	} : function (argument) {
	  return typeof argument == 'function';
	};

	var global$b = global$c;
	var isCallable$a = isCallable$b;

	var WeakMap$1 = global$b.WeakMap;

	var weakMapBasicDetection = isCallable$a(WeakMap$1) && /native code/.test(String(WeakMap$1));

	var isCallable$9 = isCallable$b;
	var $documentAll = documentAll_1;

	var documentAll = $documentAll.all;

	var isObject$6 = $documentAll.IS_HTMLDDA ? function (it) {
	  return typeof it == 'object' ? it !== null : isCallable$9(it) || it === documentAll;
	} : function (it) {
	  return typeof it == 'object' ? it !== null : isCallable$9(it);
	};

	var fails$6 = fails$9;

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails$6(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var objectDefineProperty = {};

	var global$a = global$c;
	var isObject$5 = isObject$6;

	var document$1 = global$a.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS$1 = isObject$5(document$1) && isObject$5(document$1.createElement);

	var documentCreateElement$1 = function (it) {
	  return EXISTS$1 ? document$1.createElement(it) : {};
	};

	var DESCRIPTORS$6 = descriptors;
	var fails$5 = fails$9;
	var createElement$1 = documentCreateElement$1;

	// Thanks to IE8 for its funny defineProperty
	var ie8DomDefine = !DESCRIPTORS$6 && !fails$5(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(createElement$1('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var DESCRIPTORS$5 = descriptors;
	var fails$4 = fails$9;

	// V8 ~ Chrome 36-
	// https://bugs.chromium.org/p/v8/issues/detail?id=3334
	var v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype != 42;
	});

	var isObject$4 = isObject$6;

	var $String$3 = String;
	var $TypeError$4 = TypeError;

	// `Assert: Type(argument) is Object`
	var anObject$3 = function (argument) {
	  if (isObject$4(argument)) return argument;
	  throw $TypeError$4($String$3(argument) + ' is not an object');
	};

	var NATIVE_BIND$2 = functionBindNative;

	var call$5 = Function.prototype.call;

	var functionCall = NATIVE_BIND$2 ? call$5.bind(call$5) : function () {
	  return call$5.apply(call$5, arguments);
	};

	var path$2 = {};

	var path$1 = path$2;
	var global$9 = global$c;
	var isCallable$8 = isCallable$b;

	var aFunction = function (variable) {
	  return isCallable$8(variable) ? variable : undefined;
	};

	var getBuiltIn$2 = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path$1[namespace]) || aFunction(global$9[namespace])
	    : path$1[namespace] && path$1[namespace][method] || global$9[namespace] && global$9[namespace][method];
	};

	var uncurryThis$7 = functionUncurryThis;

	var objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);

	var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

	var global$8 = global$c;
	var userAgent = engineUserAgent;

	var process = global$8.process;
	var Deno = global$8.Deno;
	var versions = process && process.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us
	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}

	// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0
	if (!version && userAgent) {
	  match = userAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}

	var engineV8Version = version;

	/* eslint-disable es/no-symbol -- required for testing */

	var V8_VERSION = engineV8Version;
	var fails$3 = fails$9;
	var global$7 = global$c;

	var $String$2 = global$7.String;

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
	var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$3(function () {
	  var symbol = Symbol();
	  // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
	  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
	  // of course, fail.
	  return !$String$2(symbol) || !(Object(symbol) instanceof Symbol) ||
	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
	});

	/* eslint-disable es/no-symbol -- required for testing */

	var NATIVE_SYMBOL$1 = symbolConstructorDetection;

	var useSymbolAsUid = NATIVE_SYMBOL$1
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var getBuiltIn$1 = getBuiltIn$2;
	var isCallable$7 = isCallable$b;
	var isPrototypeOf = objectIsPrototypeOf;
	var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

	var $Object$4 = Object;

	var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn$1('Symbol');
	  return isCallable$7($Symbol) && isPrototypeOf($Symbol.prototype, $Object$4(it));
	};

	var $String$1 = String;

	var tryToString$1 = function (argument) {
	  try {
	    return $String$1(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var isCallable$6 = isCallable$b;
	var tryToString = tryToString$1;

	var $TypeError$3 = TypeError;

	// `Assert: IsCallable(argument) is true`
	var aCallable$2 = function (argument) {
	  if (isCallable$6(argument)) return argument;
	  throw $TypeError$3(tryToString(argument) + ' is not a function');
	};

	var aCallable$1 = aCallable$2;
	var isNullOrUndefined$1 = isNullOrUndefined$3;

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod
	var getMethod$1 = function (V, P) {
	  var func = V[P];
	  return isNullOrUndefined$1(func) ? undefined : aCallable$1(func);
	};

	var call$4 = functionCall;
	var isCallable$5 = isCallable$b;
	var isObject$3 = isObject$6;

	var $TypeError$2 = TypeError;

	// `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive
	var ordinaryToPrimitive$1 = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable$5(fn = input.toString) && !isObject$3(val = call$4(fn, input))) return val;
	  if (isCallable$5(fn = input.valueOf) && !isObject$3(val = call$4(fn, input))) return val;
	  if (pref !== 'string' && isCallable$5(fn = input.toString) && !isObject$3(val = call$4(fn, input))) return val;
	  throw $TypeError$2("Can't convert object to primitive value");
	};

	var shared$3 = {exports: {}};

	var global$6 = global$c;

	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var defineProperty$1 = Object.defineProperty;

	var defineGlobalProperty$1 = function (key, value) {
	  try {
	    defineProperty$1(global$6, key, { value: value, configurable: true, writable: true });
	  } catch (error) {
	    global$6[key] = value;
	  } return value;
	};

	var global$5 = global$c;
	var defineGlobalProperty = defineGlobalProperty$1;

	var SHARED = '__core-js_shared__';
	var store$2 = global$5[SHARED] || defineGlobalProperty(SHARED, {});

	var sharedStore = store$2;

	var store$1 = sharedStore;

	(shared$3.exports = function (key, value) {
	  return store$1[key] || (store$1[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.31.1',
	  mode: 'pure' ,
	  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});

	var sharedExports = shared$3.exports;

	var requireObjectCoercible$1 = requireObjectCoercible$3;

	var $Object$3 = Object;

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject$2 = function (argument) {
	  return $Object$3(requireObjectCoercible$1(argument));
	};

	var uncurryThis$6 = functionUncurryThis;
	var toObject$1 = toObject$2;

	var hasOwnProperty = uncurryThis$6({}.hasOwnProperty);

	// `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty
	// eslint-disable-next-line es/no-object-hasown -- safe
	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject$1(it), key);
	};

	var uncurryThis$5 = functionUncurryThis;

	var id = 0;
	var postfix = Math.random();
	var toString$4 = uncurryThis$5(1.0.toString);

	var uid$2 = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id + postfix, 36);
	};

	var global$4 = global$c;
	var shared$2 = sharedExports;
	var hasOwn$8 = hasOwnProperty_1;
	var uid$1 = uid$2;
	var NATIVE_SYMBOL = symbolConstructorDetection;
	var USE_SYMBOL_AS_UID = useSymbolAsUid;

	var Symbol$1 = global$4.Symbol;
	var WellKnownSymbolsStore = shared$2('wks');
	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1['for'] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;

	var wellKnownSymbol$8 = function (name) {
	  if (!hasOwn$8(WellKnownSymbolsStore, name)) {
	    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$8(Symbol$1, name)
	      ? Symbol$1[name]
	      : createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var call$3 = functionCall;
	var isObject$2 = isObject$6;
	var isSymbol$1 = isSymbol$2;
	var getMethod = getMethod$1;
	var ordinaryToPrimitive = ordinaryToPrimitive$1;
	var wellKnownSymbol$7 = wellKnownSymbol$8;

	var $TypeError$1 = TypeError;
	var TO_PRIMITIVE = wellKnownSymbol$7('toPrimitive');

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	var toPrimitive$1 = function (input, pref) {
	  if (!isObject$2(input) || isSymbol$1(input)) return input;
	  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
	  var result;
	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = call$3(exoticToPrim, input, pref);
	    if (!isObject$2(result) || isSymbol$1(result)) return result;
	    throw $TypeError$1("Can't convert object to primitive value");
	  }
	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	var toPrimitive = toPrimitive$1;
	var isSymbol = isSymbol$2;

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey
	var toPropertyKey$2 = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol(key) ? key : key + '';
	};

	var DESCRIPTORS$4 = descriptors;
	var IE8_DOM_DEFINE$1 = ie8DomDefine;
	var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
	var anObject$2 = anObject$3;
	var toPropertyKey$1 = toPropertyKey$2;

	var $TypeError = TypeError;
	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var $defineProperty = Object.defineProperty;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable';

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	objectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
	  anObject$2(O);
	  P = toPropertyKey$1(P);
	  anObject$2(Attributes);
	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor$1(O, P);
	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  } return $defineProperty(O, P, Attributes);
	} : $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject$2(O);
	  P = toPropertyKey$1(P);
	  anObject$2(Attributes);
	  if (IE8_DOM_DEFINE$1) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var createPropertyDescriptor$3 = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var DESCRIPTORS$3 = descriptors;
	var definePropertyModule$1 = objectDefineProperty;
	var createPropertyDescriptor$2 = createPropertyDescriptor$3;

	var createNonEnumerableProperty$5 = DESCRIPTORS$3 ? function (object, key, value) {
	  return definePropertyModule$1.f(object, key, createPropertyDescriptor$2(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var shared$1 = sharedExports;
	var uid = uid$2;

	var keys$1 = shared$1('keys');

	var sharedKey$3 = function (key) {
	  return keys$1[key] || (keys$1[key] = uid(key));
	};

	var hiddenKeys$3 = {};

	var NATIVE_WEAK_MAP = weakMapBasicDetection;
	var global$3 = global$c;
	var isObject$1 = isObject$6;
	var createNonEnumerableProperty$4 = createNonEnumerableProperty$5;
	var hasOwn$7 = hasOwnProperty_1;
	var shared = sharedStore;
	var sharedKey$2 = sharedKey$3;
	var hiddenKeys$2 = hiddenKeys$3;

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$1 = global$3.TypeError;
	var WeakMap = global$3.WeakMap;
	var set, get, has;

	var enforce = function (it) {
	  return has(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$1(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (NATIVE_WEAK_MAP || shared.state) {
	  var store = shared.state || (shared.state = new WeakMap());
	  /* eslint-disable no-self-assign -- prototype methods protection */
	  store.get = store.get;
	  store.has = store.has;
	  store.set = store.set;
	  /* eslint-enable no-self-assign -- prototype methods protection */
	  set = function (it, metadata) {
	    if (store.has(it)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    store.set(it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return store.get(it) || {};
	  };
	  has = function (it) {
	    return store.has(it);
	  };
	} else {
	  var STATE = sharedKey$2('state');
	  hiddenKeys$2[STATE] = true;
	  set = function (it, metadata) {
	    if (hasOwn$7(it, STATE)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty$4(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return hasOwn$7(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return hasOwn$7(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var NATIVE_BIND$1 = functionBindNative;

	var FunctionPrototype$1 = Function.prototype;
	var apply$1 = FunctionPrototype$1.apply;
	var call$2 = FunctionPrototype$1.call;

	// eslint-disable-next-line es/no-reflect -- safe
	var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$2.bind(apply$1) : function () {
	  return call$2.apply(apply$1, arguments);
	});

	var classofRaw$1 = classofRaw$2;
	var uncurryThis$4 = functionUncurryThis;

	var functionUncurryThisClause = function (fn) {
	  // Nashorn bug:
	  //   https://github.com/zloirock/core-js/issues/1128
	  //   https://github.com/zloirock/core-js/issues/1130
	  if (classofRaw$1(fn) === 'Function') return uncurryThis$4(fn);
	};

	var objectGetOwnPropertyDescriptor = {};

	var objectPropertyIsEnumerable = {};

	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$1(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	var DESCRIPTORS$2 = descriptors;
	var call$1 = functionCall;
	var propertyIsEnumerableModule = objectPropertyIsEnumerable;
	var createPropertyDescriptor$1 = createPropertyDescriptor$3;
	var toIndexedObject$4 = toIndexedObject$5;
	var toPropertyKey = toPropertyKey$2;
	var hasOwn$6 = hasOwnProperty_1;
	var IE8_DOM_DEFINE = ie8DomDefine;

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	objectGetOwnPropertyDescriptor.f = DESCRIPTORS$2 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject$4(O);
	  P = toPropertyKey(P);
	  if (IE8_DOM_DEFINE) try {
	    return $getOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (hasOwn$6(O, P)) return createPropertyDescriptor$1(!call$1(propertyIsEnumerableModule.f, O, P), O[P]);
	};

	var fails$2 = fails$9;
	var isCallable$4 = isCallable$b;

	var replacement = /#|\.prototype\./;

	var isForced$1 = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : isCallable$4(detection) ? fails$2(detection)
	    : !!detection;
	};

	var normalize = isForced$1.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced$1.data = {};
	var NATIVE = isForced$1.NATIVE = 'N';
	var POLYFILL = isForced$1.POLYFILL = 'P';

	var isForced_1 = isForced$1;

	var uncurryThis$3 = functionUncurryThisClause;
	var aCallable = aCallable$2;
	var NATIVE_BIND = functionBindNative;

	var bind$1 = uncurryThis$3(uncurryThis$3.bind);

	// optional / simple context binding
	var functionBindContext = function (fn, that) {
	  aCallable(fn);
	  return that === undefined ? fn : NATIVE_BIND ? bind$1(fn, that) : function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var global$2 = global$c;
	var apply = functionApply;
	var uncurryThis$2 = functionUncurryThisClause;
	var isCallable$3 = isCallable$b;
	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var isForced = isForced_1;
	var path = path$2;
	var bind = functionBindContext;
	var createNonEnumerableProperty$3 = createNonEnumerableProperty$5;
	var hasOwn$5 = hasOwnProperty_1;

	var wrapConstructor = function (NativeConstructor) {
	  var Wrapper = function (a, b, c) {
	    if (this instanceof Wrapper) {
	      switch (arguments.length) {
	        case 0: return new NativeConstructor();
	        case 1: return new NativeConstructor(a);
	        case 2: return new NativeConstructor(a, b);
	      } return new NativeConstructor(a, b, c);
	    } return apply(NativeConstructor, this, arguments);
	  };
	  Wrapper.prototype = NativeConstructor.prototype;
	  return Wrapper;
	};

	/*
	  options.target         - name of the target object
	  options.global         - target is the global object
	  options.stat           - export as static methods of target
	  options.proto          - export as prototype methods of target
	  options.real           - real prototype method for the `pure` version
	  options.forced         - export even if the native feature is available
	  options.bind           - bind methods to the target, required for the `pure` version
	  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
	  options.sham           - add a flag to not completely full polyfills
	  options.enumerable     - export as enumerable property
	  options.dontCallGetSet - prevent calling a getter on target
	  options.name           - the .name of the function if it does not match the key
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var PROTO = options.proto;

	  var nativeSource = GLOBAL ? global$2 : STATIC ? global$2[TARGET] : (global$2[TARGET] || {}).prototype;

	  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty$3(path, TARGET, {})[TARGET];
	  var targetPrototype = target.prototype;

	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

	  for (key in source) {
	    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contains in native
	    USE_NATIVE = !FORCED && nativeSource && hasOwn$5(nativeSource, key);

	    targetProperty = target[key];

	    if (USE_NATIVE) if (options.dontCallGetSet) {
	      descriptor = getOwnPropertyDescriptor(nativeSource, key);
	      nativeProperty = descriptor && descriptor.value;
	    } else nativeProperty = nativeSource[key];

	    // export native or implementation
	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

	    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

	    // bind methods to global for calling from export context
	    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global$2);
	    // wrap global constructors for prevent changes in this version
	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
	    // make static versions for prototype methods
	    else if (PROTO && isCallable$3(sourceProperty)) resultProperty = uncurryThis$2(sourceProperty);
	    // default case
	    else resultProperty = sourceProperty;

	    // add a flag to not completely full polyfills
	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty$3(resultProperty, 'sham', true);
	    }

	    createNonEnumerableProperty$3(target, key, resultProperty);

	    if (PROTO) {
	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
	      if (!hasOwn$5(path, VIRTUAL_PROTOTYPE)) {
	        createNonEnumerableProperty$3(path, VIRTUAL_PROTOTYPE, {});
	      }
	      // export virtual prototype methods
	      createNonEnumerableProperty$3(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
	      // export real prototype methods
	      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
	        createNonEnumerableProperty$3(targetPrototype, key, sourceProperty);
	      }
	    }
	  }
	};

	var DESCRIPTORS$1 = descriptors;
	var hasOwn$4 = hasOwnProperty_1;

	var FunctionPrototype = Function.prototype;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;

	var EXISTS = hasOwn$4(FunctionPrototype, 'name');
	// additional protection from minified / mangled / dropped function names
	var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || (DESCRIPTORS$1 && getDescriptor(FunctionPrototype, 'name').configurable));

	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var objectDefineProperties = {};

	var ceil = Math.ceil;
	var floor$1 = Math.floor;

	// `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc
	// eslint-disable-next-line es/no-math-trunc -- safe
	var mathTrunc = Math.trunc || function trunc(x) {
	  var n = +x;
	  return (n > 0 ? floor$1 : ceil)(n);
	};

	var trunc = mathTrunc;

	// `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity
	var toIntegerOrInfinity$3 = function (argument) {
	  var number = +argument;
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return number !== number || number === 0 ? 0 : trunc(number);
	};

	var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;

	var max$1 = Math.max;
	var min$2 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex$1 = function (index, length) {
	  var integer = toIntegerOrInfinity$2(index);
	  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);
	};

	var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;

	var min$1 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength$1 = function (argument) {
	  return argument > 0 ? min$1(toIntegerOrInfinity$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var toLength = toLength$1;

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike
	var lengthOfArrayLike$1 = function (obj) {
	  return toLength(obj.length);
	};

	var toIndexedObject$3 = toIndexedObject$5;
	var toAbsoluteIndex = toAbsoluteIndex$1;
	var lengthOfArrayLike = lengthOfArrayLike$1;

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$1 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject$3($this);
	    var length = lengthOfArrayLike(O);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare -- NaN check
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$1(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$1(false)
	};

	var uncurryThis$1 = functionUncurryThis;
	var hasOwn$3 = hasOwnProperty_1;
	var toIndexedObject$2 = toIndexedObject$5;
	var indexOf = arrayIncludes.indexOf;
	var hiddenKeys$1 = hiddenKeys$3;

	var push = uncurryThis$1([].push);

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject$2(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !hasOwn$3(hiddenKeys$1, key) && hasOwn$3(O, key) && push(result, key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (hasOwn$3(O, key = names[i++])) {
	    ~indexOf(result, key) || push(result, key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys$2 = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var internalObjectKeys = objectKeysInternal;
	var enumBugKeys$1 = enumBugKeys$2;

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe
	var objectKeys$1 = Object.keys || function keys(O) {
	  return internalObjectKeys(O, enumBugKeys$1);
	};

	var DESCRIPTORS = descriptors;
	var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
	var definePropertyModule = objectDefineProperty;
	var anObject$1 = anObject$3;
	var toIndexedObject$1 = toIndexedObject$5;
	var objectKeys = objectKeys$1;

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe
	objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject$1(O);
	  var props = toIndexedObject$1(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
	  return O;
	};

	var getBuiltIn = getBuiltIn$2;

	var html$1 = getBuiltIn('document', 'documentElement');

	/* global ActiveXObject -- old IE, WSH */

	var anObject = anObject$3;
	var definePropertiesModule = objectDefineProperties;
	var enumBugKeys = enumBugKeys$2;
	var hiddenKeys = hiddenKeys$3;
	var html = html$1;
	var documentCreateElement = documentCreateElement$1;
	var sharedKey$1 = sharedKey$3;

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey$1('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = typeof document != 'undefined'
	    ? document.domain && activeXDocument
	      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
	      : NullProtoObjectViaIFrame()
	    : NullProtoObjectViaActiveX(activeXDocument); // WSH
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	// eslint-disable-next-line es/no-object-create -- safe
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
	};

	var fails$1 = fails$9;

	var correctPrototypeGetter = !fails$1(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var hasOwn$2 = hasOwnProperty_1;
	var isCallable$2 = isCallable$b;
	var toObject = toObject$2;
	var sharedKey = sharedKey$3;
	var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

	var IE_PROTO = sharedKey('IE_PROTO');
	var $Object$2 = Object;
	var ObjectPrototype = $Object$2.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	// eslint-disable-next-line es/no-object-getprototypeof -- safe
	var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$2.getPrototypeOf : function (O) {
	  var object = toObject(O);
	  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;
	  if (isCallable$2(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  } return object instanceof $Object$2 ? ObjectPrototype : null;
	};

	var createNonEnumerableProperty$2 = createNonEnumerableProperty$5;

	var defineBuiltIn$2 = function (target, key, value, options) {
	  if (options && options.enumerable) target[key] = value;
	  else createNonEnumerableProperty$2(target, key, value);
	  return target;
	};

	var fails = fails$9;
	var isCallable$1 = isCallable$b;
	var isObject = isObject$6;
	var create$1 = objectCreate;
	var getPrototypeOf$1 = objectGetPrototypeOf;
	var defineBuiltIn$1 = defineBuiltIn$2;
	var wellKnownSymbol$6 = wellKnownSymbol$8;

	var ITERATOR$2 = wellKnownSymbol$6('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;

	/* eslint-disable es/no-array-prototype-keys -- safe */
	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype$1) || fails(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype$1[ITERATOR$2].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};
	else IteratorPrototype$1 = create$1(IteratorPrototype$1);

	// `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
	if (!isCallable$1(IteratorPrototype$1[ITERATOR$2])) {
	  defineBuiltIn$1(IteratorPrototype$1, ITERATOR$2, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$1,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var wellKnownSymbol$5 = wellKnownSymbol$8;

	var TO_STRING_TAG$3 = wellKnownSymbol$5('toStringTag');
	var test = {};

	test[TO_STRING_TAG$3] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
	var isCallable = isCallable$b;
	var classofRaw = classofRaw$2;
	var wellKnownSymbol$4 = wellKnownSymbol$8;

	var TO_STRING_TAG$2 = wellKnownSymbol$4('toStringTag');
	var $Object$1 = Object;

	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof$4 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};

	var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
	var classof$3 = classof$4;

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {
	  return '[object ' + classof$3(this) + ']';
	};

	var TO_STRING_TAG_SUPPORT = toStringTagSupport;
	var defineProperty = objectDefineProperty.f;
	var createNonEnumerableProperty$1 = createNonEnumerableProperty$5;
	var hasOwn$1 = hasOwnProperty_1;
	var toString$3 = objectToString;
	var wellKnownSymbol$3 = wellKnownSymbol$8;

	var TO_STRING_TAG$1 = wellKnownSymbol$3('toStringTag');

	var setToStringTag$2 = function (it, TAG, STATIC, SET_METHOD) {
	  if (it) {
	    var target = STATIC ? it : it.prototype;
	    if (!hasOwn$1(target, TO_STRING_TAG$1)) {
	      defineProperty(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
	    }
	    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
	      createNonEnumerableProperty$1(target, 'toString', toString$3);
	    }
	  }
	};

	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var create = objectCreate;
	var createPropertyDescriptor = createPropertyDescriptor$3;
	var setToStringTag$1 = setToStringTag$2;
	var Iterators$4 = iterators;

	var returnThis$1 = function () { return this; };

	var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
	  setToStringTag$1(IteratorConstructor, TO_STRING_TAG, false, true);
	  Iterators$4[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var $ = _export;
	var call = functionCall;
	var FunctionName = functionName;
	var createIteratorConstructor = iteratorCreateConstructor;
	var getPrototypeOf = objectGetPrototypeOf;
	var setToStringTag = setToStringTag$2;
	var defineBuiltIn = defineBuiltIn$2;
	var wellKnownSymbol$2 = wellKnownSymbol$8;
	var Iterators$3 = iterators;
	var IteratorsCore = iteratorsCore;

	var PROPER_FUNCTION_NAME = FunctionName.PROPER;
	FunctionName.CONFIGURABLE;
	IteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol$2('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      Iterators$3[TO_STRING_TAG] = returnThis;
	    }
	  }

	  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
	  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    {
	      INCORRECT_VALUES_NAME = true;
	      defaultIterator = function values() { return call(nativeIterator, this); };
	    }
	  }

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  // define iterator
	  if ((FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    defineBuiltIn(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
	  }
	  Iterators$3[NAME] = defaultIterator;

	  return methods;
	};

	// `CreateIterResultObject` abstract operation
	// https://tc39.es/ecma262/#sec-createiterresultobject
	var createIterResultObject$2 = function (value, done) {
	  return { value: value, done: done };
	};

	var toIndexedObject = toIndexedObject$5;
	var Iterators$2 = iterators;
	var InternalStateModule$1 = internalState;
	objectDefineProperty.f;
	var defineIterator$1 = iteratorDefine;
	var createIterResultObject$1 = createIterResultObject$2;

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = InternalStateModule$1.set;
	var getInternalState$1 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	defineIterator$1(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return createIterResultObject$1(undefined, true);
	  }
	  if (kind == 'keys') return createIterResultObject$1(index, false);
	  if (kind == 'values') return createIterResultObject$1(target[index], false);
	  return createIterResultObject$1([index, target[index]], false);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	Iterators$2.Arguments = Iterators$2.Array;

	var classof$2 = classof$4;

	var $String = String;

	var toString$2 = function (argument) {
	  if (classof$2(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return $String(argument);
	};

	var uncurryThis = functionUncurryThis;
	var toIntegerOrInfinity = toIntegerOrInfinity$3;
	var toString$1 = toString$2;
	var requireObjectCoercible = requireObjectCoercible$3;

	var charAt$1 = uncurryThis(''.charAt);
	var charCodeAt = uncurryThis(''.charCodeAt);
	var stringSlice = uncurryThis(''.slice);

	var createMethod = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString$1(requireObjectCoercible($this));
	    var position = toIntegerOrInfinity(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING
	          ? charAt$1(S, position)
	          : first
	        : CONVERT_TO_STRING
	          ? stringSlice(S, position, position + 2)
	          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod(true)
	};

	var charAt = stringMultibyte.charAt;
	var toString = toString$2;
	var InternalStateModule = internalState;
	var defineIterator = iteratorDefine;
	var createIterResultObject = createIterResultObject$2;

	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState(this, {
	    type: STRING_ITERATOR,
	    string: toString(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return createIterResultObject(undefined, true);
	  point = charAt(string, index);
	  state.index += point.length;
	  return createIterResultObject(point, false);
	});

	var classof$1 = classof$4;
	var hasOwn = hasOwnProperty_1;
	var isNullOrUndefined = isNullOrUndefined$3;
	var wellKnownSymbol$1 = wellKnownSymbol$8;
	var Iterators$1 = iterators;

	var ITERATOR = wellKnownSymbol$1('iterator');
	var $Object = Object;

	var isIterable$6 = function (it) {
	  if (isNullOrUndefined(it)) return false;
	  var O = $Object(it);
	  return O[ITERATOR] !== undefined
	    || '@@iterator' in O
	    || hasOwn(Iterators$1, classof$1(O));
	};

	var isIterable$5 = isIterable$6;

	var isIterable_1 = isIterable$5;

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var DOMIterables = domIterables;
	var global$1 = global$c;
	var classof = classof$4;
	var createNonEnumerableProperty = createNonEnumerableProperty$5;
	var Iterators = iterators;
	var wellKnownSymbol = wellKnownSymbol$8;

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	for (var COLLECTION_NAME in DOMIterables) {
	  var Collection = global$1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	  }
	  Iterators[COLLECTION_NAME] = Iterators.Array;
	}

	var parent$2 = isIterable_1;


	var isIterable$4 = parent$2;

	var parent$1 = isIterable$4;

	var isIterable$3 = parent$1;

	var parent = isIterable$3;

	var isIterable$2 = parent;

	var isIterable$1 = isIterable$2;

	var isIterable = isIterable$1;

	var _isIterable = /*@__PURE__*/getDefaultExportFromCjs(isIterable);

	// generated during release, do not modify

	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */
	const VERSION = '4.2.16';

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */
	function dispatch_dev(type, detail) {
	  document.dispatchEvent(custom_event(type, {
	    version: VERSION,
	    ...detail
	  }, {
	    bubbles: true
	  }));
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append_dev(target, node) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node
	  });
	  append(target, node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert_dev(target, node, anchor) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node,
	    anchor
	  });
	  insert(target, node, anchor);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach_dev(node) {
	  dispatch_dev('SvelteDOMRemove', {
	    node
	  });
	  detach(node);
	}

	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */
	function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
	  const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	  if (has_prevent_default) modifiers.push('preventDefault');
	  if (has_stop_propagation) modifiers.push('stopPropagation');
	  if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	  dispatch_dev('SvelteDOMAddEventListener', {
	    node,
	    event,
	    handler,
	    modifiers
	  });
	  const dispose = listen(node, event, handler, options);
	  return () => {
	    dispatch_dev('SvelteDOMRemoveEventListener', {
	      node,
	      event,
	      handler,
	      modifiers
	    });
	    dispose();
	  };
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr_dev(node, attribute, value) {
	  attr(node, attribute, value);
	  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
	    node,
	    attribute
	  });else dispatch_dev('SvelteDOMSetAttribute', {
	    node,
	    attribute,
	    value
	  });
	}

	/**
	 * @param {Element} node
	 * @param {string} property
	 * @param {any} [value]
	 * @returns {void}
	 */
	function prop_dev(node, property, value) {
	  node[property] = value;
	  dispatch_dev('SvelteDOMSetProperty', {
	    node,
	    property,
	    value
	  });
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data_dev(text, data) {
	  data = '' + data;
	  if (text.data === data) return;
	  dispatch_dev('SvelteDOMSetData', {
	    node: text,
	    data
	  });
	  text.data = /** @type {string} */data;
	}
	function ensure_array_like_dev(arg) {
	  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg) && !(typeof Symbol === 'function' && arg && _isIterable(arg))) {
	    throw new Error('{#each} only works with iterable values.');
	  }
	  return ensure_array_like(arg);
	}

	/**
	 * @returns {void} */
	function validate_slots(name, slot, keys) {
	  for (const slot_key of Object.keys(slot)) {
	    if (!~keys.indexOf(slot_key)) {
	      console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
	    }
	  }
	}
	function construct_svelte_component_dev(component, props) {
	  const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
	  try {
	    const instance = new component(props);
	    if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
	      throw new Error(error_message);
	    }
	    return instance;
	  } catch (err) {
	    const {
	      message
	    } = err;
	    if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
	      throw new Error(error_message);
	    } else {
	      throw err;
	    }
	  }
	}

	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */
	class SvelteComponentDev extends SvelteComponent {
	  /**
	   * For type checking capabilities only.
	   * Does not exist at runtime.
	   * ### DO NOT USE!
	   *
	   * @type {Props}
	   */
	  $$prop_def;
	  /**
	   * For type checking capabilities only.
	   * Does not exist at runtime.
	   * ### DO NOT USE!
	   *
	   * @type {Events}
	   */
	  $$events_def;
	  /**
	   * For type checking capabilities only.
	   * Does not exist at runtime.
	   * ### DO NOT USE!
	   *
	   * @type {Slots}
	   */
	  $$slot_def;

	  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
	  constructor(options) {
	    if (!options || !options.target && !options.$$inline) {
	      throw new Error("'target' is a required option");
	    }
	    super();
	  }

	  /** @returns {void} */
	  $destroy() {
	    super.$destroy();
	    this.$destroy = () => {
	      console.warn('Component was already destroyed'); // eslint-disable-line no-console
	    };
	  }

	  /** @returns {void} */
	  $capture_state() {}

	  /** @returns {void} */
	  $inject_state() {}
	}

	const subscriber_queue = [];

	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#readable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function readable(value, start) {
	  return {
	    subscribe: writable(value, start).subscribe
	  };
	}

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value) {
	  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	  /** @type {import('./public.js').Unsubscriber} */
	  let stop;
	  /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	  const subscribers = new Set();
	  /** @param {T} new_value
	   * @returns {void}
	   */
	  function set(new_value) {
	    if (safe_not_equal(value, new_value)) {
	      value = new_value;
	      if (stop) {
	        // store is ready
	        const run_queue = !subscriber_queue.length;
	        for (const subscriber of subscribers) {
	          subscriber[1]();
	          subscriber_queue.push(subscriber, value);
	        }
	        if (run_queue) {
	          for (let i = 0; i < subscriber_queue.length; i += 2) {
	            subscriber_queue[i][0](subscriber_queue[i + 1]);
	          }
	          subscriber_queue.length = 0;
	        }
	      }
	    }
	  }

	  /**
	   * @param {import('./public.js').Updater<T>} fn
	   * @returns {void}
	   */
	  function update(fn) {
	    set(fn(value));
	  }

	  /**
	   * @param {import('./public.js').Subscriber<T>} run
	   * @param {import('./private.js').Invalidator<T>} [invalidate]
	   * @returns {import('./public.js').Unsubscriber}
	   */
	  function subscribe(run) {
	    let invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	    /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
	    const subscriber = [run, invalidate];
	    subscribers.add(subscriber);
	    if (subscribers.size === 1) {
	      stop = start(set, update) || noop;
	    }
	    run(value);
	    return () => {
	      subscribers.delete(subscriber);
	      if (subscribers.size === 0 && stop) {
	        stop();
	        stop = null;
	      }
	    };
	  }
	  return {
	    set,
	    update,
	    subscribe
	  };
	}

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @param {S} stores
	 * @param {Function} fn
	 * @param {T} [initial_value]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function derived(stores, fn, initial_value) {
	  const single = !Array.isArray(stores);
	  /** @type {Array<import('./public.js').Readable<any>>} */
	  const stores_array = single ? [stores] : stores;
	  if (!stores_array.every(Boolean)) {
	    throw new Error('derived() expects stores as input, got a falsy value');
	  }
	  const auto = fn.length < 2;
	  return readable(initial_value, (set, update) => {
	    let started = false;
	    const values = [];
	    let pending = 0;
	    let cleanup = noop;
	    const sync = () => {
	      if (pending) {
	        return;
	      }
	      cleanup();
	      const result = fn(single ? values[0] : values, set, update);
	      if (auto) {
	        set(result);
	      } else {
	        cleanup = is_function(result) ? result : noop;
	      }
	    };
	    const unsubscribers = stores_array.map((store, i) => subscribe(store, value => {
	      values[i] = value;
	      pending &= ~(1 << i);
	      if (started) {
	        sync();
	      }
	    }, () => {
	      pending |= 1 << i;
	    }));
	    started = true;
	    sync();
	    return function stop() {
	      run_all(unsubscribers);
	      cleanup();
	      // We need to set this to false because callbacks can still happen despite having unsubscribed:
	      // Callbacks might already be placed in the queue which doesn't know it should no longer
	      // invoke this derived store.
	      started = false;
	    };
	  });
	}

	function keyEnter(fn) {
	  return function (e) {
	    return e.key === 'Enter' || e.key === ' ' && !e.preventDefault() // prevent page scroll down
	    ? fn.call(this, e) : undefined;
	  };
	}
	function setContent(node, content) {
	  let actions = {
	    update(content) {
	      if (typeof content == 'string') {
	        node.innerText = content;
	      } else if (content?.domNodes) {
	        node.replaceChildren(...content.domNodes);
	      } else if (content?.html) {
	        node.innerHTML = content.html;
	      }
	    }
	  };
	  actions.update(content);
	  return actions;
	}

	/** Dispatch event occurred outside of node */
	function outsideEvent(node, type) {
	  const handlePointerDown = jsEvent => {
	    if (node && !node.contains(jsEvent.target)) {
	      node.dispatchEvent(new CustomEvent(type + 'outside', {
	        detail: {
	          jsEvent
	        }
	      }));
	    }
	  };
	  document.addEventListener(type, handlePointerDown, true);
	  return {
	    destroy() {
	      document.removeEventListener(type, handlePointerDown, true);
	    }
	  };
	}
	const DAY_IN_SECONDS = 86400;
	function createDate() {
	  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	  if (input !== undefined) {
	    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
	  }
	  return _fromLocalDate(new Date());
	}
	function createDuration(input) {
	  if (typeof input === 'number') {
	    input = {
	      seconds: input
	    };
	  } else if (typeof input === 'string') {
	    // Expected format hh[:mm[:ss]]
	    let seconds = 0,
	      exp = 2;
	    for (let part of input.split(':', 3)) {
	      seconds += parseInt(part, 10) * Math.pow(60, exp--);
	    }
	    input = {
	      seconds
	    };
	  } else if (input instanceof Date) {
	    input = {
	      hours: input.getUTCHours(),
	      minutes: input.getUTCMinutes(),
	      seconds: input.getUTCSeconds()
	    };
	  }
	  let weeks = input.weeks || input.week || 0;
	  return {
	    years: input.years || input.year || 0,
	    months: input.months || input.month || 0,
	    days: weeks * 7 + (input.days || input.day || 0),
	    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
	    inWeeks: !!weeks
	  };
	}
	function cloneDate(date) {
	  return new Date(date.getTime());
	}
	function addDuration(date, duration) {
	  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
	  let month = date.getUTCMonth() + x * duration.months;
	  date.setUTCMonth(month);
	  month %= 12;
	  if (month < 0) {
	    month += 12;
	  }
	  while (date.getUTCMonth() !== month) {
	    subtractDay(date);
	  }
	  date.setUTCDate(date.getUTCDate() + x * duration.days);
	  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
	  return date;
	}
	function subtractDuration(date, duration) {
	  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  return addDuration(date, duration, -x);
	}
	function addDay(date) {
	  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  date.setUTCDate(date.getUTCDate() + x);
	  return date;
	}
	function subtractDay(date) {
	  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  return addDay(date, -x);
	}
	function setMidnight(date) {
	  date.setUTCHours(0, 0, 0, 0);
	  return date;
	}
	function toLocalDate(date) {
	  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
	}
	function toISOString(date) {
	  let len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 19;
	  return date.toISOString().substring(0, len);
	}
	function datesEqual(date1) {
	  for (var _len = arguments.length, dates2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    dates2[_key - 1] = arguments[_key];
	  }
	  return dates2.every(date2 => date1.getTime() === date2.getTime());
	}
	function nextClosestDay(date, day) {
	  let diff = day - date.getUTCDay();
	  date.setUTCDate(date.getUTCDate() + (diff >= 0 ? diff : diff + 7));
	  return date;
	}
	function prevClosestDay(date, day) {
	  let diff = day - date.getUTCDay();
	  date.setUTCDate(date.getUTCDate() + (diff <= 0 ? diff : diff - 7));
	  return date;
	}

	/**
	 * Check whether given date is string which contains no time part
	  */
	function noTimePart(date) {
	  return typeof date === 'string' && date.length <= 10;
	}

	/**
	 * Copy time from one date to another
	 */
	function copyTime(toDate, fromDate) {
	  toDate.setUTCHours(fromDate.getUTCHours(), fromDate.getUTCMinutes(), fromDate.getUTCSeconds(), 0);
	  return toDate;
	}

	/**
	 * Private functions
	 */

	function _fromLocalDate(date) {
	  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
	}
	function _fromISOString(str) {
	  const parts = str.match(/\d+/g);
	  return new Date(Date.UTC(Number(parts[0]), Number(parts[1]) - 1, Number(parts[2]), Number(parts[3] || 0), Number(parts[4] || 0), Number(parts[5] || 0)));
	}
	function debounce(fn, handle, queueStore) {
	  queueStore.update(queue => queue.set(handle, fn));
	}
	function flushDebounce(queue) {
	  run_all(queue);
	  queue.clear();
	}
	function task(fn, handle, tasks) {
	  handle ??= fn;
	  if (!tasks.has(handle)) {
	    tasks.set(handle, setTimeout(() => {
	      tasks.delete(handle);
	      fn();
	    }));
	  }
	}
	function assign() {
	  return Object.assign(...arguments);
	}
	function keys(object) {
	  return Object.keys(object);
	}
	function floor(value) {
	  return Math.floor(value);
	}
	function min() {
	  return Math.min(...arguments);
	}
	function max() {
	  return Math.max(...arguments);
	}
	function symbol() {
	  return Symbol('ec');
	}
	function createElement(tag, className, content) {
	  let attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
	  let el = document.createElement(tag);
	  el.className = className;
	  if (typeof content == 'string') {
	    el.innerText = content;
	  } else if (content.domNodes) {
	    el.replaceChildren(...content.domNodes);
	  } else if (content.html) {
	    el.innerHTML = content.html;
	  }
	  for (let attr of attrs) {
	    el.setAttribute(...attr);
	  }
	  return el;
	}
	function hasYScroll(el) {
	  return el.scrollHeight > el.clientHeight;
	}
	function rect(el) {
	  return el.getBoundingClientRect();
	}
	function ancestor(el, up) {
	  while (up--) {
	    el = el.parentElement;
	  }
	  return el;
	}
	function height(el) {
	  return rect(el).height;
	}
	let payloadProp = symbol();
	function setPayload(el, payload) {
	  el[payloadProp] = payload;
	}
	function hasPayload(el) {
	  return !!el?.[payloadProp];
	}
	function getPayload(el) {
	  return el[payloadProp];
	}
	function getElementWithPayload(x, y) {
	  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
	  for (let el of root.elementsFromPoint(x, y)) {
	    if (hasPayload(el)) {
	      return el;
	    }
	    /** @see https://github.com/vkurko/calendar/issues/142 */
	    if (el.shadowRoot) {
	      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
	      if (shadowEl) {
	        return shadowEl;
	      }
	    }
	  }
	  return null;
	}
	function createView(view, _viewTitle, _currentRange, _activeRange) {
	  return {
	    type: view,
	    title: _viewTitle,
	    currentStart: _currentRange.start,
	    currentEnd: _currentRange.end,
	    activeStart: _activeRange.start,
	    activeEnd: _activeRange.end,
	    calendar: undefined
	  };
	}
	function toViewWithLocalDates(view) {
	  view = assign({}, view);
	  view.currentStart = toLocalDate(view.currentStart);
	  view.currentEnd = toLocalDate(view.currentEnd);
	  view.activeStart = toLocalDate(view.activeStart);
	  view.activeEnd = toLocalDate(view.activeEnd);
	  return view;
	}
	function listView(view) {
	  return view.startsWith('list');
	}
	let eventId = 1;
	function createEvents(input) {
	  return input.map(event => ({
	    id: 'id' in event ? String(event.id) : `{generated-${eventId++}}`,
	    resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : 'resourceId' in event ? [String(event.resourceId)] : [],
	    allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
	    start: createDate(event.start),
	    end: createDate(event.end),
	    title: event.title || '',
	    titleHTML: event.titleHTML || '',
	    editable: event.editable,
	    startEditable: event.startEditable,
	    durationEditable: event.durationEditable,
	    display: event.display || 'auto',
	    extendedProps: event.extendedProps || {},
	    backgroundColor: event.backgroundColor || event.color,
	    textColor: event.textColor
	  }));
	}
	function createEventSources(input) {
	  return input.map(source => ({
	    events: source.events,
	    url: source.url && source.url.trimEnd('&') || '',
	    method: source.method && source.method.toUpperCase() || 'GET',
	    extraParams: source.extraParams || {}
	  }));
	}
	function createEventChunk(event, start, end) {
	  return {
	    start: event.start > start ? event.start : start,
	    end: event.end < end ? event.end : end,
	    event
	  };
	}
	function sortEventChunks(chunks) {
	  // Sort by start date (all-day events always on top)
	  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
	}
	function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
	  let timeText = _intlEventTime.formatRange(chunk.start, displayEventEnd && chunk.event.display !== 'pointer' ? copyTime(cloneDate(chunk.start), chunk.end) // make Intl.formatRange output only the time part
	  : chunk.start);
	  let content;
	  if (eventContent) {
	    content = is_function(eventContent) ? eventContent({
	      event: toEventWithLocalDates(chunk.event),
	      timeText,
	      view: toViewWithLocalDates(_view)
	    }) : eventContent;
	  } else {
	    let domNodes;
	    switch (chunk.event.display) {
	      case 'background':
	        domNodes = [];
	        break;
	      case 'pointer':
	        domNodes = [createTimeElement(timeText, chunk, theme)];
	        break;
	      default:
	        domNodes = [...(chunk.event.allDay ? [] : [createTimeElement(timeText, chunk, theme)]), createElement('h4', theme.eventTitle, chunk.event.title)];
	    }
	    content = {
	      domNodes
	    };
	  }
	  return [timeText, content];
	}
	function createTimeElement(timeText, chunk, theme) {
	  return createElement('time', theme.eventTime, timeText, [['datetime', toISOString(chunk.start)]]);
	}
	function createEventClasses(eventClassNames, event, _view) {
	  if (eventClassNames) {
	    if (is_function(eventClassNames)) {
	      eventClassNames = eventClassNames({
	        event: toEventWithLocalDates(event),
	        view: toViewWithLocalDates(_view)
	      });
	    }
	    return Array.isArray(eventClassNames) ? eventClassNames : [eventClassNames];
	  }
	  return [];
	}
	function toEventWithLocalDates(event) {
	  return _cloneEvent(event, toLocalDate);
	}
	function cloneEvent(event) {
	  return _cloneEvent(event, cloneDate);
	}
	function _cloneEvent(event, dateFn) {
	  event = assign({}, event);
	  event.start = dateFn(event.start);
	  event.end = dateFn(event.end);
	  return event;
	}

	/**
	 * Prepare event chunks for month view and all-day slot in week view
	 */
	function prepareEventChunks(chunks, hiddenDays) {
	  let longChunks = {};
	  if (chunks.length) {
	    sortEventChunks(chunks);
	    let prevChunk;
	    for (let chunk of chunks) {
	      let dates = [];
	      let date = setMidnight(cloneDate(chunk.start));
	      while (chunk.end > date) {
	        if (!hiddenDays.includes(date.getUTCDay())) {
	          dates.push(cloneDate(date));
	          if (dates.length > 1) {
	            let key = date.getTime();
	            if (longChunks[key]) {
	              longChunks[key].chunks.push(chunk);
	            } else {
	              longChunks[key] = {
	                sorted: false,
	                chunks: [chunk]
	              };
	            }
	          }
	        }
	        addDay(date);
	      }
	      if (dates.length) {
	        chunk.date = dates[0];
	        chunk.days = dates.length;
	        chunk.dates = dates;
	        if (chunk.start < dates[0]) {
	          chunk.start = dates[0];
	        }
	        if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
	          chunk.end = dates[dates.length - 1];
	        }
	      } else {
	        chunk.date = setMidnight(cloneDate(chunk.start));
	        chunk.days = 1;
	        chunk.dates = [chunk.date];
	      }
	      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
	        chunk.prev = prevChunk;
	      }
	      prevChunk = chunk;
	    }
	  }
	  return longChunks;
	}
	function repositionEvent(chunk, longChunks, height) {
	  chunk.top = 0;
	  if (chunk.prev) {
	    chunk.top = chunk.prev.bottom + 1;
	  }
	  chunk.bottom = chunk.top + height;
	  let margin = 1;
	  let key = chunk.date.getTime();
	  if (longChunks[key]?.sorted || longChunks[key]?.chunks.every(chunk => 'top' in chunk)) {
	    if (!longChunks[key].sorted) {
	      longChunks[key].chunks.sort((a, b) => a.top - b.top);
	      longChunks[key].sorted = true;
	    }
	    for (let longChunk of longChunks[key].chunks) {
	      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
	        let offset = longChunk.bottom - chunk.top + 1;
	        margin += offset;
	        chunk.top += offset;
	        chunk.bottom += offset;
	      }
	    }
	  }
	  return margin;
	}
	function runReposition(refs, data) {
	  refs.length = data.length;
	  for (let ref of refs) {
	    ref?.reposition?.();
	  }
	}

	/**
	 * Check whether the event intersects with the given date range and resource
	 * @param event
	 * @param start
	 * @param end
	 * @param [resource]
	 * @param [timeMode]  Zero-length events should be allowed (@see https://github.com/vkurko/calendar/issues/50), except in time mode
	 * @return boolean
	 */
	function eventIntersects(event, start, end, resource, timeMode) {
	  return (event.start < end && event.end > start || !timeMode && datesEqual(event.start, event.end, start)) && (resource === undefined || event.resourceIds.includes(resource.id));
	}
	function helperEvent(display) {
	  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
	}
	function bgEvent(display) {
	  return display === 'background';
	}
	function previewEvent(display) {
	  return display === 'preview';
	}
	function ghostEvent(display) {
	  return display === 'ghost';
	}
	function pointerEvent(display) {
	  return display === 'pointer';
	}
	function btnTextDay(text) {
	  return btnText(text, 'day');
	}
	function btnTextWeek(text) {
	  return btnText(text, 'week');
	}
	function btnTextMonth(text) {
	  return btnText(text, 'month');
	}
	function btnTextYear(text) {
	  return btnText(text, 'year');
	}
	function btnText(text, period) {
	  return {
	    ...text,
	    next: 'Next ' + period,
	    prev: 'Previous ' + period
	  };
	}
	function themeView(view) {
	  return theme => ({
	    ...theme,
	    view
	  });
	}
	function intl(locale, format) {
	  return derived([locale, format], _ref => {
	    let [$locale, $format] = _ref;
	    let intl = is_function($format) ? {
	      format: $format
	    } : new Intl.DateTimeFormat($locale, $format);
	    return {
	      format: date => intl.format(toLocalDate(date))
	    };
	  });
	}
	function intlRange(locale, format) {
	  return derived([locale, format], _ref2 => {
	    let [$locale, $format] = _ref2;
	    let formatRange;
	    if (is_function($format)) {
	      formatRange = $format;
	    } else {
	      let intl = new Intl.DateTimeFormat($locale, $format);
	      formatRange = (start, end) => {
	        if (start <= end) {
	          return intl.formatRange(start, end);
	        } else {
	          // In iOS 16 and older, intl.formatRange() throws an exception if the start date is later than the end date.
	          // Therefore, we first swap the parameters, and then swap the resulting parts.
	          /** @see https://github.com/vkurko/calendar/issues/227 */
	          let parts = intl.formatRangeToParts(end, start);
	          let result = '';
	          let sources = ['startRange', 'endRange'];
	          let processed = [false, false];
	          for (let part of parts) {
	            let i = sources.indexOf(part.source);
	            if (i >= 0) {
	              if (!processed[i]) {
	                result += _getParts(sources[1 - i], parts);
	                processed[i] = true;
	              }
	            } else {
	              result += part.value;
	            }
	          }
	          return result;
	        }
	      };
	    }
	    return {
	      formatRange: (start, end) => formatRange(toLocalDate(start), toLocalDate(end))
	    };
	  });
	}
	function _getParts(source, parts) {
	  let result = '';
	  for (let part of parts) {
	    if (part.source == source) {
	      result += part.value;
	    }
	  }
	  return result;
	}
	function createOptions(plugins) {
	  let options = {
	    allDayContent: undefined,
	    allDaySlot: true,
	    buttonText: {
	      today: "today"
	    },
	    customButtons: {},
	    date: new Date(),
	    datesSet: undefined,
	    dayHeaderFormat: {
	      weekday: "short",
	      month: "numeric",
	      day: "numeric"
	    },
	    dayHeaderAriaLabelFormat: {
	      dateStyle: "long"
	    },
	    displayEventEnd: true,
	    duration: {
	      weeks: 1
	    },
	    events: [],
	    eventAllUpdated: undefined,
	    eventBackgroundColor: undefined,
	    eventTextColor: undefined,
	    eventClassNames: undefined,
	    eventClick: undefined,
	    eventColor: undefined,
	    eventContent: undefined,
	    eventDidMount: undefined,
	    eventMouseEnter: undefined,
	    eventMouseLeave: undefined,
	    eventSources: [],
	    eventTimeFormat: {
	      hour: "numeric",
	      minute: "2-digit"
	    },
	    firstDay: 0,
	    flexibleSlotTimeLimits: false,
	    // ec option
	    headerToolbar: {
	      start: "title",
	      center: "",
	      end: "today prev,next"
	    },
	    height: undefined,
	    hiddenDays: [],
	    highlightedDates: [],
	    // ec option
	    lazyFetching: true,
	    loading: undefined,
	    locale: undefined,
	    nowIndicator: false,
	    selectable: false,
	    scrollTime: "06:00:00",
	    slotDuration: "00:30:00",
	    slotEventOverlap: true,
	    slotHeight: 24,
	    // ec option
	    slotLabelFormat: {
	      hour: "numeric",
	      minute: "2-digit"
	    },
	    slotMaxTime: "24:00:00",
	    slotMinTime: "00:00:00",
	    theme: {
	      allDay: "ec-all-day",
	      active: "ec-active",
	      bgEvent: "ec-bg-event",
	      bgEvents: "ec-bg-events",
	      body: "ec-body",
	      button: "ec-button",
	      buttonGroup: "ec-button-group",
	      calendar: "ec",
	      compact: "ec-compact",
	      content: "ec-content",
	      day: "ec-day",
	      dayHead: "ec-day-head",
	      days: "ec-days",
	      event: "ec-event",
	      eventBody: "ec-event-body",
	      eventTime: "ec-event-time",
	      eventTitle: "ec-event-title",
	      events: "ec-events",
	      extra: "ec-extra",
	      handle: "ec-handle",
	      header: "ec-header",
	      hiddenScroll: "ec-hidden-scroll",
	      highlight: "ec-highlight",
	      icon: "ec-icon",
	      line: "ec-line",
	      lines: "ec-lines",
	      nowIndicator: "ec-now-indicator",
	      otherMonth: "ec-other-month",
	      sidebar: "ec-sidebar",
	      sidebarTitle: "ec-sidebar-title",
	      today: "ec-today",
	      time: "ec-time",
	      title: "ec-title",
	      toolbar: "ec-toolbar",
	      view: "",
	      weekdays: ["ec-sun", "ec-mon", "ec-tue", "ec-wed", "ec-thu", "ec-fri", "ec-sat"],
	      withScroll: "ec-with-scroll"
	    },
	    titleFormat: {
	      year: "numeric",
	      month: "short",
	      day: "numeric"
	    },
	    view: undefined,
	    viewDidMount: undefined,
	    viewDropDownOptions: [],
	    views: {}
	  };
	  for (let plugin of plugins) {
	    plugin.createOptions?.(options);
	  }
	  return options;
	}
	function createParsers(plugins) {
	  let parsers = {
	    date: date => setMidnight(createDate(date)),
	    duration: createDuration,
	    events: createEvents,
	    eventSources: createEventSources,
	    hiddenDays: days => [...new Set(days)],
	    highlightedDates: dates => dates.map(createDate),
	    scrollTime: createDuration,
	    slotDuration: createDuration,
	    slotMaxTime: createDuration,
	    slotMinTime: createDuration
	  };
	  for (let plugin of plugins) {
	    plugin.createParsers?.(parsers);
	  }
	  return parsers;
	}
	function diff(options, prevOptions) {
	  let diff = [];
	  for (let key of keys(options)) {
	    if (options[key] !== prevOptions[key]) {
	      diff.push([key, options[key]]);
	    }
	  }
	  assign(prevOptions, options);
	  return diff;
	}
	function dayGrid(state) {
	  return derived(state.view, $view => $view?.startsWith('dayGrid'));
	}
	function activeRange(state) {
	  return derived([state._currentRange, state.firstDay, state.slotMaxTime, state._dayGrid], _ref3 => {
	    let [$_currentRange, $firstDay, $slotMaxTime, $_dayGrid] = _ref3;
	    let start = cloneDate($_currentRange.start);
	    let end = cloneDate($_currentRange.end);
	    if ($_dayGrid) {
	      // First day of week
	      prevClosestDay(start, $firstDay);
	      nextClosestDay(end, $firstDay);
	    } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
	      addDuration(subtractDay(end), $slotMaxTime);
	      let start2 = subtractDay(cloneDate(end));
	      if (start2 < start) {
	        start = start2;
	      }
	    }
	    return {
	      start,
	      end
	    };
	  });
	}
	function currentRange(state) {
	  return derived([state.date, state.duration, state.firstDay, state._dayGrid], _ref4 => {
	    let [$date, $duration, $firstDay, $_dayGrid] = _ref4;
	    let start = cloneDate($date),
	      end;
	    if ($_dayGrid) {
	      start.setUTCDate(1);
	    } else if ($duration.inWeeks) {
	      // First day of week
	      prevClosestDay(start, $firstDay);
	    }
	    end = addDuration(cloneDate(start), $duration);
	    return {
	      start,
	      end
	    };
	  });
	}
	function viewDates(state) {
	  return derived([state._activeRange, state.hiddenDays], _ref5 => {
	    let [$_activeRange, $hiddenDays] = _ref5;
	    let dates = [];
	    let date = setMidnight(cloneDate($_activeRange.start));
	    let end = setMidnight(cloneDate($_activeRange.end));
	    while (date < end) {
	      if (!$hiddenDays.includes(date.getUTCDay())) {
	        dates.push(cloneDate(date));
	      }
	      addDay(date);
	    }
	    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
	      // Try to move the date
	      state.date.update(date => {
	        while ($hiddenDays.includes(date.getUTCDay())) {
	          addDay(date);
	        }
	        return date;
	      });
	      dates = get_store_value(state._viewDates);
	    }
	    return dates;
	  });
	}
	function viewTitle(state) {
	  return derived([state.date, state._activeRange, state._intlTitle, state._dayGrid], _ref6 => {
	    let [$date, $_activeRange, $_intlTitle, $_dayGrid] = _ref6;
	    return $_dayGrid ? $_intlTitle.formatRange($date, $date) : $_intlTitle.formatRange($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
	  });
	}
	function view(state) {
	  return derived([state.view, state._viewTitle, state._currentRange, state._activeRange], args => createView(...args));
	}
	function events(state) {
	  let _events = writable([]);
	  let abortController;
	  let fetching = 0;
	  let debounceHandle = {};
	  derived([state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading], (values, set) => debounce(() => {
	    let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
	    if (!$eventSources.length) {
	      set($events);
	      return;
	    }
	    // Do not fetch if new range is within the previous one
	    if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
	      if (abortController) {
	        // Abort previous request
	        abortController.abort();
	      }
	      // Create new abort controller
	      abortController = new AbortController();
	      // Call loading hook
	      if (is_function($loading) && !fetching) {
	        $loading(true);
	      }
	      let stopLoading = () => {
	        if (--fetching === 0 && is_function($loading)) {
	          $loading(false);
	        }
	      };
	      let events = [];
	      // Prepare handlers
	      let failure = e => stopLoading();
	      let success = data => {
	        events = events.concat(createEvents(data));
	        set(events);
	        stopLoading();
	      };
	      // Prepare other stuff
	      let startStr = toISOString($_activeRange.start);
	      let endStr = toISOString($_activeRange.end);
	      // Loop over event sources
	      for (let source of $eventSources) {
	        if (is_function(source.events)) {
	          // Events as a function
	          let result = source.events({
	            start: toLocalDate($_activeRange.start),
	            end: toLocalDate($_activeRange.end),
	            startStr,
	            endStr
	          }, success, failure);
	          if (result !== undefined) {
	            Promise.resolve(result).then(success, failure);
	          }
	        } else {
	          // Events as a JSON feed
	          // Prepare params
	          let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
	          params.start = startStr;
	          params.end = endStr;
	          params = new URLSearchParams(params);
	          // Prepare fetch
	          let url = source.url,
	            headers = {},
	            body;
	          if (['GET', 'HEAD'].includes(source.method)) {
	            url += (url.includes('?') ? '&' : '?') + params;
	          } else {
	            headers['content-type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
	            body = String(params); // Safari 10.1 doesn't convert to string automatically
	          }
	          // Do the fetch
	          fetch(url, {
	            method: source.method,
	            headers,
	            body,
	            signal: abortController.signal,
	            credentials: 'same-origin'
	          }).then(response => response.json()).then(success).catch(failure);
	        }
	        ++fetching;
	      }
	      // Save current range for future requests
	      $_fetchedRange.start = $_activeRange.start;
	      $_fetchedRange.end = $_activeRange.end;
	    }
	  }, debounceHandle, state._queue), []).subscribe(_events.set);
	  return _events;
	}
	function now() {
	  return readable(createDate(), set => {
	    let interval = setInterval(() => {
	      set(createDate());
	    }, 1000);
	    return () => clearInterval(interval);
	  });
	}
	function today(state) {
	  return derived(state._now, $_now => setMidnight(cloneDate($_now)));
	}
	class State {
	  constructor(plugins, input) {
	    plugins = plugins || [];

	    // Create options
	    let options = createOptions(plugins);
	    let parsers = createParsers(plugins);

	    // Parse options
	    options = parseOpts(options, parsers);
	    input = parseOpts(input, parsers);

	    // Create stores for options
	    for (let [option, value] of Object.entries(options)) {
	      this[option] = writable(value);
	    }

	    // Private stores
	    this._queue = writable(new Map()); // debounce queue (beforeUpdate)
	    this._queue2 = writable(new Map()); // debounce queue (afterUpdate)
	    this._tasks = new Map(); // timeout IDs for tasks
	    this._auxiliary = writable([]); // auxiliary components
	    this._dayGrid = dayGrid(this);
	    this._currentRange = currentRange(this);
	    this._activeRange = activeRange(this);
	    this._fetchedRange = writable({
	      start: undefined,
	      end: undefined
	    });
	    this._events = events(this);
	    this._now = now();
	    this._today = today(this);
	    this._intlEventTime = intlRange(this.locale, this.eventTimeFormat);
	    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
	    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
	    this._intlDayHeaderAL = intl(this.locale, this.dayHeaderAriaLabelFormat);
	    this._intlTitle = intlRange(this.locale, this.titleFormat);
	    this._bodyEl = writable(undefined);
	    this._scrollable = writable(false);
	    this._viewTitle = viewTitle(this);
	    this._viewDates = viewDates(this);
	    this._view = view(this);
	    this._viewComponent = writable(undefined);
	    // Resources
	    this._resBgColor = writable(noop);
	    this._resTxtColor = writable(noop);
	    // Interaction
	    this._interaction = writable({});
	    this._iEvents = writable([null, null]); // interaction events: [drag/resize, pointer]
	    this._iClasses = writable(identity); // interaction event css classes
	    this._iClass = writable(undefined); // interaction css class for entire calendar

	    // Set & Get
	    this._set = (key, value) => {
	      if (validKey(key, this)) {
	        if (parsers[key]) {
	          value = parsers[key](value);
	        }
	        this[key].set(value);
	      }
	    };
	    this._get = key => validKey(key, this) ? get_store_value(this[key]) : undefined;

	    // Let plugins create their private stores
	    for (let plugin of plugins) {
	      plugin.createStores?.(this);
	    }
	    if (input.view) {
	      // Set initial view based on input
	      this.view.set(input.view);
	    }

	    // Set options for each view
	    let views = new Set([...keys(options.views), ...keys(input.views ?? {})]);
	    for (let view of views) {
	      let defOpts = mergeOpts(options, options.views[view] ?? {});
	      let opts = mergeOpts(defOpts, input, input.views?.[view] ?? {});
	      let component = opts.component;
	      // Make sure we deal with valid opts from now on
	      filterOpts(opts, this);
	      // Process options
	      for (let key of keys(opts)) {
	        let {
	          set,
	          _set = set,
	          ...rest
	        } = this[key];
	        this[key] = {
	          // Set value in all views
	          set: ['buttonText', 'theme'].includes(key) ? value => {
	            if (is_function(value)) {
	              let result = value(defOpts[key]);
	              opts[key] = result;
	              set(set === _set ? result : value);
	            } else {
	              opts[key] = value;
	              set(value);
	            }
	          } : value => {
	            opts[key] = value;
	            set(value);
	          },
	          _set,
	          ...rest
	        };
	      }
	      // When view changes...
	      this.view.subscribe(newView => {
	        if (newView === view) {
	          // switch view component
	          this._viewComponent.set(component);
	          if (is_function(opts.viewDidMount)) {
	            tick().then(() => opts.viewDidMount(get_store_value(this._view)));
	          }
	          // update store values
	          for (let key of keys(opts)) {
	            this[key]._set(opts[key]);
	          }
	        }
	      });
	    }
	  }
	}
	function parseOpts(opts, parsers) {
	  let result = {
	    ...opts
	  };
	  for (let key of keys(parsers)) {
	    if (key in result) {
	      result[key] = parsers[key](result[key]);
	    }
	  }
	  if (opts.views) {
	    result.views = {};
	    for (let view of keys(opts.views)) {
	      result.views[view] = parseOpts(opts.views[view], parsers);
	    }
	  }
	  return result;
	}
	function mergeOpts() {
	  let result = {};
	  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	    args[_key2] = arguments[_key2];
	  }
	  for (let opts of args) {
	    let override = {};
	    for (let key of ['buttonText', 'theme']) {
	      if (is_function(opts[key])) {
	        override[key] = opts[key](result[key]);
	      }
	    }
	    result = {
	      ...result,
	      ...opts,
	      ...override
	    };
	  }
	  return result;
	}
	function filterOpts(opts, state) {
	  keys(opts).filter(key => !validKey(key, state) || key == 'view').forEach(key => delete opts[key]);
	}
	function validKey(key, state) {
	  return state.hasOwnProperty(key) && key[0] !== '_';
	}

	/* packages/core/src/Buttons.svelte generated by Svelte v4.2.16 */

	const file$2$4 = "packages/core/src/Buttons.svelte";
	function get_each_context$2$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[28] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[31] = list[i];
	  return child_ctx;
	}

	// (91:27) 
	function create_if_block_6(ctx) {
	  let button_1;
	  let t_value = /*$buttonText*/ctx[5][/*button*/ctx[28]] + "";
	  let t;
	  let button_1_class_value;
	  let mounted;
	  let dispose;
	  function click_handler_1() {
	    return /*click_handler_1*/ctx[25]( /*button*/ctx[28]);
	  }
	  const block = {
	    c: function create() {
	      button_1 = element("button");
	      t = text(t_value);
	      attr_dev(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + ( /*$view*/ctx[7] === /*button*/ctx[28] ? ' ' + /*$theme*/ctx[3].active : '') + " ec-" + /*button*/ctx[28]));
	      add_location(button_1, file$2$4, 91, 8, 2604);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, button_1, anchor);
	      append_dev(button_1, t);
	      if (!mounted) {
	        dispose = listen_dev(button_1, "click", click_handler_1, false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*$buttonText, buttons*/33 && t_value !== (t_value = /*$buttonText*/ctx[5][/*button*/ctx[28]] + "")) set_data_dev(t, t_value);
	      if (dirty[0] & /*$theme, $view, buttons, $viewDropDownOptions*/201 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + ( /*$view*/ctx[7] === /*button*/ctx[28] ? ' ' + /*$theme*/ctx[3].active : '') + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(button_1, "class", button_1_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_6.name,
	    type: "if",
	    source: "(91:27) ",
	    ctx
	  });
	  return block;
	}

	// (85:37) 
	function create_if_block_5(ctx) {
	  let button_1;
	  let t_value = /*$customButtons*/ctx[8][/*button*/ctx[28]].text + "";
	  let t;
	  let button_1_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      button_1 = element("button");
	      t = text(t_value);
	      attr_dev(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]));
	      add_location(button_1, file$2$4, 85, 8, 2399);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, button_1, anchor);
	      append_dev(button_1, t);
	      if (!mounted) {
	        dispose = listen_dev(button_1, "click", function () {
	          if (is_function( /*$customButtons*/ctx[8][/*button*/ctx[28]].click)) /*$customButtons*/ctx[8][/*button*/ctx[28]].click.apply(this, arguments);
	        }, false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*$customButtons, buttons*/257 && t_value !== (t_value = /*$customButtons*/ctx[8][/*button*/ctx[28]].text + "")) set_data_dev(t, t_value);
	      if (dirty[0] & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(button_1, "class", button_1_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_5.name,
	    type: "if",
	    source: "(85:37) ",
	    ctx
	  });
	  return block;
	}

	// (73:39) 
	function create_if_block_4$1(ctx) {
	  let select;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let select_class_value;
	  let select_style_value;
	  let mounted;
	  let dispose;
	  let each_value_1 = ensure_array_like_dev( /*$viewDropDownOptions*/ctx[6]);
	  const get_key = ctx => /*key*/ctx[31];
	  validate_each_keys(ctx, each_value_1, get_each_context_1$1$1, get_key);
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    let child_ctx = get_each_context_1$1$1(ctx, each_value_1, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1$1(key, child_ctx));
	  }
	  const block = {
	    c: function create() {
	      select = element("select");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(select, "class", select_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]));
	      attr_dev(select, "style", select_style_value = /*$viewDropDownOptions*/ctx[6].length === 0 ? "visibility: hidden" : "");
	      if ( /*$view*/ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ctx[24].call(select));
	      add_location(select, file$2$4, 73, 8, 1986);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, select, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(select, null);
	        }
	      }
	      select_option(select, /*$view*/ctx[7], true);
	      if (!mounted) {
	        dispose = listen_dev(select, "change", /*select_change_handler*/ctx[24]);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$viewDropDownOptions, $buttonText*/96) {
	        each_value_1 = ensure_array_like_dev( /*$viewDropDownOptions*/ctx[6]);
	        validate_each_keys(ctx, each_value_1, get_each_context_1$1$1, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, select, destroy_block, create_each_block_1$1$1, null, get_each_context_1$1$1);
	      }
	      if (dirty[0] & /*$theme, buttons*/9 && select_class_value !== (select_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(select, "class", select_class_value);
	      }
	      if (dirty[0] & /*$viewDropDownOptions*/64 && select_style_value !== (select_style_value = /*$viewDropDownOptions*/ctx[6].length === 0 ? "visibility: hidden" : "")) {
	        attr_dev(select, "style", select_style_value);
	      }
	      if (dirty[0] & /*$view, $viewDropDownOptions*/192) {
	        select_option(select, /*$view*/ctx[7]);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(select);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_4$1.name,
	    type: "if",
	    source: "(73:39) ",
	    ctx
	  });
	  return block;
	}

	// (67:32) 
	function create_if_block_3$2(ctx) {
	  let button_1;
	  let t_value = /*$buttonText*/ctx[5][/*button*/ctx[28]] + "";
	  let t;
	  let button_1_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      button_1 = element("button");
	      t = text(t_value);
	      attr_dev(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]));
	      button_1.disabled = /*isToday*/ctx[1];
	      add_location(button_1, file$2$4, 67, 8, 1755);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, button_1, anchor);
	      append_dev(button_1, t);
	      if (!mounted) {
	        dispose = listen_dev(button_1, "click", /*click_handler*/ctx[23], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$buttonText, buttons*/33 && t_value !== (t_value = /*$buttonText*/ctx[5][/*button*/ctx[28]] + "")) set_data_dev(t, t_value);
	      if (dirty[0] & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(button_1, "class", button_1_class_value);
	      }
	      if (dirty[0] & /*isToday*/2) {
	        prop_dev(button_1, "disabled", /*isToday*/ctx[1]);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_3$2.name,
	    type: "if",
	    source: "(67:32) ",
	    ctx
	  });
	  return block;
	}

	// (60:31) 
	function create_if_block_2$3(ctx) {
	  let button_1;
	  let i;
	  let i_class_value;
	  let button_1_class_value;
	  let button_1_aria_label_value;
	  let button_1_title_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      button_1 = element("button");
	      i = element("i");
	      attr_dev(i, "class", i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[28]));
	      add_location(i, file$2$4, 64, 28, 1654);
	      attr_dev(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]));
	      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/ctx[5].next);
	      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/ctx[5].next);
	      add_location(button_1, file$2$4, 60, 8, 1491);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, button_1, anchor);
	      append_dev(button_1, i);
	      if (!mounted) {
	        dispose = listen_dev(button_1, "click", /*next*/ctx[21], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, buttons*/9 && i_class_value !== (i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(i, "class", i_class_value);
	      }
	      if (dirty[0] & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(button_1, "class", button_1_class_value);
	      }
	      if (dirty[0] & /*$buttonText*/32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/ctx[5].next)) {
	        attr_dev(button_1, "aria-label", button_1_aria_label_value);
	      }
	      if (dirty[0] & /*$buttonText*/32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/ctx[5].next)) {
	        attr_dev(button_1, "title", button_1_title_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$3.name,
	    type: "if",
	    source: "(60:31) ",
	    ctx
	  });
	  return block;
	}

	// (53:31) 
	function create_if_block_1$3(ctx) {
	  let button_1;
	  let i;
	  let i_class_value;
	  let button_1_class_value;
	  let button_1_aria_label_value;
	  let button_1_title_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      button_1 = element("button");
	      i = element("i");
	      attr_dev(i, "class", i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[28]));
	      add_location(i, file$2$4, 57, 28, 1391);
	      attr_dev(button_1, "class", button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]));
	      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/ctx[5].prev);
	      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/ctx[5].prev);
	      add_location(button_1, file$2$4, 53, 8, 1228);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, button_1, anchor);
	      append_dev(button_1, i);
	      if (!mounted) {
	        dispose = listen_dev(button_1, "click", /*prev*/ctx[20], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, buttons*/9 && i_class_value !== (i_class_value = "" + ( /*$theme*/ctx[3].icon + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(i, "class", i_class_value);
	      }
	      if (dirty[0] & /*$theme, buttons*/9 && button_1_class_value !== (button_1_class_value = "" + ( /*$theme*/ctx[3].button + " ec-" + /*button*/ctx[28]))) {
	        attr_dev(button_1, "class", button_1_class_value);
	      }
	      if (dirty[0] & /*$buttonText*/32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/ctx[5].prev)) {
	        attr_dev(button_1, "aria-label", button_1_aria_label_value);
	      }
	      if (dirty[0] & /*$buttonText*/32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/ctx[5].prev)) {
	        attr_dev(button_1, "title", button_1_title_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(button_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$3.name,
	    type: "if",
	    source: "(53:31) ",
	    ctx
	  });
	  return block;
	}

	// (50:4) {#if button == "title"}
	function create_if_block$1$3(ctx) {
	  let h2;
	  let h2_class_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      h2 = element("h2");
	      attr_dev(h2, "class", h2_class_value = /*$theme*/ctx[3].title);
	      add_location(h2, file$2$4, 51, 8, 1128);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, h2, anchor);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, h2, /*$_viewTitle*/ctx[4]));
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme*/8 && h2_class_value !== (h2_class_value = /*$theme*/ctx[3].title)) {
	        attr_dev(h2, "class", h2_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_viewTitle*/16) setContent_action.update.call(null, /*$_viewTitle*/ctx[4]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(h2);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1$3.name,
	    type: "if",
	    source: "(50:4) {#if button == \\\"title\\\"}",
	    ctx
	  });
	  return block;
	}

	// (81:12) {#each $viewDropDownOptions as key (key)}
	function create_each_block_1$1$1(key_2, ctx) {
	  let option;
	  let t_value = /*$buttonText*/ctx[5][/*key*/ctx[31]] + "";
	  let t;
	  let option_value_value;
	  const block = {
	    key: key_2,
	    first: null,
	    c: function create() {
	      option = element("option");
	      t = text(t_value);
	      option.__value = option_value_value = /*key*/ctx[31];
	      set_input_value(option, option.__value);
	      add_location(option, file$2$4, 81, 16, 2267);
	      this.first = option;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, option, anchor);
	      append_dev(option, t);
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*$buttonText, $viewDropDownOptions*/96 && t_value !== (t_value = /*$buttonText*/ctx[5][/*key*/ctx[31]] + "")) set_data_dev(t, t_value);
	      if (dirty[0] & /*$viewDropDownOptions*/64 && option_value_value !== (option_value_value = /*key*/ctx[31])) {
	        prop_dev(option, "__value", option_value_value);
	        set_input_value(option, option.__value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(option);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1$1$1.name,
	    type: "each",
	    source: "(81:12) {#each $viewDropDownOptions as key (key)}",
	    ctx
	  });
	  return block;
	}

	// (49:0) {#each buttons as button}
	function create_each_block$2$2(ctx) {
	  let if_block_anchor;
	  function select_block_type(ctx, dirty) {
	    if ( /*button*/ctx[28] == "title") return create_if_block$1$3;
	    if ( /*button*/ctx[28] == "prev") return create_if_block_1$3;
	    if ( /*button*/ctx[28] == "next") return create_if_block_2$3;
	    if ( /*button*/ctx[28] == "today") return create_if_block_3$2;
	    if ( /*button*/ctx[28] == "viewDropDown") return create_if_block_4$1;
	    if ( /*$customButtons*/ctx[8][/*button*/ctx[28]]) return create_if_block_5;
	    if ( /*button*/ctx[28] != "") return create_if_block_6;
	  }
	  let current_block_type = select_block_type(ctx);
	  let if_block = current_block_type && current_block_type(ctx);
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if (if_block) if_block.d(1);
	        if_block = current_block_type && current_block_type(ctx);
	        if (if_block) {
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if (if_block) {
	        if_block.d(detaching);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$2$2.name,
	    type: "each",
	    source: "(49:0) {#each buttons as button}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$3$4(ctx) {
	  let each_1_anchor;
	  let each_value = ensure_array_like_dev( /*buttons*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$2$2(get_each_context$2$2(ctx, each_value, i));
	  }
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, $_viewTitle, buttons, $buttonText, prev, next, isToday, $date, today, $viewDropDownOptions, $view, $customButtons*/3670527) {
	        each_value = ensure_array_like_dev( /*buttons*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$2$2(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$2$2(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$3$4($$self, $$props, $$invalidate) {
	  let $duration;
	  let $date;
	  let $hiddenDays;
	  let $_currentRange;
	  let $theme;
	  let $_viewTitle;
	  let $buttonText;
	  let $viewDropDownOptions;
	  let $view;
	  let $customButtons;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Buttons', slots, []);
	  let {
	    buttons
	  } = $$props;
	  let {
	    _currentRange,
	    _viewTitle,
	    buttonText,
	    customButtons,
	    date,
	    duration,
	    hiddenDays,
	    theme,
	    view,
	    viewDropDownOptions
	  } = getContext("state");
	  validate_store(_currentRange, '_currentRange');
	  component_subscribe($$self, _currentRange, value => $$invalidate(22, $_currentRange = value));
	  validate_store(_viewTitle, '_viewTitle');
	  component_subscribe($$self, _viewTitle, value => $$invalidate(4, $_viewTitle = value));
	  validate_store(buttonText, 'buttonText');
	  component_subscribe($$self, buttonText, value => $$invalidate(5, $buttonText = value));
	  validate_store(customButtons, 'customButtons');
	  component_subscribe($$self, customButtons, value => $$invalidate(8, $customButtons = value));
	  validate_store(date, 'date');
	  component_subscribe($$self, date, value => $$invalidate(2, $date = value));
	  validate_store(duration, 'duration');
	  component_subscribe($$self, duration, value => $$invalidate(26, $duration = value));
	  validate_store(hiddenDays, 'hiddenDays');
	  component_subscribe($$self, hiddenDays, value => $$invalidate(27, $hiddenDays = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  validate_store(view, 'view');
	  component_subscribe($$self, view, value => $$invalidate(7, $view = value));
	  validate_store(viewDropDownOptions, 'viewDropDownOptions');
	  component_subscribe($$self, viewDropDownOptions, value => $$invalidate(6, $viewDropDownOptions = value));
	  let today = setMidnight(createDate()),
	    isToday;
	  function prev() {
	    let d = subtractDuration($date, $duration);
	    if ($hiddenDays.length && $hiddenDays.length < 7) {
	      while ($hiddenDays.includes(d.getUTCDay())) {
	        subtractDay(d);
	      }
	    }
	    set_store_value(date, $date = d, $date);
	  }
	  function next() {
	    set_store_value(date, $date = addDuration($date, $duration), $date);
	  }
	  $$self.$$.on_mount.push(function () {
	    if (buttons === undefined && !('buttons' in $$props || $$self.$$.bound[$$self.$$.props['buttons']])) {
	      console.warn("<Buttons> was created without expected prop 'buttons'");
	    }
	  });
	  const writable_props = ['buttons'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Buttons> was created with unknown prop '${key}'`);
	  });
	  const click_handler = () => set_store_value(date, $date = cloneDate(today), $date);
	  function select_change_handler() {
	    $view = select_value(this);
	    view.set($view);
	  }
	  const click_handler_1 = button => set_store_value(view, $view = button, $view);
	  $$self.$$set = $$props => {
	    if ('buttons' in $$props) $$invalidate(0, buttons = $$props.buttons);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    createDate,
	    cloneDate,
	    subtractDay,
	    addDuration,
	    setContent,
	    subtractDuration,
	    setMidnight,
	    buttons,
	    _currentRange,
	    _viewTitle,
	    buttonText,
	    customButtons,
	    date,
	    duration,
	    hiddenDays,
	    theme,
	    view,
	    viewDropDownOptions,
	    today,
	    isToday,
	    prev,
	    next,
	    $duration,
	    $date,
	    $hiddenDays,
	    $_currentRange,
	    $theme,
	    $_viewTitle,
	    $buttonText,
	    $viewDropDownOptions,
	    $view,
	    $customButtons
	  });
	  $$self.$inject_state = $$props => {
	    if ('buttons' in $$props) $$invalidate(0, buttons = $$props.buttons);
	    if ('_currentRange' in $$props) $$invalidate(9, _currentRange = $$props._currentRange);
	    if ('_viewTitle' in $$props) $$invalidate(10, _viewTitle = $$props._viewTitle);
	    if ('buttonText' in $$props) $$invalidate(11, buttonText = $$props.buttonText);
	    if ('customButtons' in $$props) $$invalidate(12, customButtons = $$props.customButtons);
	    if ('date' in $$props) $$invalidate(13, date = $$props.date);
	    if ('duration' in $$props) $$invalidate(14, duration = $$props.duration);
	    if ('hiddenDays' in $$props) $$invalidate(15, hiddenDays = $$props.hiddenDays);
	    if ('theme' in $$props) $$invalidate(16, theme = $$props.theme);
	    if ('view' in $$props) $$invalidate(17, view = $$props.view);
	    if ('viewDropDownOptions' in $$props) $$invalidate(18, viewDropDownOptions = $$props.viewDropDownOptions);
	    if ('today' in $$props) $$invalidate(19, today = $$props.today);
	    if ('isToday' in $$props) $$invalidate(1, isToday = $$props.isToday);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*$_currentRange*/4194304) {
	      $$invalidate(1, isToday = today >= $_currentRange.start && today < $_currentRange.end || null);
	    }
	  };
	  return [buttons, isToday, $date, $theme, $_viewTitle, $buttonText, $viewDropDownOptions, $view, $customButtons, _currentRange, _viewTitle, buttonText, customButtons, date, duration, hiddenDays, theme, view, viewDropDownOptions, today, prev, next, $_currentRange, click_handler, select_change_handler, click_handler_1];
	}
	class Buttons extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3$4, create_fragment$3$4, safe_not_equal, {
	      buttons: 0
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Buttons",
	      options,
	      id: create_fragment$3$4.name
	    });
	  }
	  get buttons() {
	    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set buttons(value) {
	    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/core/src/Toolbar.svelte generated by Svelte v4.2.16 */

	const {
	  Object: Object_1$1
	} = globals;
	const file$1$4 = "packages/core/src/Toolbar.svelte";
	function get_each_context$1$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[5] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[8] = list[i];
	  return child_ctx;
	}

	// (28:16) {:else}
	function create_else_block$2(ctx) {
	  let buttons_1;
	  let current;
	  buttons_1 = new Buttons({
	    props: {
	      buttons: /*buttons*/ctx[8]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(buttons_1.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(buttons_1, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const buttons_1_changes = {};
	      if (dirty & /*sections*/1) buttons_1_changes.buttons = /*buttons*/ctx[8];
	      buttons_1.$set(buttons_1_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(buttons_1.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(buttons_1.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(buttons_1, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$2.name,
	    type: "else",
	    source: "(28:16) {:else}",
	    ctx
	  });
	  return block;
	}

	// (24:16) {#if buttons.length > 1}
	function create_if_block$6(ctx) {
	  let div;
	  let buttons_1;
	  let div_class_value;
	  let current;
	  buttons_1 = new Buttons({
	    props: {
	      buttons: /*buttons*/ctx[8]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(buttons_1.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[1].buttonGroup);
	      add_location(div, file$1$4, 24, 20, 600);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(buttons_1, div, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const buttons_1_changes = {};
	      if (dirty & /*sections*/1) buttons_1_changes.buttons = /*buttons*/ctx[8];
	      buttons_1.$set(buttons_1_changes);
	      if (!current || dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].buttonGroup)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(buttons_1.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(buttons_1.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(buttons_1);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$6.name,
	    type: "if",
	    source: "(24:16) {#if buttons.length > 1}",
	    ctx
	  });
	  return block;
	}

	// (23:12) {#each sections[key] as buttons}
	function create_each_block_1$3(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block$6, create_else_block$2];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*buttons*/ctx[8].length > 1) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  const block = {
	    c: function create() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1$3.name,
	    type: "each",
	    source: "(23:12) {#each sections[key] as buttons}",
	    ctx
	  });
	  return block;
	}

	// (21:4) {#each Object.keys(sections) as key}
	function create_each_block$1$3(ctx) {
	  let div;
	  let t;
	  let current;
	  let each_value_1 = ensure_array_like_dev( /*sections*/ctx[0][/*key*/ctx[5]]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      add_location(div, file$1$4, 21, 8, 488);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append_dev(div, t);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme, sections, Object*/3) {
	        each_value_1 = ensure_array_like_dev( /*sections*/ctx[0][/*key*/ctx[5]]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1$3(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1$3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1$3.name,
	    type: "each",
	    source: "(21:4) {#each Object.keys(sections) as key}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$2$5(ctx) {
	  let nav;
	  let nav_class_value;
	  let current;
	  let each_value = ensure_array_like_dev(Object.keys( /*sections*/ctx[0]));
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1$3(get_each_context$1$3(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      nav = element("nav");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(nav, "class", nav_class_value = /*$theme*/ctx[1].toolbar);
	      add_location(nav, file$1$4, 19, 0, 408);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, nav, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(nav, null);
	        }
	      }
	      current = true;
	    },
	    p: function update(ctx, _ref7) {
	      let [dirty] = _ref7;
	      if (dirty & /*sections, Object, $theme*/3) {
	        each_value = ensure_array_like_dev(Object.keys( /*sections*/ctx[0]));
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1$3(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1$3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(nav, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/2 && nav_class_value !== (nav_class_value = /*$theme*/ctx[1].toolbar)) {
	        attr_dev(nav, "class", nav_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(nav);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2$5.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2$5($$self, $$props, $$invalidate) {
	  let $headerToolbar;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Toolbar', slots, []);
	  let {
	    headerToolbar,
	    theme
	  } = getContext('state');
	  validate_store(headerToolbar, 'headerToolbar');
	  component_subscribe($$self, headerToolbar, value => $$invalidate(4, $headerToolbar = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  let sections = {
	    start: [],
	    center: [],
	    end: []
	  };
	  const writable_props = [];
	  Object_1$1.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toolbar> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    Buttons,
	    headerToolbar,
	    theme,
	    sections,
	    $headerToolbar,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('headerToolbar' in $$props) $$invalidate(2, headerToolbar = $$props.headerToolbar);
	    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
	    if ('sections' in $$props) $$invalidate(0, sections = $$props.sections);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*sections, $headerToolbar*/17) {
	      {
	        for (let key of Object.keys(sections)) {
	          $$invalidate(0, sections[key] = $headerToolbar[key].split(' ').map(group => group.split(',')), sections);
	        }
	      }
	    }
	  };
	  return [sections, $theme, headerToolbar, theme, $headerToolbar];
	}
	class Toolbar extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2$5, create_fragment$2$5, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Toolbar",
	      options,
	      id: create_fragment$2$5.name
	    });
	  }
	}

	/* packages/core/src/Auxiliary.svelte generated by Svelte v4.2.16 */

	function get_each_context$9(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[11] = list[i];
	  return child_ctx;
	}

	// (25:0) {#each $_auxiliary as component}
	function create_each_block$9(ctx) {
	  let switch_instance;
	  let switch_instance_anchor;
	  let current;
	  var switch_value = /*component*/ctx[11];
	  function switch_props(ctx, dirty) {
	    return {
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	  }
	  const block = {
	    c: function create() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (switch_instance) mount_component(switch_instance, target, anchor);
	      insert_dev(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$_auxiliary*/1 && switch_value !== (switch_value = /*component*/ctx[11])) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(switch_instance_anchor);
	      }
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$9.name,
	    type: "each",
	    source: "(25:0) {#each $_auxiliary as component}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1$5(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like_dev( /*$_auxiliary*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref8) {
	      let [dirty] = _ref8;
	      if (dirty & /*$_auxiliary*/1) {
	        each_value = ensure_array_like_dev( /*$_auxiliary*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$9(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$9(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1$5.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1$5($$self, $$props, $$invalidate) {
	  let $_view;
	  let $datesSet;
	  let $_activeRange;
	  let $_auxiliary;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Auxiliary', slots, []);
	  let {
	    datesSet,
	    _auxiliary,
	    _activeRange,
	    _queue,
	    _view
	  } = getContext('state');
	  validate_store(datesSet, 'datesSet');
	  component_subscribe($$self, datesSet, value => $$invalidate(7, $datesSet = value));
	  validate_store(_auxiliary, '_auxiliary');
	  component_subscribe($$self, _auxiliary, value => $$invalidate(0, $_auxiliary = value));
	  validate_store(_activeRange, '_activeRange');
	  component_subscribe($$self, _activeRange, value => $$invalidate(5, $_activeRange = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(6, $_view = value));
	  let debounceHandle = {};
	  function runDatesSet(_activeRange) {
	    if (is_function($datesSet)) {
	      debounce(() => $datesSet({
	        start: toLocalDate(_activeRange.start),
	        end: toLocalDate(_activeRange.end),
	        startStr: toISOString(_activeRange.start),
	        endStr: toISOString(_activeRange.end),
	        view: toViewWithLocalDates($_view)
	      }), debounceHandle, _queue);
	    }
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    is_function,
	    debounce,
	    toISOString,
	    toLocalDate,
	    toViewWithLocalDates,
	    datesSet,
	    _auxiliary,
	    _activeRange,
	    _queue,
	    _view,
	    debounceHandle,
	    runDatesSet,
	    $_view,
	    $datesSet,
	    $_activeRange,
	    $_auxiliary
	  });
	  $$self.$inject_state = $$props => {
	    if ('datesSet' in $$props) $$invalidate(1, datesSet = $$props.datesSet);
	    if ('_auxiliary' in $$props) $$invalidate(2, _auxiliary = $$props._auxiliary);
	    if ('_activeRange' in $$props) $$invalidate(3, _activeRange = $$props._activeRange);
	    if ('_queue' in $$props) _queue = $$props._queue;
	    if ('_view' in $$props) $$invalidate(4, _view = $$props._view);
	    if ('debounceHandle' in $$props) debounceHandle = $$props.debounceHandle;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_activeRange*/32) {
	      // Set up datesSet callback
	      runDatesSet($_activeRange);
	    }
	  };
	  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
	}
	let Auxiliary$2 = class Auxiliary extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1$5, create_fragment$1$5, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Auxiliary",
	      options,
	      id: create_fragment$1$5.name
	    });
	  }
	};

	/* packages/core/src/Calendar.svelte generated by Svelte v4.2.16 */

	const file$b = "packages/core/src/Calendar.svelte";
	function create_fragment$c(ctx) {
	  let div;
	  let toolbar;
	  let t0;
	  let switch_instance;
	  let div_class_value;
	  let div_role_value;
	  let t1;
	  let auxiliary;
	  let current;
	  let mounted;
	  let dispose;
	  toolbar = new Toolbar({
	    $$inline: true
	  });
	  var switch_value = /*$_viewComponent*/ctx[5];
	  function switch_props(ctx, dirty) {
	    return {
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	  }
	  auxiliary = new Auxiliary$2({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(toolbar.$$.fragment);
	      t0 = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      t1 = space();
	      create_component(auxiliary.$$.fragment);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[1].calendar + " " + /*$theme*/ctx[1].view + ( /*$_scrollable*/ctx[0] ? ' ' + /*$theme*/ctx[1].withScroll : '') + ( /*$_iClass*/ctx[2] ? ' ' + /*$theme*/ctx[1][/*$_iClass*/ctx[2]] : '')));
	      attr_dev(div, "role", div_role_value = listView( /*$view*/ctx[4]) ? 'list' : 'table');
	      set_style(div, "height", /*$height*/ctx[3]);
	      add_location(div, file$b, 129, 0, 3339);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(toolbar, div, null);
	      append_dev(div, t0);
	      if (switch_instance) mount_component(switch_instance, div, null);
	      insert_dev(target, t1, anchor);
	      mount_component(auxiliary, target, anchor);
	      current = true;
	      if (!mounted) {
	        dispose = listen_dev(window, "resize", /*recheckScrollable*/ctx[17], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$_viewComponent*/32 && switch_value !== (switch_value = /*$_viewComponent*/ctx[5])) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, div, null);
	        } else {
	          switch_instance = null;
	        }
	      }
	      if (!current || dirty[0] & /*$theme, $_scrollable, $_iClass*/7 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[1].calendar + " " + /*$theme*/ctx[1].view + ( /*$_scrollable*/ctx[0] ? ' ' + /*$theme*/ctx[1].withScroll : '') + ( /*$_iClass*/ctx[2] ? ' ' + /*$theme*/ctx[1][/*$_iClass*/ctx[2]] : '')))) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (!current || dirty[0] & /*$view*/16 && div_role_value !== (div_role_value = listView( /*$view*/ctx[4]) ? 'list' : 'table')) {
	        attr_dev(div, "role", div_role_value);
	      }
	      if (dirty[0] & /*$height*/8) {
	        set_style(div, "height", /*$height*/ctx[3]);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(toolbar.$$.fragment, local);
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      transition_in(auxiliary.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(toolbar.$$.fragment, local);
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      transition_out(auxiliary.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	        detach_dev(t1);
	      }
	      destroy_component(toolbar);
	      if (switch_instance) destroy_component(switch_instance);
	      destroy_component(auxiliary, detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$c.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$c($$self, $$props, $$invalidate) {
	  let $_bodyEl;
	  let $_scrollable;
	  let $_queue2;
	  let $_queue;
	  let $_interaction;
	  let $_events;
	  let $theme;
	  let $_iClass;
	  let $height;
	  let $view;
	  let $_viewComponent;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Calendar', slots, []);
	  let {
	    plugins = []
	  } = $$props;
	  let {
	    options = {}
	  } = $$props;
	  let component = get_current_component();
	  let state = new State(plugins, options);
	  setContext('state', state);
	  let {
	    _viewComponent,
	    _bodyEl,
	    _interaction,
	    _iClass,
	    _events,
	    _queue,
	    _queue2,
	    _tasks,
	    _scrollable,
	    height,
	    theme,
	    view
	  } = state;
	  validate_store(_viewComponent, '_viewComponent');
	  component_subscribe($$self, _viewComponent, value => $$invalidate(5, $_viewComponent = value));
	  validate_store(_bodyEl, '_bodyEl');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(32, $_bodyEl = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(35, $_interaction = value));
	  validate_store(_iClass, '_iClass');
	  component_subscribe($$self, _iClass, value => $$invalidate(2, $_iClass = value));
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(36, $_events = value));
	  validate_store(_queue, '_queue');
	  component_subscribe($$self, _queue, value => $$invalidate(34, $_queue = value));
	  validate_store(_queue2, '_queue2');
	  component_subscribe($$self, _queue2, value => $$invalidate(33, $_queue2 = value));
	  validate_store(_scrollable, '_scrollable');
	  component_subscribe($$self, _scrollable, value => $$invalidate(0, $_scrollable = value));
	  validate_store(height, 'height');
	  component_subscribe($$self, height, value => $$invalidate(3, $height = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  validate_store(view, 'view');
	  component_subscribe($$self, view, value => $$invalidate(4, $view = value));

	  // Reactively update options that did change
	  let prevOptions = {
	    ...options
	  };
	  function setOption(name, value) {
	    state._set(name, value);
	    return this;
	  }
	  function getOption(name) {
	    let value = state._get(name);
	    return value instanceof Date ? toLocalDate(value) : value;
	  }
	  function refetchEvents() {
	    state._fetchedRange.set({
	      start: undefined,
	      end: undefined
	    });
	    return this;
	  }
	  function getEvents() {
	    return $_events.map(toEventWithLocalDates);
	  }
	  function getEventById(id) {
	    for (let event of $_events) {
	      if (event.id == id) {
	        return toEventWithLocalDates(event);
	      }
	    }
	    return null;
	  }
	  function addEvent(event) {
	    $_events.push(createEvents([event])[0]);
	    _events.set($_events);
	    return this;
	  }
	  function updateEvent(event) {
	    for (let e of $_events) {
	      if (e.id == event.id) {
	        assign(e, createEvents([event])[0]);
	        _events.set($_events);
	        break;
	      }
	    }
	    return this;
	  }
	  function removeEventById(id) {
	    let idx = $_events.findIndex(event => event.id == id);
	    if (idx >= 0) {
	      $_events.splice(idx, 1);
	      _events.set($_events);
	    }
	    return this;
	  }
	  function getView() {
	    return toViewWithLocalDates(get_store_value(state._view));
	  }
	  function unselect() {
	    if ($_interaction.action) {
	      $_interaction.action.unselect();
	    }
	    return this;
	  }
	  function dateFromPoint(x, y) {
	    let dayEl = getElementWithPayload(x, y);
	    return dayEl ? getPayload(dayEl)(y) : null;
	  }
	  function destroy() {
	    destroy_component(component, true);
	  }
	  beforeUpdate(() => {
	    flushDebounce($_queue);
	  });
	  afterUpdate(() => {
	    flushDebounce($_queue2);
	    task(recheckScrollable, null, _tasks);
	  });
	  function recheckScrollable() {
	    if ($_bodyEl) {
	      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
	    }
	  }
	  const writable_props = ['plugins', 'options'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Calendar> was created with unknown prop '${key}'`);
	  });
	  $$self.$$set = $$props => {
	    if ('plugins' in $$props) $$invalidate(18, plugins = $$props.plugins);
	    if ('options' in $$props) $$invalidate(19, options = $$props.options);
	  };
	  $$self.$capture_state = () => ({
	    setContext,
	    beforeUpdate,
	    afterUpdate,
	    destroy_component,
	    get_current_component,
	    get: get_store_value,
	    diff,
	    State,
	    Toolbar,
	    Auxiliary: Auxiliary$2,
	    assign,
	    createEvents,
	    toEventWithLocalDates,
	    toViewWithLocalDates,
	    toLocalDate,
	    getElementWithPayload,
	    getPayload,
	    flushDebounce,
	    hasYScroll,
	    listView,
	    task,
	    plugins,
	    options,
	    component,
	    state,
	    _viewComponent,
	    _bodyEl,
	    _interaction,
	    _iClass,
	    _events,
	    _queue,
	    _queue2,
	    _tasks,
	    _scrollable,
	    height,
	    theme,
	    view,
	    prevOptions,
	    setOption,
	    getOption,
	    refetchEvents,
	    getEvents,
	    getEventById,
	    addEvent,
	    updateEvent,
	    removeEventById,
	    getView,
	    unselect,
	    dateFromPoint,
	    destroy,
	    recheckScrollable,
	    $_bodyEl,
	    $_scrollable,
	    $_queue2,
	    $_queue,
	    $_interaction,
	    $_events,
	    $theme,
	    $_iClass,
	    $height,
	    $view,
	    $_viewComponent
	  });
	  $$self.$inject_state = $$props => {
	    if ('plugins' in $$props) $$invalidate(18, plugins = $$props.plugins);
	    if ('options' in $$props) $$invalidate(19, options = $$props.options);
	    if ('component' in $$props) component = $$props.component;
	    if ('state' in $$props) state = $$props.state;
	    if ('_viewComponent' in $$props) $$invalidate(6, _viewComponent = $$props._viewComponent);
	    if ('_bodyEl' in $$props) $$invalidate(7, _bodyEl = $$props._bodyEl);
	    if ('_interaction' in $$props) $$invalidate(8, _interaction = $$props._interaction);
	    if ('_iClass' in $$props) $$invalidate(9, _iClass = $$props._iClass);
	    if ('_events' in $$props) $$invalidate(10, _events = $$props._events);
	    if ('_queue' in $$props) $$invalidate(11, _queue = $$props._queue);
	    if ('_queue2' in $$props) $$invalidate(12, _queue2 = $$props._queue2);
	    if ('_tasks' in $$props) _tasks = $$props._tasks;
	    if ('_scrollable' in $$props) $$invalidate(13, _scrollable = $$props._scrollable);
	    if ('height' in $$props) $$invalidate(14, height = $$props.height);
	    if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
	    if ('view' in $$props) $$invalidate(16, view = $$props.view);
	    if ('prevOptions' in $$props) $$invalidate(40, prevOptions = $$props.prevOptions);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*options*/524288) {
	      for (let [name, value] of diff(options, prevOptions)) {
	        setOption(name, value);
	      }
	    }
	  };
	  return [$_scrollable, $theme, $_iClass, $height, $view, $_viewComponent, _viewComponent, _bodyEl, _interaction, _iClass, _events, _queue, _queue2, _scrollable, height, theme, view, recheckScrollable, plugins, options, setOption, getOption, refetchEvents, getEvents, getEventById, addEvent, updateEvent, removeEventById, getView, unselect, dateFromPoint, destroy];
	}
	class Calendar extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$c, create_fragment$c, safe_not_equal, {
	      plugins: 18,
	      options: 19,
	      setOption: 20,
	      getOption: 21,
	      refetchEvents: 22,
	      getEvents: 23,
	      getEventById: 24,
	      addEvent: 25,
	      updateEvent: 26,
	      removeEventById: 27,
	      getView: 28,
	      unselect: 29,
	      dateFromPoint: 30,
	      destroy: 31
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Calendar",
	      options,
	      id: create_fragment$c.name
	    });
	  }
	  get plugins() {
	    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set plugins(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get options() {
	    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set options(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get setOption() {
	    return this.$$.ctx[20];
	  }
	  set setOption(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get getOption() {
	    return this.$$.ctx[21];
	  }
	  set getOption(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get refetchEvents() {
	    return this.$$.ctx[22];
	  }
	  set refetchEvents(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get getEvents() {
	    return this.$$.ctx[23];
	  }
	  set getEvents(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get getEventById() {
	    return this.$$.ctx[24];
	  }
	  set getEventById(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get addEvent() {
	    return this.$$.ctx[25];
	  }
	  set addEvent(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get updateEvent() {
	    return this.$$.ctx[26];
	  }
	  set updateEvent(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get removeEventById() {
	    return this.$$.ctx[27];
	  }
	  set removeEventById(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get getView() {
	    return this.$$.ctx[28];
	  }
	  set getView(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get unselect() {
	    return this.$$.ctx[29];
	  }
	  set unselect(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get dateFromPoint() {
	    return this.$$.ctx[30];
	  }
	  set dateFromPoint(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get destroy() {
	    return this.$$.ctx[31];
	  }
	  set destroy(value) {
	    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	function days(state) {
	  return derived([state.date, state.firstDay, state.hiddenDays], _ref => {
	    let [$date, $firstDay, $hiddenDays] = _ref;
	    let days = [];
	    let day = cloneDate($date);
	    let max = 7;
	    // First day of week
	    while (day.getUTCDay() !== $firstDay && max) {
	      subtractDay(day);
	      --max;
	    }
	    for (let i = 0; i < 7; ++i) {
	      if (!$hiddenDays.includes(day.getUTCDay())) {
	        days.push(cloneDate(day));
	      }
	      addDay(day);
	    }
	    return days;
	  });
	}

	/* packages/day-grid/src/Header.svelte generated by Svelte v4.2.16 */
	const file$5$1 = "packages/day-grid/src/Header.svelte";
	function get_each_context$4$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[8] = list[i];
	  return child_ctx;
	}

	// (10:8) {#each $_days as day}
	function create_each_block$4$1(ctx) {
	  let div;
	  let span;
	  let span_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      span = element("span");
	      t = space();
	      attr_dev(span, "aria-label", span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]));
	      add_location(span, file$5$1, 11, 16, 408);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]));
	      attr_dev(div, "role", "columnheader");
	      add_location(div, file$5$1, 10, 12, 308);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, span);
	      append_dev(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, span, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8])));
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$_intlDayHeaderAL, $_days*/6 && span_aria_label_value !== (span_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*day*/ctx[8]))) {
	        attr_dev(span, "aria-label", span_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_days*/10) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[3].format( /*day*/ctx[8]));
	      if (dirty & /*$theme, $_days*/3 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*day*/ctx[8].getUTCDay()]))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$4$1.name,
	    type: "each",
	    source: "(10:8) {#each $_days as day}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$6$1(ctx) {
	  let div2;
	  let div0;
	  let div0_class_value;
	  let t;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let each_value = ensure_array_like_dev( /*$_days*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4$1(get_each_context$4$1(ctx, each_value, i));
	  }
	  const block = {
	    c: function create() {
	      div2 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      div1 = element("div");
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].days);
	      attr_dev(div0, "role", "row");
	      add_location(div0, file$5$1, 8, 4, 227);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[0].hiddenScroll);
	      add_location(div1, file$5$1, 18, 4, 619);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[0].header);
	      add_location(div2, file$5$1, 7, 0, 193);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append_dev(div2, t);
	      append_dev(div2, div1);
	    },
	    p: function update(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if (dirty & /*$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader*/15) {
	        each_value = ensure_array_like_dev( /*$_days*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$4$1(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$4$1(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(div0, null);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	      if (dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].days)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (dirty & /*$theme*/1 && div2_class_value !== (div2_class_value = /*$theme*/ctx[0].header)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div2);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$6$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$6$1($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_days;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Header', slots, []);
	  let {
	    theme,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    _days
	  } = getContext('state');
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  validate_store(_intlDayHeader, '_intlDayHeader');
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	  validate_store(_intlDayHeaderAL, '_intlDayHeaderAL');
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(2, $_intlDayHeaderAL = value));
	  validate_store(_days, '_days');
	  component_subscribe($$self, _days, value => $$invalidate(1, $_days = value));
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    setContent,
	    theme,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    _days,
	    $theme,
	    $_days,
	    $_intlDayHeaderAL,
	    $_intlDayHeader
	  });
	  $$self.$inject_state = $$props => {
	    if ('theme' in $$props) $$invalidate(4, theme = $$props.theme);
	    if ('_intlDayHeader' in $$props) $$invalidate(5, _intlDayHeader = $$props._intlDayHeader);
	    if ('_intlDayHeaderAL' in $$props) $$invalidate(6, _intlDayHeaderAL = $$props._intlDayHeaderAL);
	    if ('_days' in $$props) $$invalidate(7, _days = $$props._days);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [$theme, $_days, $_intlDayHeaderAL, $_intlDayHeader, theme, _intlDayHeader, _intlDayHeaderAL, _days];
	}
	class Header extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$6$1, create_fragment$6$1, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Header",
	      options,
	      id: create_fragment$6$1.name
	    });
	  }
	}

	/* packages/day-grid/src/Body.svelte generated by Svelte v4.2.16 */
	const file$4$1 = "packages/day-grid/src/Body.svelte";
	function create_fragment$5$1(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  const default_slot_template = /*#slots*/ctx[7].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[6], null);
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      if (default_slot) default_slot.c();
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].content);
	      add_location(div0, file$4$1, 10, 4, 236);
	      attr_dev(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')));
	      add_location(div1, file$4$1, 6, 0, 122);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      if (default_slot) {
	        default_slot.m(div0, null);
	      }

	      /*div1_binding*/
	      ctx[8](div1);
	      current = true;
	    },
	    p: function update(ctx, _ref3) {
	      let [dirty] = _ref3;
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/64)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[6], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[6]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[6], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].content)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, $dayMaxEvents*/3 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[0].body + ( /*$dayMaxEvents*/ctx[1] === true ? ' ' + /*$theme*/ctx[0].uniform : '')))) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	      }
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/
	      ctx[8](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$5$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$5$1($$self, $$props, $$invalidate) {
	  let $theme;
	  let $dayMaxEvents;
	  let $_bodyEl;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Body', slots, ['default']);
	  let {
	    dayMaxEvents,
	    _bodyEl,
	    theme
	  } = getContext('state');
	  validate_store(dayMaxEvents, 'dayMaxEvents');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(1, $dayMaxEvents = value));
	  validate_store(_bodyEl, '_bodyEl');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(2, $_bodyEl = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Body> was created with unknown prop '${key}'`);
	  });
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_bodyEl = $$value;
	      _bodyEl.set($_bodyEl);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    dayMaxEvents,
	    _bodyEl,
	    theme,
	    $theme,
	    $dayMaxEvents,
	    $_bodyEl
	  });
	  $$self.$inject_state = $$props => {
	    if ('dayMaxEvents' in $$props) $$invalidate(3, dayMaxEvents = $$props.dayMaxEvents);
	    if ('_bodyEl' in $$props) $$invalidate(4, _bodyEl = $$props._bodyEl);
	    if ('theme' in $$props) $$invalidate(5, theme = $$props.theme);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [$theme, $dayMaxEvents, $_bodyEl, dayMaxEvents, _bodyEl, theme, $$scope, slots, div1_binding];
	}
	let Body$2 = class Body extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$5$1, create_fragment$5$1, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Body",
	      options,
	      id: create_fragment$5$1.name
	    });
	  }
	};

	/* packages/day-grid/src/Event.svelte generated by Svelte v4.2.16 */

	const file$3$2 = "packages/day-grid/src/Event.svelte";
	function create_fragment$4$2(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[8].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      },
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	    });
	  }
	  const block = {
	    c: function create() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      add_location(div, file$3$2, 165, 4, 4978);
	      attr_dev(article, "class", /*classes*/ctx[4]);
	      attr_dev(article, "style", /*style*/ctx[5]);
	      attr_dev(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	      add_location(article, file$3$2, 153, 0, 4542);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, article, anchor);
	      append_dev(article, div);
	      append_dev(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[52](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen_dev(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7] || undefined)) ( /*onclick*/ctx[7] || undefined).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[32]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[32]( /*$eventMouseEnter*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[32]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]))) /*createHandler*/ctx[32]( /*$eventMouseLeave*/ctx[10], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "pointerdown", function () {
	          if (is_function(!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8]))) (!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8])).apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/256 && switch_value !== (switch_value = /*$_interaction*/ctx[8].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8], true))) /*createDragHandler*/ctx[33]( /*$_interaction*/ctx[8], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr_dev(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr_dev(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr_dev(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr_dev(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[52](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$4$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$4$2($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_hiddenEvents;
	  let $dayMaxEvents;
	  let $_popupDate;
	  let $_interaction;
	  let $_view;
	  let $eventAllUpdated;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Event', slots, []);
	  let {
	    chunk
	  } = $$props;
	  let {
	    longChunks = {}
	  } = $$props;
	  let {
	    inPopup = false
	  } = $$props;
	  let {
	    dayMaxEvents,
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _hiddenEvents,
	    _popupDate,
	    _tasks
	  } = getContext('state');
	  validate_store(dayMaxEvents, 'dayMaxEvents');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(55, $dayMaxEvents = value));
	  validate_store(displayEventEnd, 'displayEventEnd');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(44, $displayEventEnd = value));
	  validate_store(eventAllUpdated, 'eventAllUpdated');
	  component_subscribe($$self, eventAllUpdated, value => $$invalidate(57, $eventAllUpdated = value));
	  validate_store(eventBackgroundColor, 'eventBackgroundColor');
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(50, $eventBackgroundColor = value));
	  validate_store(eventTextColor, 'eventTextColor');
	  component_subscribe($$self, eventTextColor, value => $$invalidate(47, $eventTextColor = value));
	  validate_store(eventClick, 'eventClick');
	  component_subscribe($$self, eventClick, value => $$invalidate(40, $eventClick = value));
	  validate_store(eventColor, 'eventColor');
	  component_subscribe($$self, eventColor, value => $$invalidate(49, $eventColor = value));
	  validate_store(eventContent, 'eventContent');
	  component_subscribe($$self, eventContent, value => $$invalidate(43, $eventContent = value));
	  validate_store(eventClassNames, 'eventClassNames');
	  component_subscribe($$self, eventClassNames, value => $$invalidate(45, $eventClassNames = value));
	  validate_store(eventDidMount, 'eventDidMount');
	  component_subscribe($$self, eventDidMount, value => $$invalidate(58, $eventDidMount = value));
	  validate_store(eventMouseEnter, 'eventMouseEnter');
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	  validate_store(eventMouseLeave, 'eventMouseLeave');
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(41, $_view = value));
	  validate_store(_intlEventTime, '_intlEventTime');
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(42, $_intlEventTime = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  validate_store(_iClasses, '_iClasses');
	  component_subscribe($$self, _iClasses, value => $$invalidate(46, $_iClasses = value));
	  validate_store(_resBgColor, '_resBgColor');
	  component_subscribe($$self, _resBgColor, value => $$invalidate(51, $_resBgColor = value));
	  validate_store(_resTxtColor, '_resTxtColor');
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(48, $_resTxtColor = value));
	  validate_store(_hiddenEvents, '_hiddenEvents');
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(54, $_hiddenEvents = value));
	  validate_store(_popupDate, '_popupDate');
	  component_subscribe($$self, _popupDate, value => $$invalidate(56, $_popupDate = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let margin = 1;
	  let hidden = false;
	  let display;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (is_function($eventAllUpdated) && !helperEvent(display)) {
	      task(() => $eventAllUpdated({
	        view: toViewWithLocalDates($_view)
	      }), 'eau', _tasks);
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => $_interaction.action.drag(event, jsEvent, resize, inPopup ? $_popupDate : undefined) : undefined;
	  }
	  function reposition() {
	    if (!el) {
	      return;
	    }
	    $$invalidate(38, margin = repositionEvent(chunk, longChunks, height(el)));
	    if ($dayMaxEvents === true) {
	      hide();
	    } else {
	      $$invalidate(39, hidden = false);
	    }
	  }
	  function hide() {
	    let dayEl = ancestor(el, 2);
	    let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
	    $$invalidate(39, hidden = chunk.bottom > h);
	    let update = false;

	    // Hide or show the event throughout all days
	    for (let date of chunk.dates) {
	      let hiddenEvents = $_hiddenEvents[date.getTime()];
	      if (hiddenEvents) {
	        let size = hiddenEvents.size;
	        if (hidden) {
	          hiddenEvents.add(chunk.event);
	        } else {
	          hiddenEvents.delete(chunk.event);
	        }
	        if (size !== hiddenEvents.size) {
	          update = true;
	        }
	      }
	    }
	    if (update) {
	      _hiddenEvents.set($_hiddenEvents);
	    }
	  }
	  function footHeight(dayEl) {
	    let h = 0;
	    for (let i = 0; i < chunk.days; ++i) {
	      h = max(h, height(dayEl.lastElementChild));
	      dayEl = dayEl.nextElementSibling;
	      if (!dayEl) {
	        break;
	      }
	    }
	    return h;
	  }
	  $$self.$$.on_mount.push(function () {
	    if (chunk === undefined && !('chunk' in $$props || $$self.$$.bound[$$self.$$.props['chunk']])) {
	      console.warn("<Event> was created without expected prop 'chunk'");
	    }
	  });
	  const writable_props = ['chunk', 'longChunks', 'inPopup'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Event> was created with unknown prop '${key}'`);
	  });
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(34, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(35, longChunks = $$props.longChunks);
	    if ('inPopup' in $$props) $$invalidate(36, inPopup = $$props.inPopup);
	  };
	  $$self.$capture_state = () => ({
	    afterUpdate,
	    getContext,
	    onMount,
	    is_function,
	    ancestor,
	    createEventClasses,
	    createEventContent,
	    height,
	    max,
	    toEventWithLocalDates,
	    toViewWithLocalDates,
	    setContent,
	    repositionEvent,
	    helperEvent,
	    keyEnter,
	    task,
	    chunk,
	    longChunks,
	    inPopup,
	    dayMaxEvents,
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _hiddenEvents,
	    _popupDate,
	    _tasks,
	    el,
	    event,
	    classes,
	    style,
	    content,
	    timeText,
	    margin,
	    hidden,
	    display,
	    onclick,
	    createHandler,
	    createDragHandler,
	    reposition,
	    hide,
	    footHeight,
	    $eventClick,
	    $_hiddenEvents,
	    $dayMaxEvents,
	    $_popupDate,
	    $_interaction,
	    $_view,
	    $eventAllUpdated,
	    $eventDidMount,
	    $_intlEventTime,
	    $theme,
	    $eventContent,
	    $displayEventEnd,
	    $eventClassNames,
	    $_iClasses,
	    $eventTextColor,
	    $_resTxtColor,
	    $eventColor,
	    $eventBackgroundColor,
	    $_resBgColor,
	    $eventMouseEnter,
	    $eventMouseLeave
	  });
	  $$self.$inject_state = $$props => {
	    if ('chunk' in $$props) $$invalidate(34, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(35, longChunks = $$props.longChunks);
	    if ('inPopup' in $$props) $$invalidate(36, inPopup = $$props.inPopup);
	    if ('dayMaxEvents' in $$props) $$invalidate(11, dayMaxEvents = $$props.dayMaxEvents);
	    if ('displayEventEnd' in $$props) $$invalidate(12, displayEventEnd = $$props.displayEventEnd);
	    if ('eventAllUpdated' in $$props) $$invalidate(13, eventAllUpdated = $$props.eventAllUpdated);
	    if ('eventBackgroundColor' in $$props) $$invalidate(14, eventBackgroundColor = $$props.eventBackgroundColor);
	    if ('eventTextColor' in $$props) $$invalidate(15, eventTextColor = $$props.eventTextColor);
	    if ('eventClick' in $$props) $$invalidate(16, eventClick = $$props.eventClick);
	    if ('eventColor' in $$props) $$invalidate(17, eventColor = $$props.eventColor);
	    if ('eventContent' in $$props) $$invalidate(18, eventContent = $$props.eventContent);
	    if ('eventClassNames' in $$props) $$invalidate(19, eventClassNames = $$props.eventClassNames);
	    if ('eventDidMount' in $$props) $$invalidate(20, eventDidMount = $$props.eventDidMount);
	    if ('eventMouseEnter' in $$props) $$invalidate(21, eventMouseEnter = $$props.eventMouseEnter);
	    if ('eventMouseLeave' in $$props) $$invalidate(22, eventMouseLeave = $$props.eventMouseLeave);
	    if ('theme' in $$props) $$invalidate(23, theme = $$props.theme);
	    if ('_view' in $$props) $$invalidate(24, _view = $$props._view);
	    if ('_intlEventTime' in $$props) $$invalidate(25, _intlEventTime = $$props._intlEventTime);
	    if ('_interaction' in $$props) $$invalidate(26, _interaction = $$props._interaction);
	    if ('_iClasses' in $$props) $$invalidate(27, _iClasses = $$props._iClasses);
	    if ('_resBgColor' in $$props) $$invalidate(28, _resBgColor = $$props._resBgColor);
	    if ('_resTxtColor' in $$props) $$invalidate(29, _resTxtColor = $$props._resTxtColor);
	    if ('_hiddenEvents' in $$props) $$invalidate(30, _hiddenEvents = $$props._hiddenEvents);
	    if ('_popupDate' in $$props) $$invalidate(31, _popupDate = $$props._popupDate);
	    if ('_tasks' in $$props) _tasks = $$props._tasks;
	    if ('el' in $$props) $$invalidate(3, el = $$props.el);
	    if ('event' in $$props) $$invalidate(0, event = $$props.event);
	    if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
	    if ('style' in $$props) $$invalidate(5, style = $$props.style);
	    if ('content' in $$props) $$invalidate(6, content = $$props.content);
	    if ('timeText' in $$props) timeText = $$props.timeText;
	    if ('margin' in $$props) $$invalidate(38, margin = $$props.margin);
	    if ('hidden' in $$props) $$invalidate(39, hidden = $$props.hidden);
	    if ('display' in $$props) $$invalidate(1, display = $$props.display);
	    if ('onclick' in $$props) $$invalidate(7, onclick = $$props.onclick);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/8) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme*/37 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, chunk, margin, hidden, $_iClasses, $eventClassNames, $_view*/2082184) {
	      {
	        $$invalidate(1, display = event.display);

	        // Class & Style
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        if (hidden) {
	          $$invalidate(5, style += 'visibility:hidden;');
	        }
	        $$invalidate(4, classes = [$theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/15368) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/512) {
	      // Onclick handler
	      $$invalidate(7, onclick = createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $_interaction, $eventMouseEnter, $eventMouseLeave, dayMaxEvents, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _hiddenEvents, _popupDate, createHandler, createDragHandler, chunk, longChunks, inPopup, reposition, margin, hidden, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	let Event$3 = class Event extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$4$2, create_fragment$4$2, safe_not_equal, {
	      chunk: 34,
	      longChunks: 35,
	      inPopup: 36,
	      reposition: 37
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Event",
	      options,
	      id: create_fragment$4$2.name
	    });
	  }
	  get chunk() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunk(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get longChunks() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set longChunks(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get inPopup() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set inPopup(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get reposition() {
	    return this.$$.ctx[37];
	  }
	  set reposition(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/day-grid/src/Popup.svelte generated by Svelte v4.2.16 */
	const file$2$3 = "packages/day-grid/src/Popup.svelte";
	function get_each_context$3$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	// (100:8) {#each $_popupChunks as chunk (chunk.event)}
	function create_each_block$3$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*chunk*/ctx[20],
	      inPopup: true
	    },
	    $$inline: true
	  });
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty & /*$_popupChunks*/1) event_changes.chunk = /*chunk*/ctx[20];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$3$1.name,
	    type: "each",
	    source: "(100:8) {#each $_popupChunks as chunk (chunk.event)}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$3$3(ctx) {
	  let div2;
	  let div0;
	  let time;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let a;
	  let t1;
	  let a_aria_label_value;
	  let div0_class_value;
	  let t2;
	  let div1;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like_dev( /*$_popupChunks*/ctx[0]);
	  const get_key = ctx => /*chunk*/ctx[20].event;
	  validate_each_keys(ctx, each_value, get_each_context$3$1, get_key);
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$3$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$3$1(key, child_ctx));
	  }
	  const block = {
	    c: function create() {
	      div2 = element("div");
	      div0 = element("div");
	      time = element("time");
	      t0 = space();
	      a = element("a");
	      t1 = text("Ã");
	      t2 = space();
	      div1 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(time, "datetime", time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10));
	      add_location(time, file$2$3, 88, 8, 2732);
	      attr_dev(a, "role", "button");
	      attr_dev(a, "tabindex", "0");
	      attr_dev(a, "aria-label", a_aria_label_value = /*$buttonText*/ctx[6].close);
	      add_location(a, file$2$3, 90, 8, 2904);
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[4].dayHead);
	      add_location(div0, file$2$3, 87, 4, 2693);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[4].events);
	      add_location(div1, file$2$3, 98, 4, 3123);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[4].popup);
	      attr_dev(div2, "style", /*style*/ctx[2]);
	      add_location(div2, file$2$3, 79, 0, 2499);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div0);
	      append_dev(div0, time);
	      append_dev(div0, t0);
	      append_dev(div0, a);
	      append_dev(a, t1);
	      append_dev(div2, t2);
	      append_dev(div2, div1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }

	      /*div2_binding*/
	      ctx[16](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]))), listen_dev(a, "click", stop_propagation( /*close*/ctx[13]), false, false, true, false), listen_dev(a, "keydown", keyEnter( /*close*/ctx[13]), false, false, false, false), action_destroyer(outsideEvent.call(null, div2, 'pointerdown')), listen_dev(div2, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[15]), false, false, true, false), listen_dev(div2, "pointerdownoutside", /*handlePointerDownOutside*/ctx[14], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref4) {
	      let [dirty] = _ref4;
	      if (!current || dirty & /*$_popupDate*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*$_popupDate*/ctx[3], 10))) {
	        attr_dev(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayPopover, $_popupDate*/40) setContent_action.update.call(null, /*$_intlDayPopover*/ctx[5].format( /*$_popupDate*/ctx[3]));
	      if (!current || dirty & /*$buttonText*/64 && a_aria_label_value !== (a_aria_label_value = /*$buttonText*/ctx[6].close)) {
	        attr_dev(a, "aria-label", a_aria_label_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div0_class_value !== (div0_class_value = /*$theme*/ctx[4].dayHead)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (dirty & /*$_popupChunks*/1) {
	        each_value = ensure_array_like_dev( /*$_popupChunks*/ctx[0]);
	        group_outros();
	        validate_each_keys(ctx, each_value, get_each_context$3$1, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$3$1, null, get_each_context$3$1);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/16 && div1_class_value !== (div1_class_value = /*$theme*/ctx[4].events)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (!current || dirty & /*$theme*/16 && div2_class_value !== (div2_class_value = /*$theme*/ctx[4].popup)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	      if (!current || dirty & /*style*/4) {
	        attr_dev(div2, "style", /*style*/ctx[2]);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div2);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div2_binding*/
	      ctx[16](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$3$3($$self, $$props, $$invalidate) {
	  let $_interaction;
	  let $_popupDate;
	  let $_popupChunks;
	  let $theme;
	  let $_intlDayPopover;
	  let $buttonText;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Popup', slots, []);
	  let {
	    buttonText,
	    theme,
	    _interaction,
	    _intlDayPopover,
	    _popupDate,
	    _popupChunks
	  } = getContext('state');
	  validate_store(buttonText, 'buttonText');
	  component_subscribe($$self, buttonText, value => $$invalidate(6, $buttonText = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(17, $_interaction = value));
	  validate_store(_intlDayPopover, '_intlDayPopover');
	  component_subscribe($$self, _intlDayPopover, value => $$invalidate(5, $_intlDayPopover = value));
	  validate_store(_popupDate, '_popupDate');
	  component_subscribe($$self, _popupDate, value => $$invalidate(3, $_popupDate = value));
	  validate_store(_popupChunks, '_popupChunks');
	  component_subscribe($$self, _popupChunks, value => $$invalidate(0, $_popupChunks = value));
	  let el;
	  let style = '';
	  function position() {
	    let dayEl = ancestor(el, 1);
	    let bodyEl = ancestor(dayEl, 3);
	    let popupRect = rect(el);
	    let dayRect = rect(dayEl);
	    let bodyRect = rect(bodyEl);
	    $$invalidate(2, style = '');
	    let left;
	    if (popupRect.width >= bodyRect.width) {
	      left = bodyRect.left - dayRect.left;
	      let right = dayRect.right - bodyRect.right;
	      $$invalidate(2, style += `right:${right}px;`);
	    } else {
	      left = (dayRect.width - popupRect.width) / 2;
	      if (dayRect.left + left < bodyRect.left) {
	        left = bodyRect.left - dayRect.left;
	      } else if (dayRect.left + left + popupRect.width > bodyRect.right) {
	        left = bodyRect.right - dayRect.left - popupRect.width;
	      }
	    }
	    $$invalidate(2, style += `left:${left}px;`);
	    let top;
	    if (popupRect.height >= bodyRect.height) {
	      top = bodyRect.top - dayRect.top;
	      let bottom = dayRect.bottom - bodyRect.bottom;
	      $$invalidate(2, style += `bottom:${bottom}px;`);
	    } else {
	      top = (dayRect.height - popupRect.height) / 2;
	      if (dayRect.top + top < bodyRect.top) {
	        top = bodyRect.top - dayRect.top;
	      } else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
	        top = bodyRect.bottom - dayRect.top - popupRect.height;
	      }
	    }
	    $$invalidate(2, style += `top:${top}px;`);
	  }
	  function reposition() {
	    // Skip the first call (el is not defined at this time)
	    if (el) {
	      $$invalidate(2, style = '');

	      // Let chunks to update/mount then position the popup
	      tick().then(() => {
	        if ($_popupChunks.length) {
	          position();
	        } else {
	          close();
	        }
	      });
	    }
	  }
	  function close(e) {
	    set_store_value(_popupDate, $_popupDate = null, $_popupDate);
	  }
	  function handlePointerDownOutside(e) {
	    close();
	    $_interaction.action?.noClick();
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Popup> was created with unknown prop '${key}'`);
	  });
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$capture_state = () => ({
	    getContext,
	    tick,
	    ancestor,
	    rect,
	    setContent,
	    outsideEvent,
	    keyEnter,
	    toISOString,
	    Event: Event$3,
	    buttonText,
	    theme,
	    _interaction,
	    _intlDayPopover,
	    _popupDate,
	    _popupChunks,
	    el,
	    style,
	    position,
	    reposition,
	    close,
	    handlePointerDownOutside,
	    $_interaction,
	    $_popupDate,
	    $_popupChunks,
	    $theme,
	    $_intlDayPopover,
	    $buttonText
	  });
	  $$self.$inject_state = $$props => {
	    if ('buttonText' in $$props) $$invalidate(7, buttonText = $$props.buttonText);
	    if ('theme' in $$props) $$invalidate(8, theme = $$props.theme);
	    if ('_interaction' in $$props) $$invalidate(9, _interaction = $$props._interaction);
	    if ('_intlDayPopover' in $$props) $$invalidate(10, _intlDayPopover = $$props._intlDayPopover);
	    if ('_popupDate' in $$props) $$invalidate(11, _popupDate = $$props._popupDate);
	    if ('_popupChunks' in $$props) $$invalidate(12, _popupChunks = $$props._popupChunks);
	    if ('el' in $$props) $$invalidate(1, el = $$props.el);
	    if ('style' in $$props) $$invalidate(2, style = $$props.style);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_popupChunks*/1) {
	      if ($_popupChunks) {
	        // Fire reposition only on popup chunks change
	        reposition();
	      }
	    }
	  };
	  return [$_popupChunks, el, style, $_popupDate, $theme, $_intlDayPopover, $buttonText, buttonText, theme, _interaction, _intlDayPopover, _popupDate, _popupChunks, close, handlePointerDownOutside, pointerdown_handler, div2_binding];
	}
	class Popup extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3$3, create_fragment$3$3, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Popup",
	      options,
	      id: create_fragment$3$3.name
	    });
	  }
	}

	/* packages/day-grid/src/Day.svelte generated by Svelte v4.2.16 */
	const file$1$3 = "packages/day-grid/src/Day.svelte";
	function get_each_context$2$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[42] = list[i];
	  child_ctx[43] = list;
	  child_ctx[44] = i;
	  return child_ctx;
	}

	// (109:4) {#if iChunks[1] && datesEqual(iChunks[1].date, date)}
	function create_if_block_3$1(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*iChunks*/ctx[2][1]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[12].events);
	      add_location(div, file$1$3, 109, 8, 3622);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][1];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = /*$theme*/ctx[12].events)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(event);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_3$1.name,
	    type: "if",
	    source: "(109:4) {#if iChunks[1] && datesEqual(iChunks[1].date, date)}",
	    ctx
	  });
	  return block;
	}

	// (115:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
	function create_if_block_2$2(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event$3({
	    props: {
	      chunk: /*iChunks*/ctx[2][0]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview));
	      add_location(div, file$1$3, 115, 8, 3810);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][0];
	      event.$set(event_changes);
	      if (!current || dirty[0] & /*$theme*/4096 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[12].events + " " + /*$theme*/ctx[12].preview))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(event);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$2.name,
	    type: "if",
	    source: "(115:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}",
	    ctx
	  });
	  return block;
	}

	// (121:8) {#each dayChunks as chunk, i (chunk.event)}
	function create_each_block$2$1(key_1, ctx) {
	  let first;
	  let event;
	  let i = /*i*/ctx[44];
	  let current;
	  const assign_event = () => /*event_binding*/ctx[36](event, i);
	  const unassign_event = () => /*event_binding*/ctx[36](null, i);
	  let event_props = {
	    chunk: /*chunk*/ctx[42],
	    longChunks: /*longChunks*/ctx[1]
	  };
	  event = new Event$3({
	    props: event_props,
	    $$inline: true
	  });
	  assign_event();
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (i !== /*i*/ctx[44]) {
	        unassign_event();
	        i = /*i*/ctx[44];
	        assign_event();
	      }
	      const event_changes = {};
	      if (dirty[0] & /*dayChunks*/16) event_changes.chunk = /*chunk*/ctx[42];
	      if (dirty[0] & /*longChunks*/2) event_changes.longChunks = /*longChunks*/ctx[1];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      unassign_event();
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$2$1.name,
	    type: "each",
	    source: "(121:8) {#each dayChunks as chunk, i (chunk.event)}",
	    ctx
	  });
	  return block;
	}

	// (125:4) {#if showPopup}
	function create_if_block_1$2(ctx) {
	  let popup;
	  let current;
	  popup = new Popup({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(popup.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(popup, target, anchor);
	      current = true;
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(popup.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(popup.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(popup, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$2.name,
	    type: "if",
	    source: "(125:4) {#if showPopup}",
	    ctx
	  });
	  return block;
	}

	// (129:8) {#if hiddenEvents.size}
	function create_if_block$5(ctx) {
	  let a;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      a = element("a");
	      attr_dev(a, "role", "button");
	      attr_dev(a, "tabindex", "0");
	      attr_dev(a, "aria-haspopup", "true");
	      add_location(a, file$1$3, 131, 12, 4338);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, a, anchor);
	      if (!mounted) {
	        dispose = [listen_dev(a, "click", stop_propagation( /*showMore*/ctx[26]), false, false, true, false), listen_dev(a, "keydown", keyEnter( /*showMore*/ctx[26]), false, false, false, false), listen_dev(a, "pointerdown", stop_propagation( /*pointerdown_handler*/ctx[35]), false, false, true, false), action_destroyer(setContent_action = setContent.call(null, a, /*moreLink*/ctx[10]))];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/1024) setContent_action.update.call(null, /*moreLink*/ctx[10]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(a);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$5.name,
	    type: "if",
	    source: "(129:8) {#if hiddenEvents.size}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$2$4(ctx) {
	  let div2;
	  let time;
	  let time_class_value;
	  let time_datetime_value;
	  let setContent_action;
	  let t0;
	  let show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	  let t1;
	  let show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	  let t2;
	  let div0;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div0_class_value;
	  let t3;
	  let t4;
	  let div1;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let if_block0 = show_if_1 && create_if_block_3$1(ctx);
	  let if_block1 = show_if && create_if_block_2$2(ctx);
	  let each_value = ensure_array_like_dev( /*dayChunks*/ctx[4]);
	  const get_key = ctx => /*chunk*/ctx[42].event;
	  validate_each_keys(ctx, each_value, get_each_context$2$1, get_key);
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$2$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$2$1(key, child_ctx));
	  }
	  let if_block2 = /*showPopup*/ctx[6] && create_if_block_1$2(ctx);
	  let if_block3 = /*hiddenEvents*/ctx[5].size && create_if_block$5(ctx);
	  const block = {
	    c: function create() {
	      div2 = element("div");
	      time = element("time");
	      t0 = space();
	      if (if_block0) if_block0.c();
	      t1 = space();
	      if (if_block1) if_block1.c();
	      t2 = space();
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();
	      div1 = element("div");
	      if (if_block3) if_block3.c();
	      attr_dev(time, "class", time_class_value = /*$theme*/ctx[12].dayHead);
	      attr_dev(time, "datetime", time_datetime_value = toISOString( /*date*/ctx[0], 10));
	      add_location(time, file$1$3, 102, 4, 3388);
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[12].events);
	      add_location(div0, file$1$3, 119, 4, 3926);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[12].dayFoot);
	      add_location(div1, file$1$3, 127, 4, 4149);
	      attr_dev(div2, "class", div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[7] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[8] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[9] ? ' ' + /*$theme*/ctx[12].highlight : '')));
	      attr_dev(div2, "role", "cell");
	      add_location(div2, file$1$3, 94, 0, 2996);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, time);
	      append_dev(div2, t0);
	      if (if_block0) if_block0.m(div2, null);
	      append_dev(div2, t1);
	      if (if_block1) if_block1.m(div2, null);
	      append_dev(div2, t2);
	      append_dev(div2, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      append_dev(div2, t3);
	      if (if_block2) if_block2.m(div2, null);
	      append_dev(div2, t4);
	      append_dev(div2, div1);
	      if (if_block3) if_block3.m(div1, null);
	      /*div2_binding*/
	      ctx[37](div2);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]))), listen_dev(div2, "pointerenter", function () {
	          if (is_function( /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]))) /*createPointerEnterHandler*/ctx[25]( /*$_interaction*/ctx[13]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(div2, "pointerleave", function () {
	          if (is_function( /*$_interaction*/ctx[13].pointer?.leave)) /*$_interaction*/ctx[13].pointer?.leave.apply(this, arguments);
	        }, false, false, false, false), listen_dev(div2, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[13].action?.select)) /*$_interaction*/ctx[13].action?.select.apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4096 && time_class_value !== (time_class_value = /*$theme*/ctx[12].dayHead)) {
	        attr_dev(time, "class", time_class_value);
	      }
	      if (!current || dirty[0] & /*date*/1 && time_datetime_value !== (time_datetime_value = toISOString( /*date*/ctx[0], 10))) {
	        attr_dev(time, "datetime", time_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayCell, date*/16385) setContent_action.update.call(null, /*$_intlDayCell*/ctx[14].format( /*date*/ctx[0]));
	      if (dirty[0] & /*iChunks, date*/5) show_if_1 = /*iChunks*/ctx[2][1] && datesEqual( /*iChunks*/ctx[2][1].date, /*date*/ctx[0]);
	      if (show_if_1) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_3$1(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div2, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, () => {
	          if_block0 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*iChunks, date*/5) show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	      if (show_if) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*iChunks, date*/5) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_2$2(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div2, t2);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*dayChunks, longChunks, refs*/2066) {
	        each_value = ensure_array_like_dev( /*dayChunks*/ctx[4]);
	        group_outros();
	        validate_each_keys(ctx, each_value, get_each_context$2$1, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2$1, null, get_each_context$2$1);
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div0_class_value !== (div0_class_value = /*$theme*/ctx[12].events)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if ( /*showPopup*/ctx[6]) {
	        if (if_block2) {
	          if (dirty[0] & /*showPopup*/64) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_1$2(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div2, t4);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, () => {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	      if ( /*hiddenEvents*/ctx[5].size) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block$5(ctx);
	          if_block3.c();
	          if_block3.m(div1, null);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }
	      if (!current || dirty[0] & /*$theme*/4096 && div1_class_value !== (div1_class_value = /*$theme*/ctx[12].dayFoot)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (!current || dirty[0] & /*$theme, date, isToday, otherMonth, highlight*/4993 && div2_class_value !== (div2_class_value = "" + ( /*$theme*/ctx[12].day + " " + /*$theme*/ctx[12].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[7] ? ' ' + /*$theme*/ctx[12].today : '') + ( /*otherMonth*/ctx[8] ? ' ' + /*$theme*/ctx[12].otherMonth : '') + ( /*highlight*/ctx[9] ? ' ' + /*$theme*/ctx[12].highlight : '')))) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      transition_in(if_block2);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      transition_out(if_block2);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div2);
	      }
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      /*div2_binding*/
	      ctx[37](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2$4($$self, $$props, $$invalidate) {
	  let $_popupChunks;
	  let $_popupDate;
	  let $moreLinkContent;
	  let $_hiddenEvents;
	  let $highlightedDates;
	  let $currentDate;
	  let $_today;
	  let $theme;
	  let $_interaction;
	  let $_intlDayCell;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Day', slots, []);
	  let {
	    date
	  } = $$props;
	  let {
	    chunks
	  } = $$props;
	  let {
	    longChunks
	  } = $$props;
	  let {
	    iChunks = []
	  } = $$props;
	  let {
	    date: currentDate,
	    dayMaxEvents,
	    highlightedDates,
	    moreLinkContent,
	    theme,
	    _hiddenEvents,
	    _intlDayCell,
	    _popupDate,
	    _popupChunks,
	    _today,
	    _interaction,
	    _queue
	  } = getContext('state');
	  validate_store(currentDate, 'currentDate');
	  component_subscribe($$self, currentDate, value => $$invalidate(33, $currentDate = value));
	  validate_store(highlightedDates, 'highlightedDates');
	  component_subscribe($$self, highlightedDates, value => $$invalidate(32, $highlightedDates = value));
	  validate_store(moreLinkContent, 'moreLinkContent');
	  component_subscribe($$self, moreLinkContent, value => $$invalidate(30, $moreLinkContent = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(12, $theme = value));
	  validate_store(_hiddenEvents, '_hiddenEvents');
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(31, $_hiddenEvents = value));
	  validate_store(_intlDayCell, '_intlDayCell');
	  component_subscribe($$self, _intlDayCell, value => $$invalidate(14, $_intlDayCell = value));
	  validate_store(_popupDate, '_popupDate');
	  component_subscribe($$self, _popupDate, value => $$invalidate(29, $_popupDate = value));
	  validate_store(_popupChunks, '_popupChunks');
	  component_subscribe($$self, _popupChunks, value => $$invalidate(38, $_popupChunks = value));
	  validate_store(_today, '_today');
	  component_subscribe($$self, _today, value => $$invalidate(34, $_today = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(13, $_interaction = value));
	  let el;
	  let dayChunks;
	  let isToday;
	  let otherMonth;
	  let highlight;
	  let hiddenEvents = new Set(); // hidden events of this day
	  let moreLink = '';
	  let showPopup;
	  let refs = [];
	  function createPointerEnterHandler(interaction) {
	    return interaction.pointer ? jsEvent => interaction.pointer.enterDayGrid(date, jsEvent) : undefined;
	  }
	  function showMore() {
	    set_store_value(_popupDate, $_popupDate = date, $_popupDate);
	  }
	  function setPopupChunks() {
	    let nextDay = addDay(cloneDate(date));
	    let chunks = dayChunks.concat(longChunks[date.getTime()]?.chunks || []);
	    set_store_value(_popupChunks, $_popupChunks = chunks.map(chunk => assign({}, chunk, createEventChunk(chunk.event, date, nextDay), {
	      days: 1,
	      dates: [date]
	    })).sort((a, b) => a.top - b.top), $_popupChunks);
	  }
	  function reposition() {
	    runReposition(refs, dayChunks);
	  }
	  $$self.$$.on_mount.push(function () {
	    if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
	      console.warn("<Day> was created without expected prop 'date'");
	    }
	    if (chunks === undefined && !('chunks' in $$props || $$self.$$.bound[$$self.$$.props['chunks']])) {
	      console.warn("<Day> was created without expected prop 'chunks'");
	    }
	    if (longChunks === undefined && !('longChunks' in $$props || $$self.$$.bound[$$self.$$.props['longChunks']])) {
	      console.warn("<Day> was created without expected prop 'longChunks'");
	    }
	  });
	  const writable_props = ['date', 'chunks', 'longChunks', 'iChunks'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Day> was created with unknown prop '${key}'`);
	  });
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  function event_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(11, refs);
	    });
	  }
	  function div2_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(27, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    tick,
	    is_function,
	    datesEqual,
	    setContent,
	    createEventChunk,
	    addDay,
	    cloneDate,
	    assign,
	    setPayload,
	    toISOString,
	    keyEnter,
	    runReposition,
	    Event: Event$3,
	    Popup,
	    date,
	    chunks,
	    longChunks,
	    iChunks,
	    currentDate,
	    dayMaxEvents,
	    highlightedDates,
	    moreLinkContent,
	    theme,
	    _hiddenEvents,
	    _intlDayCell,
	    _popupDate,
	    _popupChunks,
	    _today,
	    _interaction,
	    _queue,
	    el,
	    dayChunks,
	    isToday,
	    otherMonth,
	    highlight,
	    hiddenEvents,
	    moreLink,
	    showPopup,
	    refs,
	    createPointerEnterHandler,
	    showMore,
	    setPopupChunks,
	    reposition,
	    $_popupChunks,
	    $_popupDate,
	    $moreLinkContent,
	    $_hiddenEvents,
	    $highlightedDates,
	    $currentDate,
	    $_today,
	    $theme,
	    $_interaction,
	    $_intlDayCell
	  });
	  $$self.$inject_state = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(27, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	    if ('currentDate' in $$props) $$invalidate(15, currentDate = $$props.currentDate);
	    if ('dayMaxEvents' in $$props) dayMaxEvents = $$props.dayMaxEvents;
	    if ('highlightedDates' in $$props) $$invalidate(16, highlightedDates = $$props.highlightedDates);
	    if ('moreLinkContent' in $$props) $$invalidate(17, moreLinkContent = $$props.moreLinkContent);
	    if ('theme' in $$props) $$invalidate(18, theme = $$props.theme);
	    if ('_hiddenEvents' in $$props) $$invalidate(19, _hiddenEvents = $$props._hiddenEvents);
	    if ('_intlDayCell' in $$props) $$invalidate(20, _intlDayCell = $$props._intlDayCell);
	    if ('_popupDate' in $$props) $$invalidate(21, _popupDate = $$props._popupDate);
	    if ('_popupChunks' in $$props) $$invalidate(22, _popupChunks = $$props._popupChunks);
	    if ('_today' in $$props) $$invalidate(23, _today = $$props._today);
	    if ('_interaction' in $$props) $$invalidate(24, _interaction = $$props._interaction);
	    if ('_queue' in $$props) _queue = $$props._queue;
	    if ('el' in $$props) $$invalidate(3, el = $$props.el);
	    if ('dayChunks' in $$props) $$invalidate(4, dayChunks = $$props.dayChunks);
	    if ('isToday' in $$props) $$invalidate(7, isToday = $$props.isToday);
	    if ('otherMonth' in $$props) $$invalidate(8, otherMonth = $$props.otherMonth);
	    if ('highlight' in $$props) $$invalidate(9, highlight = $$props.highlight);
	    if ('hiddenEvents' in $$props) $$invalidate(5, hiddenEvents = $$props.hiddenEvents);
	    if ('moreLink' in $$props) $$invalidate(10, moreLink = $$props.moreLink);
	    if ('showPopup' in $$props) $$invalidate(6, showPopup = $$props.showPopup);
	    if ('refs' in $$props) $$invalidate(11, refs = $$props.refs);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*hiddenEvents, chunks, date, dayChunks*/134217777) {
	      {
	        $$invalidate(4, dayChunks = []);
	        hiddenEvents.clear();
	        (($$invalidate(5, hiddenEvents), $$invalidate(27, chunks)), $$invalidate(0, date)), $$invalidate(4, dayChunks);
	        for (let chunk of chunks) {
	          if (datesEqual(chunk.date, date)) {
	            dayChunks.push(chunk);
	          } // if ($dayMaxEvents !== false && dayChunks.length > $dayMaxEvents) {
	          // 	chunk.hidden = true;
	        } // }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*date, hiddenEvents*/33) {
	      set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$_today*/8) {
	      $$invalidate(7, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty[0] & /*date*/1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/6) {
	      {
	        $$invalidate(8, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
	        $$invalidate(9, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*hiddenEvents, $moreLinkContent*/1073741856 | $$self.$$.dirty[1] & /*$_hiddenEvents*/1) {
	      if ($_hiddenEvents && hiddenEvents.size) {
	        // make Svelte update this block on $_hiddenEvents update
	        let text = '+' + hiddenEvents.size + ' more';
	        if ($moreLinkContent) {
	          $$invalidate(10, moreLink = is_function($moreLinkContent) ? $moreLinkContent({
	            num: hiddenEvents.size,
	            text
	          }) : $moreLinkContent);
	        } else {
	          $$invalidate(10, moreLink = text);
	        }
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_popupDate, date*/536870913) {
	      $$invalidate(6, showPopup = $_popupDate && datesEqual(date, $_popupDate));
	    }
	    if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/82) {
	      if (showPopup && longChunks && dayChunks) {
	        // Let chunks to reposition then set popup chunks
	        tick().then(setPopupChunks);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*el, date*/9) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource: undefined,
	          dayEl: el
	        }));
	      }
	    }
	  };
	  return [date, longChunks, iChunks, el, dayChunks, hiddenEvents, showPopup, isToday, otherMonth, highlight, moreLink, refs, $theme, $_interaction, $_intlDayCell, currentDate, highlightedDates, moreLinkContent, theme, _hiddenEvents, _intlDayCell, _popupDate, _popupChunks, _today, _interaction, createPointerEnterHandler, showMore, chunks, reposition, $_popupDate, $moreLinkContent, $_hiddenEvents, $highlightedDates, $currentDate, $_today, pointerdown_handler, event_binding, div2_binding];
	}
	let Day$3 = class Day extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2$4, create_fragment$2$4, safe_not_equal, {
	      date: 0,
	      chunks: 27,
	      longChunks: 1,
	      iChunks: 2,
	      reposition: 28
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Day",
	      options,
	      id: create_fragment$2$4.name
	    });
	  }
	  get date() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get chunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get longChunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set longChunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get iChunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set iChunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get reposition() {
	    return this.$$.ctx[28];
	  }
	  set reposition(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/day-grid/src/Week.svelte generated by Svelte v4.2.16 */
	const file$a = "packages/day-grid/src/Week.svelte";
	function get_each_context$1$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  child_ctx[22] = list;
	  child_ctx[23] = i;
	  return child_ctx;
	}

	// (57:4) {#each dates as date, i}
	function create_each_block$1$2(ctx) {
	  let day;
	  let i = /*i*/ctx[23];
	  let current;
	  const assign_day = () => /*day_binding*/ctx[18](day, i);
	  const unassign_day = () => /*day_binding*/ctx[18](null, i);
	  let day_props = {
	    date: /*date*/ctx[21],
	    chunks: /*chunks*/ctx[1],
	    longChunks: /*longChunks*/ctx[2],
	    iChunks: /*iChunks*/ctx[3]
	  };
	  day = new Day$3({
	    props: day_props,
	    $$inline: true
	  });
	  assign_day();
	  const block = {
	    c: function create() {
	      create_component(day.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (i !== /*i*/ctx[23]) {
	        unassign_day();
	        i = /*i*/ctx[23];
	        assign_day();
	      }
	      const day_changes = {};
	      if (dirty & /*dates*/1) day_changes.date = /*date*/ctx[21];
	      if (dirty & /*chunks*/2) day_changes.chunks = /*chunks*/ctx[1];
	      if (dirty & /*longChunks*/4) day_changes.longChunks = /*longChunks*/ctx[2];
	      if (dirty & /*iChunks*/8) day_changes.iChunks = /*iChunks*/ctx[3];
	      day.$set(day_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      unassign_day();
	      destroy_component(day, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1$2.name,
	    type: "each",
	    source: "(57:4) {#each dates as date, i}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1$4(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like_dev( /*dates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1$2(get_each_context$1$2(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].days);
	      attr_dev(div, "role", "row");
	      add_location(div, file$a, 55, 0, 1495);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	      if (!mounted) {
	        dispose = listen_dev(window, "resize", /*reposition*/ctx[11], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref5) {
	      let [dirty] = _ref5;
	      if (dirty & /*dates, chunks, longChunks, iChunks, refs*/31) {
	        each_value = ensure_array_like_dev( /*dates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1$2(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1$2(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].days)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1$4($$self, $$props, $$invalidate) {
	  let $_hiddenEvents;
	  let $hiddenDays;
	  let $_iEvents;
	  let $_events;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Week', slots, []);
	  let {
	    dates
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    _queue2,
	    _hiddenEvents,
	    hiddenDays,
	    theme
	  } = getContext('state');
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(17, $_events = value));
	  validate_store(_iEvents, '_iEvents');
	  component_subscribe($$self, _iEvents, value => $$invalidate(16, $_iEvents = value));
	  validate_store(_hiddenEvents, '_hiddenEvents');
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(14, $_hiddenEvents = value));
	  validate_store(hiddenDays, 'hiddenDays');
	  component_subscribe($$self, hiddenDays, value => $$invalidate(15, $hiddenDays = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(5, $theme = value));
	  let chunks,
	    longChunks,
	    iChunks = [];
	  let start;
	  let end;
	  let refs = [];
	  let debounceHandle = {};
	  function reposition() {
	    debounce(() => runReposition(refs, dates), debounceHandle, _queue2);
	  }
	  $$self.$$.on_mount.push(function () {
	    if (dates === undefined && !('dates' in $$props || $$self.$$.bound[$$self.$$.props['dates']])) {
	      console.warn("<Week> was created without expected prop 'dates'");
	    }
	  });
	  const writable_props = ['dates'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Week> was created with unknown prop '${key}'`);
	  });
	  function day_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(4, refs);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    cloneDate,
	    addDay,
	    eventIntersects,
	    bgEvent,
	    createEventChunk,
	    prepareEventChunks,
	    runReposition,
	    debounce,
	    Day: Day$3,
	    dates,
	    _events,
	    _iEvents,
	    _queue2,
	    _hiddenEvents,
	    hiddenDays,
	    theme,
	    chunks,
	    longChunks,
	    iChunks,
	    start,
	    end,
	    refs,
	    debounceHandle,
	    reposition,
	    $_hiddenEvents,
	    $hiddenDays,
	    $_iEvents,
	    $_events,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	    if ('_events' in $$props) $$invalidate(6, _events = $$props._events);
	    if ('_iEvents' in $$props) $$invalidate(7, _iEvents = $$props._iEvents);
	    if ('_queue2' in $$props) _queue2 = $$props._queue2;
	    if ('_hiddenEvents' in $$props) $$invalidate(8, _hiddenEvents = $$props._hiddenEvents);
	    if ('hiddenDays' in $$props) $$invalidate(9, hiddenDays = $$props.hiddenDays);
	    if ('theme' in $$props) $$invalidate(10, theme = $$props.theme);
	    if ('chunks' in $$props) $$invalidate(1, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(2, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(3, iChunks = $$props.iChunks);
	    if ('start' in $$props) $$invalidate(12, start = $$props.start);
	    if ('end' in $$props) $$invalidate(13, end = $$props.end);
	    if ('refs' in $$props) $$invalidate(4, refs = $$props.refs);
	    if ('debounceHandle' in $$props) debounceHandle = $$props.debounceHandle;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*dates*/1) {
	      {
	        $$invalidate(12, start = dates[0]);
	        $$invalidate(13, end = addDay(cloneDate(dates[dates.length - 1])));
	      }
	    }
	    if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/176130) {
	      {
	        $$invalidate(1, chunks = []);
	        for (let event of $_events) {
	          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        $$invalidate(2, longChunks = prepareEventChunks(chunks, $hiddenDays));

	        // Run reposition only when events get changed
	        reposition();
	      }
	    }
	    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/110592) {
	      $$invalidate(3, iChunks = $_iEvents.map(event => {
	        let chunk;
	        if (event && eventIntersects(event, start, end)) {
	          chunk = createEventChunk(event, start, end);
	          prepareEventChunks([chunk], $hiddenDays);
	        } else {
	          chunk = null;
	        }
	        return chunk;
	      }));
	    }
	    if ($$self.$$.dirty & /*$_hiddenEvents*/16384) {
	      if ($_hiddenEvents) {
	        reposition();
	      }
	    }
	  };
	  return [dates, chunks, longChunks, iChunks, refs, $theme, _events, _iEvents, _hiddenEvents, hiddenDays, theme, reposition, start, end, $_hiddenEvents, $hiddenDays, $_iEvents, $_events, day_binding];
	}
	let Week$1 = class Week extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1$4, create_fragment$1$4, safe_not_equal, {
	      dates: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Week",
	      options,
	      id: create_fragment$1$4.name
	    });
	  }
	  get dates() {
	    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set dates(value) {
	    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/day-grid/src/View.svelte generated by Svelte v4.2.16 */

	function get_each_context$8(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}

	// (29:0) {#each weeks as dates}
	function create_each_block$8(ctx) {
	  let week;
	  let current;
	  week = new Week$1({
	    props: {
	      dates: /*dates*/ctx[10]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(week.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const week_changes = {};
	      if (dirty & /*weeks*/1) week_changes.dates = /*dates*/ctx[10];
	      week.$set(week_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$8.name,
	    type: "each",
	    source: "(29:0) {#each weeks as dates}",
	    ctx
	  });
	  return block;
	}

	// (28:0) <Body>
	function create_default_slot$4(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like_dev( /*weeks*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*weeks*/1) {
	        each_value = ensure_array_like_dev( /*weeks*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$8(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$8(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot$4.name,
	    type: "slot",
	    source: "(28:0) <Body>",
	    ctx
	  });
	  return block;
	}
	function create_fragment$b(ctx) {
	  let header;
	  let t;
	  let body;
	  let current;
	  header = new Header({
	    $$inline: true
	  });
	  body = new Body$2({
	    props: {
	      $$slots: {
	        default: [create_default_slot$4]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(header.$$.fragment);
	      t = space();
	      create_component(body.$$.fragment);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      mount_component(header, target, anchor);
	      insert_dev(target, t, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref6) {
	      let [dirty] = _ref6;
	      const body_changes = {};
	      if (dirty & /*$$scope, weeks*/8193) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(header.$$.fragment, local);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(header.$$.fragment, local);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(t);
	      }
	      destroy_component(header, detaching);
	      destroy_component(body, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$b.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$b($$self, $$props, $$invalidate) {
	  let $_viewDates;
	  let $dayMaxEvents;
	  let $_hiddenEvents;
	  let $hiddenDays;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('View', slots, []);
	  let {
	    _viewDates,
	    _hiddenEvents,
	    dayMaxEvents,
	    hiddenDays
	  } = getContext('state');
	  validate_store(_viewDates, '_viewDates');
	  component_subscribe($$self, _viewDates, value => $$invalidate(6, $_viewDates = value));
	  validate_store(_hiddenEvents, '_hiddenEvents');
	  component_subscribe($$self, _hiddenEvents, value => $$invalidate(9, $_hiddenEvents = value));
	  validate_store(dayMaxEvents, 'dayMaxEvents');
	  component_subscribe($$self, dayMaxEvents, value => $$invalidate(7, $dayMaxEvents = value));
	  validate_store(hiddenDays, 'hiddenDays');
	  component_subscribe($$self, hiddenDays, value => $$invalidate(8, $hiddenDays = value));
	  let weeks;
	  let days;
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<View> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    Header,
	    Body: Body$2,
	    Week: Week$1,
	    _viewDates,
	    _hiddenEvents,
	    dayMaxEvents,
	    hiddenDays,
	    weeks,
	    days,
	    $_viewDates,
	    $dayMaxEvents,
	    $_hiddenEvents,
	    $hiddenDays
	  });
	  $$self.$inject_state = $$props => {
	    if ('_viewDates' in $$props) $$invalidate(1, _viewDates = $$props._viewDates);
	    if ('_hiddenEvents' in $$props) $$invalidate(2, _hiddenEvents = $$props._hiddenEvents);
	    if ('dayMaxEvents' in $$props) $$invalidate(3, dayMaxEvents = $$props.dayMaxEvents);
	    if ('hiddenDays' in $$props) $$invalidate(4, hiddenDays = $$props.hiddenDays);
	    if ('weeks' in $$props) $$invalidate(0, weeks = $$props.weeks);
	    if ('days' in $$props) $$invalidate(5, days = $$props.days);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$hiddenDays, $dayMaxEvents, $_viewDates, days, weeks*/481) {
	      {
	        $$invalidate(0, weeks = []);
	        $$invalidate(5, days = 7 - $hiddenDays.length);
	        set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);
	        for (let i = 0; i < $_viewDates.length / days; ++i) {
	          let dates = [];
	          for (let j = 0; j < days; ++j) {
	            dates.push($_viewDates[i * days + j]);
	          }
	          weeks.push(dates);
	        }
	      }
	    }
	  };
	  return [weeks, _viewDates, _hiddenEvents, dayMaxEvents, hiddenDays, days, $_viewDates, $dayMaxEvents, $hiddenDays];
	}
	let View$3 = class View extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$b, create_fragment$b, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "View",
	      options,
	      id: create_fragment$b.name
	    });
	  }
	};
	var index$5 = {
	  createOptions(options) {
	    options.dayMaxEvents = false;
	    options.dayCellFormat = {
	      day: 'numeric'
	    };
	    options.dayPopoverFormat = {
	      month: 'long',
	      day: 'numeric',
	      year: 'numeric'
	    };
	    options.moreLinkContent = undefined;
	    // Common options
	    options.buttonText.dayGridMonth = 'month';
	    options.buttonText.close = 'Close';
	    options.theme.uniform = 'ec-uniform';
	    options.theme.dayFoot = 'ec-day-foot';
	    options.theme.popup = 'ec-popup';
	    options.view = 'dayGridMonth';
	    options.views.dayGridMonth = {
	      buttonText: btnTextMonth,
	      component: View$3,
	      dayHeaderFormat: {
	        weekday: 'short'
	      },
	      dayHeaderAriaLabelFormat: {
	        weekday: 'long'
	      },
	      displayEventEnd: false,
	      duration: {
	        months: 1
	      },
	      theme: themeView('ec-day-grid ec-month-view'),
	      titleFormat: {
	        year: 'numeric',
	        month: 'long'
	      }
	    };
	  },
	  createStores(state) {
	    state._days = days(state);
	    state._intlDayCell = intl(state.locale, state.dayCellFormat);
	    state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
	    state._hiddenEvents = writable({});
	    state._popupDate = writable(null);
	    state._popupChunks = writable([]);
	  }
	};

	/* packages/list/src/Body.svelte generated by Svelte v4.2.16 */
	const file$3$1 = "packages/list/src/Body.svelte";
	function create_fragment$3$2(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  const default_slot_template = /*#slots*/ctx[5].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[4], null);
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      if (default_slot) default_slot.c();
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].content);
	      add_location(div0, file$3$1, 7, 4, 161);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[0].body);
	      add_location(div1, file$3$1, 6, 0, 108);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      if (default_slot) {
	        default_slot.m(div0, null);
	      }

	      /*div1_binding*/
	      ctx[6](div1);
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/16)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[4], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[4]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[4], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].content)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].body)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	      }
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/
	      ctx[6](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$3$2($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_bodyEl;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Body', slots, ['default']);
	  let {
	    _bodyEl,
	    theme
	  } = getContext('state');
	  validate_store(_bodyEl, '_bodyEl');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(1, $_bodyEl = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Body> was created with unknown prop '${key}'`);
	  });
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_bodyEl = $$value;
	      _bodyEl.set($_bodyEl);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    _bodyEl,
	    theme,
	    $theme,
	    $_bodyEl
	  });
	  $$self.$inject_state = $$props => {
	    if ('_bodyEl' in $$props) $$invalidate(2, _bodyEl = $$props._bodyEl);
	    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [$theme, $_bodyEl, _bodyEl, theme, $$scope, slots, div1_binding];
	}
	let Body$1 = class Body extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3$2, create_fragment$3$2, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Body",
	      options,
	      id: create_fragment$3$2.name
	    });
	  }
	};

	/* packages/list/src/Event.svelte generated by Svelte v4.2.16 */

	const file$2$2 = "packages/list/src/Event.svelte";
	function create_fragment$2$3(ctx) {
	  let article;
	  let div0;
	  let div0_class_value;
	  let t;
	  let div1;
	  let div1_class_value;
	  let setContent_action;
	  let article_role_value;
	  let article_tabindex_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      article = element("article");
	      div0 = element("div");
	      t = space();
	      div1 = element("div");
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].eventTag);
	      attr_dev(div0, "style", /*style*/ctx[3]);
	      add_location(div0, file$2$2, 91, 4, 2683);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[0].eventBody);
	      add_location(div1, file$2$2, 92, 4, 2733);
	      attr_dev(article, "class", /*classes*/ctx[2]);
	      attr_dev(article, "role", article_role_value = /*onclick*/ctx[5] ? 'button' : undefined);
	      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/ctx[5] ? 0 : undefined);
	      add_location(article, file$2$2, 80, 0, 2317);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, article, anchor);
	      append_dev(article, div0);
	      append_dev(article, t);
	      append_dev(article, div1);
	      /*article_binding*/
	      ctx[40](article);
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div1, /*content*/ctx[4])), listen_dev(article, "click", function () {
	          if (is_function( /*onclick*/ctx[5])) /*onclick*/ctx[5].apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[5] && keyEnter( /*onclick*/ctx[5]))) ( /*onclick*/ctx[5] && keyEnter( /*onclick*/ctx[5])).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[26]( /*$eventMouseEnter*/ctx[6]))) /*createHandler*/ctx[26]( /*$eventMouseEnter*/ctx[6]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[26]( /*$eventMouseLeave*/ctx[7]))) /*createHandler*/ctx[26]( /*$eventMouseLeave*/ctx[7]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[8].action?.noAction)) /*$_interaction*/ctx[8].action?.noAction.apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].eventTag)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (dirty[0] & /*style*/8) {
	        attr_dev(div0, "style", /*style*/ctx[3]);
	      }
	      if (dirty[0] & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].eventBody)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/16) setContent_action.update.call(null, /*content*/ctx[4]);
	      if (dirty[0] & /*classes*/4) {
	        attr_dev(article, "class", /*classes*/ctx[2]);
	      }
	      if (dirty[0] & /*onclick*/32 && article_role_value !== (article_role_value = /*onclick*/ctx[5] ? 'button' : undefined)) {
	        attr_dev(article, "role", article_role_value);
	      }
	      if (dirty[0] & /*onclick*/32 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[5] ? 0 : undefined)) {
	        attr_dev(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(article);
	      }

	      /*article_binding*/
	      ctx[40](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2$3($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventAllUpdated;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Event', slots, []);
	  let {
	    chunk
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventClick,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _resBgColor,
	    _resTxtColor,
	    _interaction,
	    _tasks
	  } = getContext('state');
	  validate_store(displayEventEnd, 'displayEventEnd');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(33, $displayEventEnd = value));
	  validate_store(eventAllUpdated, 'eventAllUpdated');
	  component_subscribe($$self, eventAllUpdated, value => $$invalidate(42, $eventAllUpdated = value));
	  validate_store(eventBackgroundColor, 'eventBackgroundColor');
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(38, $eventBackgroundColor = value));
	  validate_store(eventTextColor, 'eventTextColor');
	  component_subscribe($$self, eventTextColor, value => $$invalidate(35, $eventTextColor = value));
	  validate_store(eventColor, 'eventColor');
	  component_subscribe($$self, eventColor, value => $$invalidate(37, $eventColor = value));
	  validate_store(eventContent, 'eventContent');
	  component_subscribe($$self, eventContent, value => $$invalidate(32, $eventContent = value));
	  validate_store(eventClassNames, 'eventClassNames');
	  component_subscribe($$self, eventClassNames, value => $$invalidate(34, $eventClassNames = value));
	  validate_store(eventClick, 'eventClick');
	  component_subscribe($$self, eventClick, value => $$invalidate(29, $eventClick = value));
	  validate_store(eventDidMount, 'eventDidMount');
	  component_subscribe($$self, eventDidMount, value => $$invalidate(43, $eventDidMount = value));
	  validate_store(eventMouseEnter, 'eventMouseEnter');
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(6, $eventMouseEnter = value));
	  validate_store(eventMouseLeave, 'eventMouseLeave');
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(7, $eventMouseLeave = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(30, $_view = value));
	  validate_store(_intlEventTime, '_intlEventTime');
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(31, $_intlEventTime = value));
	  validate_store(_resBgColor, '_resBgColor');
	  component_subscribe($$self, _resBgColor, value => $$invalidate(39, $_resBgColor = value));
	  validate_store(_resTxtColor, '_resTxtColor');
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(36, $_resTxtColor = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (is_function($eventAllUpdated)) {
	      task(() => $eventAllUpdated({
	        view: toViewWithLocalDates($_view)
	      }), 'eau', _tasks);
	    }
	  });
	  function createHandler(fn) {
	    return is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  $$self.$$.on_mount.push(function () {
	    if (chunk === undefined && !('chunk' in $$props || $$self.$$.bound[$$self.$$.props['chunk']])) {
	      console.warn("<Event> was created without expected prop 'chunk'");
	    }
	  });
	  const writable_props = ['chunk'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Event> was created with unknown prop '${key}'`);
	  });
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(27, chunk = $$props.chunk);
	  };
	  $$self.$capture_state = () => ({
	    afterUpdate,
	    getContext,
	    onMount,
	    is_function,
	    createEventContent,
	    toEventWithLocalDates,
	    toViewWithLocalDates,
	    setContent,
	    createEventClasses,
	    keyEnter,
	    task,
	    chunk,
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventClick,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _resBgColor,
	    _resTxtColor,
	    _interaction,
	    _tasks,
	    el,
	    event,
	    classes,
	    style,
	    content,
	    timeText,
	    onclick,
	    createHandler,
	    $eventClick,
	    $_view,
	    $eventAllUpdated,
	    $eventDidMount,
	    $_intlEventTime,
	    $theme,
	    $eventContent,
	    $displayEventEnd,
	    $eventClassNames,
	    $eventTextColor,
	    $_resTxtColor,
	    $eventColor,
	    $eventBackgroundColor,
	    $_resBgColor,
	    $eventMouseEnter,
	    $eventMouseLeave,
	    $_interaction
	  });
	  $$self.$inject_state = $$props => {
	    if ('chunk' in $$props) $$invalidate(27, chunk = $$props.chunk);
	    if ('displayEventEnd' in $$props) $$invalidate(9, displayEventEnd = $$props.displayEventEnd);
	    if ('eventAllUpdated' in $$props) $$invalidate(10, eventAllUpdated = $$props.eventAllUpdated);
	    if ('eventBackgroundColor' in $$props) $$invalidate(11, eventBackgroundColor = $$props.eventBackgroundColor);
	    if ('eventTextColor' in $$props) $$invalidate(12, eventTextColor = $$props.eventTextColor);
	    if ('eventColor' in $$props) $$invalidate(13, eventColor = $$props.eventColor);
	    if ('eventContent' in $$props) $$invalidate(14, eventContent = $$props.eventContent);
	    if ('eventClassNames' in $$props) $$invalidate(15, eventClassNames = $$props.eventClassNames);
	    if ('eventClick' in $$props) $$invalidate(16, eventClick = $$props.eventClick);
	    if ('eventDidMount' in $$props) $$invalidate(17, eventDidMount = $$props.eventDidMount);
	    if ('eventMouseEnter' in $$props) $$invalidate(18, eventMouseEnter = $$props.eventMouseEnter);
	    if ('eventMouseLeave' in $$props) $$invalidate(19, eventMouseLeave = $$props.eventMouseLeave);
	    if ('theme' in $$props) $$invalidate(20, theme = $$props.theme);
	    if ('_view' in $$props) $$invalidate(21, _view = $$props._view);
	    if ('_intlEventTime' in $$props) $$invalidate(22, _intlEventTime = $$props._intlEventTime);
	    if ('_resBgColor' in $$props) $$invalidate(23, _resBgColor = $$props._resBgColor);
	    if ('_resTxtColor' in $$props) $$invalidate(24, _resTxtColor = $$props._resTxtColor);
	    if ('_interaction' in $$props) $$invalidate(25, _interaction = $$props._interaction);
	    if ('_tasks' in $$props) _tasks = $$props._tasks;
	    if ('el' in $$props) $$invalidate(1, el = $$props.el);
	    if ('event' in $$props) $$invalidate(28, event = $$props.event);
	    if ('classes' in $$props) $$invalidate(2, classes = $$props.classes);
	    if ('style' in $$props) $$invalidate(3, style = $$props.style);
	    if ('content' in $$props) $$invalidate(4, content = $$props.content);
	    if ('timeText' in $$props) timeText = $$props.timeText;
	    if ('onclick' in $$props) $$invalidate(5, onclick = $$props.onclick);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*chunk*/134217728) {
	      $$invalidate(28, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme, $_view*/1342177289 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, $eventClassNames*/504) {
	      {
	        // Class & Style
	        $$invalidate(3, style = '');
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        if (bgColor) {
	          $$invalidate(3, style = `background-color:${bgColor};`);
	        }
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        if (txtColor) {
	          $$invalidate(3, style += `color:${txtColor};`);
	        }
	        $$invalidate(2, classes = [$theme.event, ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*chunk, $theme, $_view*/1207959553 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime*/7) {
	      {
	        // Content
	        $$invalidate(4, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$eventClick*/536870912) {
	      // Onclick handler
	      $$invalidate(5, onclick = createHandler($eventClick));
	    }
	  };
	  return [$theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventColor, eventContent, eventClassNames, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _resBgColor, _resTxtColor, _interaction, createHandler, chunk, event, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	let Event$2 = class Event extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2$3, create_fragment$2$3, safe_not_equal, {
	      chunk: 27
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Event",
	      options,
	      id: create_fragment$2$3.name
	    });
	  }
	  get chunk() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunk(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/list/src/Day.svelte generated by Svelte v4.2.16 */
	const file$1$2 = "packages/list/src/Day.svelte";
	function get_each_context$1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  return child_ctx;
	}

	// (49:0) {#if chunks.length}
	function create_if_block$1$2(ctx) {
	  let div;
	  let h4;
	  let time0;
	  let setContent_action;
	  let t0;
	  let time1;
	  let time1_class_value;
	  let setContent_action_1;
	  let h4_class_value;
	  let t1;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like_dev( /*chunks*/ctx[2]);
	  const get_key = ctx => /*chunk*/ctx[21].event;
	  validate_each_keys(ctx, each_value, get_each_context$1$1, get_key);
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$1$1(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$1$1(key, child_ctx));
	  }
	  const block = {
	    c: function create() {
	      div = element("div");
	      h4 = element("h4");
	      time0 = element("time");
	      t0 = space();
	      time1 = element("time");
	      t1 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(time0, "datetime", /*datetime*/ctx[5]);
	      add_location(time0, file$1$2, 56, 12, 1571);
	      attr_dev(time1, "class", time1_class_value = /*$theme*/ctx[6].daySide);
	      attr_dev(time1, "datetime", /*datetime*/ctx[5]);
	      add_location(time1, file$1$2, 57, 12, 1652);
	      attr_dev(h4, "class", h4_class_value = /*$theme*/ctx[6].dayHead);
	      add_location(h4, file$1$2, 55, 8, 1529);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[6].day + " " + /*$theme*/ctx[6].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[3] ? ' ' + /*$theme*/ctx[6].today : '') + ( /*highlight*/ctx[4] ? ' ' + /*$theme*/ctx[6].highlight : '')));
	      attr_dev(div, "role", "listitem");
	      add_location(div, file$1$2, 49, 4, 1266);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, h4);
	      append_dev(h4, time0);
	      append_dev(h4, t0);
	      append_dev(h4, time1);
	      append_dev(div, t1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }

	      /*div_binding*/
	      ctx[20](div);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, time0, /*$_intlListDay*/ctx[8].format( /*date*/ctx[0]))), action_destroyer(setContent_action_1 = setContent.call(null, time1, /*$_intlListDaySide*/ctx[9].format( /*date*/ctx[0]))), listen_dev(div, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[7].action?.select)) /*$_interaction*/ctx[7].action?.select.apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty & /*datetime*/32) {
	        attr_dev(time0, "datetime", /*datetime*/ctx[5]);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlListDay, date*/257) setContent_action.update.call(null, /*$_intlListDay*/ctx[8].format( /*date*/ctx[0]));
	      if (!current || dirty & /*$theme*/64 && time1_class_value !== (time1_class_value = /*$theme*/ctx[6].daySide)) {
	        attr_dev(time1, "class", time1_class_value);
	      }
	      if (!current || dirty & /*datetime*/32) {
	        attr_dev(time1, "datetime", /*datetime*/ctx[5]);
	      }
	      if (setContent_action_1 && is_function(setContent_action_1.update) && dirty & /*$_intlListDaySide, date*/513) setContent_action_1.update.call(null, /*$_intlListDaySide*/ctx[9].format( /*date*/ctx[0]));
	      if (!current || dirty & /*$theme*/64 && h4_class_value !== (h4_class_value = /*$theme*/ctx[6].dayHead)) {
	        attr_dev(h4, "class", h4_class_value);
	      }
	      if (dirty & /*chunks*/4) {
	        each_value = ensure_array_like_dev( /*chunks*/ctx[2]);
	        group_outros();
	        validate_each_keys(ctx, each_value, get_each_context$1$1, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1$1, null, get_each_context$1$1);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme, date, isToday, highlight*/89 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[6].day + " " + /*$theme*/ctx[6].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[3] ? ' ' + /*$theme*/ctx[6].today : '') + ( /*highlight*/ctx[4] ? ' ' + /*$theme*/ctx[6].highlight : '')))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div_binding*/
	      ctx[20](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1$2.name,
	    type: "if",
	    source: "(49:0) {#if chunks.length}",
	    ctx
	  });
	  return block;
	}

	// (60:8) {#each chunks as chunk (chunk.event)}
	function create_each_block$1$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$2({
	    props: {
	      chunk: /*chunk*/ctx[21]
	    },
	    $$inline: true
	  });
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty & /*chunks*/4) event_changes.chunk = /*chunk*/ctx[21];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1$1.name,
	    type: "each",
	    source: "(60:8) {#each chunks as chunk (chunk.event)}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1$3(ctx) {
	  let if_block_anchor;
	  let current;
	  let if_block = /*chunks*/ctx[2].length && create_if_block$1$2(ctx);
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if ( /*chunks*/ctx[2].length) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*chunks*/4) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$1$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1$3($$self, $$props, $$invalidate) {
	  let $highlightedDates;
	  let $_today;
	  let $_events;
	  let $theme;
	  let $_interaction;
	  let $_intlListDay;
	  let $_intlListDaySide;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Day', slots, []);
	  let {
	    date
	  } = $$props;
	  let {
	    _events,
	    _interaction,
	    _intlListDay,
	    _intlListDaySide,
	    _today,
	    highlightedDates,
	    theme
	  } = getContext('state');
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(19, $_events = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(7, $_interaction = value));
	  validate_store(_intlListDay, '_intlListDay');
	  component_subscribe($$self, _intlListDay, value => $$invalidate(8, $_intlListDay = value));
	  validate_store(_intlListDaySide, '_intlListDaySide');
	  component_subscribe($$self, _intlListDaySide, value => $$invalidate(9, $_intlListDaySide = value));
	  validate_store(_today, '_today');
	  component_subscribe($$self, _today, value => $$invalidate(18, $_today = value));
	  validate_store(highlightedDates, 'highlightedDates');
	  component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(6, $theme = value));
	  let el;
	  let chunks;
	  let isToday, highlight;
	  let datetime;
	  $$self.$$.on_mount.push(function () {
	    if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
	      console.warn("<Day> was created without expected prop 'date'");
	    }
	  });
	  const writable_props = ['date'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Day> was created with unknown prop '${key}'`);
	  });
	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    addDay,
	    cloneDate,
	    createEventChunk,
	    datesEqual,
	    sortEventChunks,
	    eventIntersects,
	    setContent,
	    setPayload,
	    bgEvent,
	    toISOString,
	    Event: Event$2,
	    date,
	    _events,
	    _interaction,
	    _intlListDay,
	    _intlListDaySide,
	    _today,
	    highlightedDates,
	    theme,
	    el,
	    chunks,
	    isToday,
	    highlight,
	    datetime,
	    $highlightedDates,
	    $_today,
	    $_events,
	    $theme,
	    $_interaction,
	    $_intlListDay,
	    $_intlListDaySide
	  });
	  $$self.$inject_state = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('_events' in $$props) $$invalidate(10, _events = $$props._events);
	    if ('_interaction' in $$props) $$invalidate(11, _interaction = $$props._interaction);
	    if ('_intlListDay' in $$props) $$invalidate(12, _intlListDay = $$props._intlListDay);
	    if ('_intlListDaySide' in $$props) $$invalidate(13, _intlListDaySide = $$props._intlListDaySide);
	    if ('_today' in $$props) $$invalidate(14, _today = $$props._today);
	    if ('highlightedDates' in $$props) $$invalidate(15, highlightedDates = $$props.highlightedDates);
	    if ('theme' in $$props) $$invalidate(16, theme = $$props.theme);
	    if ('el' in $$props) $$invalidate(1, el = $$props.el);
	    if ('chunks' in $$props) $$invalidate(2, chunks = $$props.chunks);
	    if ('isToday' in $$props) $$invalidate(3, isToday = $$props.isToday);
	    if ('highlight' in $$props) $$invalidate(4, highlight = $$props.highlight);
	    if ('datetime' in $$props) $$invalidate(5, datetime = $$props.datetime);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*date, $_events, chunks*/524293) {
	      {
	        $$invalidate(2, chunks = []);
	        let start = date;
	        let end = addDay(cloneDate(date));
	        for (let event of $_events) {
	          if (!bgEvent(event.display) && eventIntersects(event, start, end)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        sortEventChunks(chunks);
	      }
	    }
	    if ($$self.$$.dirty & /*date, $_today*/262145) {
	      $$invalidate(3, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty & /*$highlightedDates, date*/131073) {
	      $$invalidate(4, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty & /*date*/1) {
	      $$invalidate(5, datetime = toISOString(date, 10));
	    }
	    if ($$self.$$.dirty & /*el, date*/3) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource: undefined,
	          dayEl: el
	        }));
	      }
	    }
	  };
	  return [date, el, chunks, isToday, highlight, datetime, $theme, $_interaction, $_intlListDay, $_intlListDaySide, _events, _interaction, _intlListDay, _intlListDaySide, _today, highlightedDates, theme, $highlightedDates, $_today, $_events, div_binding];
	}
	let Day$2 = class Day extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1$3, create_fragment$1$3, safe_not_equal, {
	      date: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Day",
	      options,
	      id: create_fragment$1$3.name
	    });
	  }
	  get date() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/list/src/View.svelte generated by Svelte v4.2.16 */

	const file$9 = "packages/list/src/View.svelte";
	function get_each_context$7(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[15] = list[i];
	  return child_ctx;
	}

	// (45:0) {:else}
	function create_else_block$1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$_viewDates*/2) {
	        each_value = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$7(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$7(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block$1.name,
	    type: "else",
	    source: "(45:0) {:else}",
	    ctx
	  });
	  return block;
	}

	// (41:0) {#if noEvents}
	function create_if_block$4(ctx) {
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[3].noEvents);
	      add_location(div, file$9, 43, 4, 1362);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[0])), listen_dev(div, "click", /*handleClick*/ctx[10], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme*/8 && div_class_value !== (div_class_value = /*$theme*/ctx[3].noEvents)) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/1) setContent_action.update.call(null, /*content*/ctx[0]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$4.name,
	    type: "if",
	    source: "(41:0) {#if noEvents}",
	    ctx
	  });
	  return block;
	}

	// (46:4) {#each $_viewDates as date}
	function create_each_block$7(ctx) {
	  let day;
	  let current;
	  day = new Day$2({
	    props: {
	      date: /*date*/ctx[15]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(day.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*$_viewDates*/2) day_changes.date = /*date*/ctx[15];
	      day.$set(day_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$7.name,
	    type: "each",
	    source: "(46:4) {#each $_viewDates as date}",
	    ctx
	  });
	  return block;
	}

	// (40:0) <Body>
	function create_default_slot$3(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block$4, create_else_block$1];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*noEvents*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  const block = {
	    c: function create() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot$3.name,
	    type: "slot",
	    source: "(40:0) <Body>",
	    ctx
	  });
	  return block;
	}
	function create_fragment$a(ctx) {
	  let body;
	  let current;
	  body = new Body$1({
	    props: {
	      $$slots: {
	        default: [create_default_slot$3]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(body.$$.fragment);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref3) {
	      let [dirty] = _ref3;
	      const body_changes = {};
	      if (dirty & /*$$scope, $theme, content, noEvents, $_viewDates*/262159) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(body, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$a.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$a($$self, $$props, $$invalidate) {
	  let $_view;
	  let $noEventsClick;
	  let $noEventsContent;
	  let $_events;
	  let $_viewDates;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('View', slots, []);
	  let {
	    _events,
	    _view,
	    _viewDates,
	    noEventsClick,
	    noEventsContent,
	    theme
	  } = getContext('state');
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(12, $_events = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(13, $_view = value));
	  validate_store(_viewDates, '_viewDates');
	  component_subscribe($$self, _viewDates, value => $$invalidate(1, $_viewDates = value));
	  validate_store(noEventsClick, 'noEventsClick');
	  component_subscribe($$self, noEventsClick, value => $$invalidate(14, $noEventsClick = value));
	  validate_store(noEventsContent, 'noEventsContent');
	  component_subscribe($$self, noEventsContent, value => $$invalidate(11, $noEventsContent = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  let noEvents, content;
	  function handleClick(jsEvent) {
	    if (is_function($noEventsClick)) {
	      $noEventsClick({
	        jsEvent,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<View> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    is_function,
	    Body: Body$1,
	    Day: Day$2,
	    addDay,
	    cloneDate,
	    toViewWithLocalDates,
	    setContent,
	    bgEvent,
	    _events,
	    _view,
	    _viewDates,
	    noEventsClick,
	    noEventsContent,
	    theme,
	    noEvents,
	    content,
	    handleClick,
	    $_view,
	    $noEventsClick,
	    $noEventsContent,
	    $_events,
	    $_viewDates,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('_events' in $$props) $$invalidate(4, _events = $$props._events);
	    if ('_view' in $$props) $$invalidate(5, _view = $$props._view);
	    if ('_viewDates' in $$props) $$invalidate(6, _viewDates = $$props._viewDates);
	    if ('noEventsClick' in $$props) $$invalidate(7, noEventsClick = $$props.noEventsClick);
	    if ('noEventsContent' in $$props) $$invalidate(8, noEventsContent = $$props.noEventsContent);
	    if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
	    if ('noEvents' in $$props) $$invalidate(2, noEvents = $$props.noEvents);
	    if ('content' in $$props) $$invalidate(0, content = $$props.content);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_viewDates, $_events*/4098) {
	      {
	        $$invalidate(2, noEvents = true);
	        if ($_viewDates.length) {
	          let start = $_viewDates[0];
	          let end = addDay(cloneDate($_viewDates[$_viewDates.length - 1]));
	          for (let event of $_events) {
	            if (!bgEvent(event.display) && event.start < end && event.end > start) {
	              $$invalidate(2, noEvents = false);
	              break;
	            }
	          }
	        }
	      }
	    }
	    if ($$self.$$.dirty & /*$noEventsContent, content*/2049) {
	      {
	        $$invalidate(0, content = is_function($noEventsContent) ? $noEventsContent() : $noEventsContent);
	        if (typeof content === 'string') {
	          $$invalidate(0, content = {
	            html: content
	          });
	        }
	      }
	    }
	  };
	  return [content, $_viewDates, noEvents, $theme, _events, _view, _viewDates, noEventsClick, noEventsContent, theme, handleClick, $noEventsContent, $_events];
	}
	let View$2 = class View extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "View",
	      options,
	      id: create_fragment$a.name
	    });
	  }
	};
	var index$4 = {
	  createOptions(options) {
	    // Common options
	    options.buttonText.listDay = 'list';
	    options.buttonText.listWeek = 'list';
	    options.buttonText.listMonth = 'list';
	    options.buttonText.listYear = 'list';
	    options.listDayFormat = {
	      weekday: 'long'
	    };
	    options.listDaySideFormat = {
	      year: 'numeric',
	      month: 'long',
	      day: 'numeric'
	    };
	    options.noEventsClick = undefined; // ec option
	    options.noEventsContent = 'No events';
	    options.theme.daySide = 'ec-day-side';
	    options.theme.eventTag = 'ec-event-tag';
	    options.theme.noEvents = 'ec-no-events';
	    options.view = 'listWeek';
	    options.views.listDay = {
	      buttonText: btnTextDay,
	      component: View$2,
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-list ec-day-view')
	    };
	    options.views.listWeek = {
	      buttonText: btnTextWeek,
	      component: View$2,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-list ec-week-view')
	    };
	    options.views.listMonth = {
	      buttonText: btnTextMonth,
	      component: View$2,
	      duration: {
	        months: 1
	      },
	      theme: themeView('ec-list ec-month-view')
	    };
	    options.views.listYear = {
	      buttonText: btnTextYear,
	      component: View$2,
	      duration: {
	        years: 1
	      },
	      theme: themeView('ec-list ec-year-view')
	    };
	  },
	  createStores(state) {
	    state._intlListDay = intl(state.locale, state.listDayFormat);
	    state._intlListDaySide = intl(state.locale, state.listDaySideFormat);
	  }
	};

	function times(state) {
	  return derived([state._slotTimeLimits, state._intlSlotLabel, state.slotDuration], _ref => {
	    let [$_slotTimeLimits, $_intlSlotLabel, $slotDuration] = _ref;
	    let large = $slotDuration.seconds >= 3600;
	    let times = [];
	    let date = setMidnight(createDate());
	    let end = cloneDate(date);
	    let i = 1;
	    addDuration(date, $_slotTimeLimits.min);
	    addDuration(end, $_slotTimeLimits.max);
	    while (date < end) {
	      times.push([toISOString(date), times.length && (i || large) ? $_intlSlotLabel.format(date) : '']);
	      addDuration(date, $slotDuration);
	      i = 1 - i;
	    }
	    return times;
	  });
	}
	function slotTimeLimits(state) {
	  return derived([state._events, state._viewDates, state.flexibleSlotTimeLimits, state.slotMinTime, state.slotMaxTime], _ref2 => {
	    let [$_events, $_viewDates, $flexibleSlotTimeLimits, $slotMinTime, $slotMaxTime] = _ref2;
	    let min$1 = createDuration($slotMinTime);
	    let max$1 = createDuration($slotMaxTime);
	    if ($flexibleSlotTimeLimits) {
	      let minMin = createDuration(min(min$1.seconds, max(0, max$1.seconds - DAY_IN_SECONDS)));
	      let maxMax = createDuration(max(max$1.seconds, minMin.seconds + DAY_IN_SECONDS));
	      let filter = is_function($flexibleSlotTimeLimits?.eventFilter) ? $flexibleSlotTimeLimits.eventFilter : event => !bgEvent(event.display);
	      loop: for (let date of $_viewDates) {
	        let start = addDuration(cloneDate(date), min$1);
	        let end = addDuration(cloneDate(date), max$1);
	        let minStart = addDuration(cloneDate(date), minMin);
	        let maxEnd = addDuration(cloneDate(date), maxMax);
	        for (let event of $_events) {
	          if (!event.allDay && filter(event) && event.start < maxEnd && event.end > minStart) {
	            if (event.start < start) {
	              let seconds = max((event.start - date) / 1000, minMin.seconds);
	              if (seconds < min$1.seconds) {
	                min$1.seconds = seconds;
	              }
	            }
	            if (event.end > end) {
	              let seconds = min((event.end - date) / 1000, maxMax.seconds);
	              if (seconds > max$1.seconds) {
	                max$1.seconds = seconds;
	              }
	            }
	            if (min$1.seconds === minMin.seconds && max$1.seconds === maxMax.seconds) {
	              break loop;
	            }
	          }
	        }
	      }
	    }
	    return {
	      min: min$1,
	      max: max$1
	    };
	  });
	}
	function groupEventChunks(chunks) {
	  if (!chunks.length) {
	    return;
	  }
	  sortEventChunks(chunks);

	  // Group
	  let group = {
	    columns: [],
	    end: chunks[0].end
	  };
	  for (let chunk of chunks) {
	    let c = 0;
	    if (chunk.start < group.end) {
	      for (; c < group.columns.length; ++c) {
	        if (group.columns[c][group.columns[c].length - 1].end <= chunk.start) {
	          break;
	        }
	      }
	      if (chunk.end > group.end) {
	        group.end = chunk.end;
	      }
	    } else {
	      group = {
	        columns: [],
	        end: chunk.end
	      };
	    }
	    if (group.columns.length < c + 1) {
	      group.columns.push([]);
	    }
	    group.columns[c].push(chunk);
	    chunk.group = group;
	    chunk.column = c;
	  }
	}
	function createAllDayContent(allDayContent) {
	  let text = 'all-day';
	  let content;
	  if (allDayContent) {
	    content = is_function(allDayContent) ? allDayContent({
	      text
	    }) : allDayContent;
	    if (typeof content === 'string') {
	      content = {
	        html: content
	      };
	    }
	  } else {
	    content = {
	      html: text
	    };
	  }
	  return content;
	}

	/* packages/time-grid/src/Section.svelte generated by Svelte v4.2.16 */
	const file$7 = "packages/time-grid/src/Section.svelte";
	const get_lines_slot_changes = dirty => ({});
	const get_lines_slot_context = ctx => ({});
	function get_each_context$5(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[9] = list[i];
	  return child_ctx;
	}

	// (14:4) {#each $_times as time}
	function create_each_block$5(ctx) {
	  let time_1;
	  let time_1_class_value;
	  let time_1_datetime_value;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      time_1 = element("time");
	      attr_dev(time_1, "class", time_1_class_value = /*$theme*/ctx[1].time);
	      attr_dev(time_1, "datetime", time_1_datetime_value = /*time*/ctx[9][0]);
	      add_location(time_1, file$7, 14, 8, 446);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, time_1, anchor);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time_1, /*time*/ctx[9][1]));
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$theme*/2 && time_1_class_value !== (time_1_class_value = /*$theme*/ctx[1].time)) {
	        attr_dev(time_1, "class", time_1_class_value);
	      }
	      if (dirty & /*$_times*/4 && time_1_datetime_value !== (time_1_datetime_value = /*time*/ctx[9][0])) {
	        attr_dev(time_1, "datetime", time_1_datetime_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_times*/4) setContent_action.update.call(null, /*time*/ctx[9][1]);
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(time_1);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$5.name,
	    type: "each",
	    source: "(14:4) {#each $_times as time}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$8(ctx) {
	  let div1;
	  let div0;
	  let div0_class_value;
	  let setContent_action;
	  let t0;
	  let div1_class_value;
	  let t1;
	  let div3;
	  let div2;
	  let div2_class_value;
	  let t2;
	  let div3_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like_dev( /*$_times*/ctx[2]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	  }
	  const lines_slot_template = /*#slots*/ctx[8].lines;
	  const lines_slot = create_slot(lines_slot_template, ctx, /*$$scope*/ctx[7], get_lines_slot_context);
	  const default_slot_template = /*#slots*/ctx[8].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[7], null);
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      t0 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t1 = space();
	      div3 = element("div");
	      div2 = element("div");
	      if (lines_slot) lines_slot.c();
	      t2 = space();
	      if (default_slot) default_slot.c();
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[1].sidebarTitle);
	      add_location(div0, file$7, 12, 4, 340);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[1].sidebar);
	      add_location(div1, file$7, 11, 0, 305);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[1].lines);
	      add_location(div2, file$7, 18, 4, 590);
	      attr_dev(div3, "class", div3_class_value = /*$theme*/ctx[1].days);
	      attr_dev(div3, "role", "row");
	      add_location(div3, file$7, 17, 0, 547);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      append_dev(div1, t0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }
	      insert_dev(target, t1, anchor);
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div2);
	      if (lines_slot) {
	        lines_slot.m(div2, null);
	      }
	      append_dev(div3, t2);
	      if (default_slot) {
	        default_slot.m(div3, null);
	      }
	      current = true;
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, div0, /*allDayText*/ctx[0]));
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref3) {
	      let [dirty] = _ref3;
	      if (!current || dirty & /*$theme*/2 && div0_class_value !== (div0_class_value = /*$theme*/ctx[1].sidebarTitle)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*allDayText*/1) setContent_action.update.call(null, /*allDayText*/ctx[0]);
	      if (dirty & /*$theme, $_times*/6) {
	        each_value = ensure_array_like_dev( /*$_times*/ctx[2]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$5(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$5(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(div1, null);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	      if (!current || dirty & /*$theme*/2 && div1_class_value !== (div1_class_value = /*$theme*/ctx[1].sidebar)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (lines_slot) {
	        if (lines_slot.p && (!current || dirty & /*$$scope*/128)) {
	          update_slot_base(lines_slot, lines_slot_template, ctx, /*$$scope*/ctx[7], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[7]) : get_slot_changes(lines_slot_template, /*$$scope*/ctx[7], dirty, get_lines_slot_changes), get_lines_slot_context);
	        }
	      }
	      if (!current || dirty & /*$theme*/2 && div2_class_value !== (div2_class_value = /*$theme*/ctx[1].lines)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/128)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[7], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[7]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[7], dirty, null), null);
	        }
	      }
	      if (!current || dirty & /*$theme*/2 && div3_class_value !== (div3_class_value = /*$theme*/ctx[1].days)) {
	        attr_dev(div3, "class", div3_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(lines_slot, local);
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(lines_slot, local);
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	        detach_dev(t1);
	        detach_dev(div3);
	      }
	      destroy_each(each_blocks, detaching);
	      if (lines_slot) lines_slot.d(detaching);
	      if (default_slot) default_slot.d(detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$8.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$8($$self, $$props, $$invalidate) {
	  let $allDayContent;
	  let $theme;
	  let $_times;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Section', slots, ['lines', 'default']);
	  let {
	    allDayContent,
	    theme,
	    _times
	  } = getContext('state');
	  validate_store(allDayContent, 'allDayContent');
	  component_subscribe($$self, allDayContent, value => $$invalidate(6, $allDayContent = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  validate_store(_times, '_times');
	  component_subscribe($$self, _times, value => $$invalidate(2, $_times = value));
	  let allDayText;
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Section> was created with unknown prop '${key}'`);
	  });
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    setContent,
	    createAllDayContent,
	    allDayContent,
	    theme,
	    _times,
	    allDayText,
	    $allDayContent,
	    $theme,
	    $_times
	  });
	  $$self.$inject_state = $$props => {
	    if ('allDayContent' in $$props) $$invalidate(3, allDayContent = $$props.allDayContent);
	    if ('theme' in $$props) $$invalidate(4, theme = $$props.theme);
	    if ('_times' in $$props) $$invalidate(5, _times = $$props._times);
	    if ('allDayText' in $$props) $$invalidate(0, allDayText = $$props.allDayText);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$allDayContent*/64) {
	      $$invalidate(0, allDayText = createAllDayContent($allDayContent));
	    }
	  };
	  return [allDayText, $theme, $_times, allDayContent, theme, _times, $allDayContent, $$scope, slots];
	}
	class Section extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Section",
	      options,
	      id: create_fragment$8.name
	    });
	  }
	}

	/* packages/time-grid/src/Body.svelte generated by Svelte v4.2.16 */
	const file$6 = "packages/time-grid/src/Body.svelte";
	function get_each_context$4(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[24] = list[i];
	  return child_ctx;
	}

	// (35:8) <Section>
	function create_default_slot$1(ctx) {
	  let current;
	  const default_slot_template = /*#slots*/ctx[16].default;
	  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[18], null);
	  const block = {
	    c: function create() {
	      if (default_slot) default_slot.c();
	    },
	    m: function mount(target, anchor) {
	      if (default_slot) {
	        default_slot.m(target, anchor);
	      }
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty & /*$$scope*/262144)) {
	          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[18], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[18]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[18], dirty, null), null);
	        }
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (default_slot) default_slot.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot$1.name,
	    type: "slot",
	    source: "(35:8) <Section>",
	    ctx
	  });
	  return block;
	}

	// (37:16) {#each lines as line}
	function create_each_block$4(ctx) {
	  let div;
	  let div_class_value;
	  const block = {
	    c: function create() {
	      div = element("div");
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[3].line);
	      add_location(div, file$6, 37, 20, 1040);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme*/8 && div_class_value !== (div_class_value = /*$theme*/ctx[3].line)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$4.name,
	    type: "each",
	    source: "(37:16) {#each lines as line}",
	    ctx
	  });
	  return block;
	}

	// (36:12) <svelte:fragment slot="lines">
	function create_lines_slot(ctx) {
	  let each_1_anchor;
	  let each_value = ensure_array_like_dev( /*lines*/ctx[2]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	  }
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme, lines*/12) {
	        each_value = ensure_array_like_dev( /*lines*/ctx[2]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$4(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block$4(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value.length;
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_lines_slot.name,
	    type: "slot",
	    source: "(36:12) <svelte:fragment slot=\\\"lines\\\">",
	    ctx
	  });
	  return block;
	}
	function create_fragment$7(ctx) {
	  let div1;
	  let div0;
	  let section;
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        lines: [create_lines_slot],
	        default: [create_default_slot$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      div0 = element("div");
	      create_component(section.$$.fragment);
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[3].content);
	      add_location(div0, file$6, 33, 4, 890);
	      attr_dev(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[3].body + ( /*compact*/ctx[1] ? ' ' + /*$theme*/ctx[3].compact : '')));
	      add_location(div1, file$6, 29, 0, 797);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      mount_component(section, div0, null);
	      /*div1_binding*/
	      ctx[17](div1);
	      current = true;
	    },
	    p: function update(ctx, _ref4) {
	      let [dirty] = _ref4;
	      const section_changes = {};
	      if (dirty & /*$$scope, lines, $theme*/262156) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/8 && div0_class_value !== (div0_class_value = /*$theme*/ctx[3].content)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, compact*/10 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[3].body + ( /*compact*/ctx[1] ? ' ' + /*$theme*/ctx[3].compact : '')))) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	      }
	      destroy_component(section);
	      /*div1_binding*/
	      ctx[17](null);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$7.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$7($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $slotDuration;
	  let $scrollTime;
	  let $_viewDates;
	  let $_slotTimeLimits;
	  let $_times;
	  let $_bodyEl;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Body', slots, ['default']);
	  let {
	    _bodyEl,
	    _viewDates,
	    _slotTimeLimits,
	    _times,
	    scrollTime,
	    slotDuration,
	    slotHeight,
	    theme
	  } = getContext('state');
	  validate_store(_bodyEl, '_bodyEl');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(22, $_bodyEl = value));
	  validate_store(_viewDates, '_viewDates');
	  component_subscribe($$self, _viewDates, value => $$invalidate(13, $_viewDates = value));
	  validate_store(_slotTimeLimits, '_slotTimeLimits');
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(14, $_slotTimeLimits = value));
	  validate_store(_times, '_times');
	  component_subscribe($$self, _times, value => $$invalidate(15, $_times = value));
	  validate_store(scrollTime, 'scrollTime');
	  component_subscribe($$self, scrollTime, value => $$invalidate(21, $scrollTime = value));
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(12, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(20, $slotHeight = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	  let el;
	  let compact;
	  let lines = [];
	  let timeLimitMin;
	  function scrollToTime() {
	    $$invalidate(0, el.scrollTop = (($scrollTime.seconds - timeLimitMin) / $slotDuration.seconds - 0.5) * $slotHeight, el);
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Body> was created with unknown prop '${key}'`);
	  });
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(0, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    Section,
	    _bodyEl,
	    _viewDates,
	    _slotTimeLimits,
	    _times,
	    scrollTime,
	    slotDuration,
	    slotHeight,
	    theme,
	    el,
	    compact,
	    lines,
	    timeLimitMin,
	    scrollToTime,
	    $slotHeight,
	    $slotDuration,
	    $scrollTime,
	    $_viewDates,
	    $_slotTimeLimits,
	    $_times,
	    $_bodyEl,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('_bodyEl' in $$props) $$invalidate(4, _bodyEl = $$props._bodyEl);
	    if ('_viewDates' in $$props) $$invalidate(5, _viewDates = $$props._viewDates);
	    if ('_slotTimeLimits' in $$props) $$invalidate(6, _slotTimeLimits = $$props._slotTimeLimits);
	    if ('_times' in $$props) $$invalidate(7, _times = $$props._times);
	    if ('scrollTime' in $$props) $$invalidate(8, scrollTime = $$props.scrollTime);
	    if ('slotDuration' in $$props) $$invalidate(9, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(10, slotHeight = $$props.slotHeight);
	    if ('theme' in $$props) $$invalidate(11, theme = $$props.theme);
	    if ('el' in $$props) $$invalidate(0, el = $$props.el);
	    if ('compact' in $$props) $$invalidate(1, compact = $$props.compact);
	    if ('lines' in $$props) $$invalidate(2, lines = $$props.lines);
	    if ('timeLimitMin' in $$props) timeLimitMin = $$props.timeLimitMin;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*el*/1) {
	      set_store_value(_bodyEl, $_bodyEl = el, $_bodyEl);
	    }
	    if ($$self.$$.dirty & /*$slotDuration, $_times, $_slotTimeLimits*/53248) {
	      {
	        $$invalidate(1, compact = $slotDuration.seconds >= 3600);
	        $$invalidate(2, lines.length = $_times.length, lines);

	        // Use intermediate variable so that changes in _slotTimeLimits do not trigger setting the el.scrollTop
	        timeLimitMin = $_slotTimeLimits.min.seconds;
	      }
	    }
	    if ($$self.$$.dirty & /*el, $_viewDates*/8193) {
	      if (el && $_viewDates) {
	        scrollToTime();
	      }
	    }
	  };
	  return [el, compact, lines, $theme, _bodyEl, _viewDates, _slotTimeLimits, _times, scrollTime, slotDuration, slotHeight, theme, $slotDuration, $_viewDates, $_slotTimeLimits, $_times, slots, div1_binding, $$scope];
	}
	class Body extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Body",
	      options,
	      id: create_fragment$7.name
	    });
	  }
	}

	/* packages/time-grid/src/Event.svelte generated by Svelte v4.2.16 */

	const file$5 = "packages/time-grid/src/Event.svelte";
	function create_fragment$6(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[10].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      },
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	    });
	  }
	  const block = {
	    c: function create() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      add_location(div, file$5, 124, 4, 4269);
	      attr_dev(article, "class", /*classes*/ctx[4]);
	      attr_dev(article, "style", /*style*/ctx[5]);
	      attr_dev(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	      add_location(article, file$5, 112, 0, 3825);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, article, anchor);
	      append_dev(article, div);
	      append_dev(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[53](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen_dev(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[33]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]))) /*createHandler*/ctx[33]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[33]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[33]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "pointerdown", function () {
	          if (is_function(!bgEvent( /*display*/ctx[1]) && !helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10]))) (!bgEvent( /*display*/ctx[1]) && !helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10])).apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/1024 && switch_value !== (switch_value = /*$_interaction*/ctx[10].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[34]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr_dev(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr_dev(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr_dev(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr_dev(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[53](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$6.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$6($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventAllUpdated;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $slotEventOverlap;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let $slotDuration;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Event', slots, []);
	  let {
	    date
	  } = $$props;
	  let {
	    chunk
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClick,
	    eventDidMount,
	    eventClassNames,
	    eventMouseEnter,
	    eventMouseLeave,
	    slotEventOverlap,
	    slotDuration,
	    slotHeight,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _slotTimeLimits,
	    _tasks
	  } = getContext('state');
	  validate_store(displayEventEnd, 'displayEventEnd');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(41, $displayEventEnd = value));
	  validate_store(eventAllUpdated, 'eventAllUpdated');
	  component_subscribe($$self, eventAllUpdated, value => $$invalidate(55, $eventAllUpdated = value));
	  validate_store(eventBackgroundColor, 'eventBackgroundColor');
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(48, $eventBackgroundColor = value));
	  validate_store(eventTextColor, 'eventTextColor');
	  component_subscribe($$self, eventTextColor, value => $$invalidate(45, $eventTextColor = value));
	  validate_store(eventColor, 'eventColor');
	  component_subscribe($$self, eventColor, value => $$invalidate(47, $eventColor = value));
	  validate_store(eventContent, 'eventContent');
	  component_subscribe($$self, eventContent, value => $$invalidate(40, $eventContent = value));
	  validate_store(eventClick, 'eventClick');
	  component_subscribe($$self, eventClick, value => $$invalidate(37, $eventClick = value));
	  validate_store(eventDidMount, 'eventDidMount');
	  component_subscribe($$self, eventDidMount, value => $$invalidate(56, $eventDidMount = value));
	  validate_store(eventClassNames, 'eventClassNames');
	  component_subscribe($$self, eventClassNames, value => $$invalidate(42, $eventClassNames = value));
	  validate_store(eventMouseEnter, 'eventMouseEnter');
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(8, $eventMouseEnter = value));
	  validate_store(eventMouseLeave, 'eventMouseLeave');
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(9, $eventMouseLeave = value));
	  validate_store(slotEventOverlap, 'slotEventOverlap');
	  component_subscribe($$self, slotEventOverlap, value => $$invalidate(44, $slotEventOverlap = value));
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(52, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(50, $slotHeight = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(38, $_view = value));
	  validate_store(_intlEventTime, '_intlEventTime');
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(39, $_intlEventTime = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(10, $_interaction = value));
	  validate_store(_iClasses, '_iClasses');
	  component_subscribe($$self, _iClasses, value => $$invalidate(43, $_iClasses = value));
	  validate_store(_resBgColor, '_resBgColor');
	  component_subscribe($$self, _resBgColor, value => $$invalidate(49, $_resBgColor = value));
	  validate_store(_resTxtColor, '_resTxtColor');
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(46, $_resTxtColor = value));
	  validate_store(_slotTimeLimits, '_slotTimeLimits');
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(51, $_slotTimeLimits = value));
	  let el;
	  let event;
	  let display;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (is_function($eventAllUpdated) && !helperEvent(display)) {
	      task(() => $eventAllUpdated({
	        view: toViewWithLocalDates($_view)
	      }), 'eau', _tasks);
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => interaction.action.drag(event, jsEvent, resize) : undefined;
	  }
	  $$self.$$.on_mount.push(function () {
	    if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
	      console.warn("<Event> was created without expected prop 'date'");
	    }
	    if (chunk === undefined && !('chunk' in $$props || $$self.$$.bound[$$self.$$.props['chunk']])) {
	      console.warn("<Event> was created without expected prop 'chunk'");
	    }
	  });
	  const writable_props = ['date', 'chunk'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Event> was created with unknown prop '${key}'`);
	  });
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(35, date = $$props.date);
	    if ('chunk' in $$props) $$invalidate(36, chunk = $$props.chunk);
	  };
	  $$self.$capture_state = () => ({
	    afterUpdate,
	    getContext,
	    onMount,
	    is_function,
	    createEventContent,
	    createEventClasses,
	    toEventWithLocalDates,
	    toViewWithLocalDates,
	    setContent,
	    bgEvent,
	    helperEvent,
	    ghostEvent,
	    keyEnter,
	    task,
	    date,
	    chunk,
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventColor,
	    eventContent,
	    eventClick,
	    eventDidMount,
	    eventClassNames,
	    eventMouseEnter,
	    eventMouseLeave,
	    slotEventOverlap,
	    slotDuration,
	    slotHeight,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _slotTimeLimits,
	    _tasks,
	    el,
	    event,
	    display,
	    classes,
	    style,
	    content,
	    timeText,
	    onclick,
	    createHandler,
	    createDragHandler,
	    $eventClick,
	    $_view,
	    $eventAllUpdated,
	    $eventDidMount,
	    $_intlEventTime,
	    $theme,
	    $eventContent,
	    $displayEventEnd,
	    $eventClassNames,
	    $_iClasses,
	    $slotEventOverlap,
	    $eventTextColor,
	    $_resTxtColor,
	    $eventColor,
	    $eventBackgroundColor,
	    $_resBgColor,
	    $slotHeight,
	    $_slotTimeLimits,
	    $slotDuration,
	    $eventMouseEnter,
	    $eventMouseLeave,
	    $_interaction
	  });
	  $$self.$inject_state = $$props => {
	    if ('date' in $$props) $$invalidate(35, date = $$props.date);
	    if ('chunk' in $$props) $$invalidate(36, chunk = $$props.chunk);
	    if ('displayEventEnd' in $$props) $$invalidate(11, displayEventEnd = $$props.displayEventEnd);
	    if ('eventAllUpdated' in $$props) $$invalidate(12, eventAllUpdated = $$props.eventAllUpdated);
	    if ('eventBackgroundColor' in $$props) $$invalidate(13, eventBackgroundColor = $$props.eventBackgroundColor);
	    if ('eventTextColor' in $$props) $$invalidate(14, eventTextColor = $$props.eventTextColor);
	    if ('eventColor' in $$props) $$invalidate(15, eventColor = $$props.eventColor);
	    if ('eventContent' in $$props) $$invalidate(16, eventContent = $$props.eventContent);
	    if ('eventClick' in $$props) $$invalidate(17, eventClick = $$props.eventClick);
	    if ('eventDidMount' in $$props) $$invalidate(18, eventDidMount = $$props.eventDidMount);
	    if ('eventClassNames' in $$props) $$invalidate(19, eventClassNames = $$props.eventClassNames);
	    if ('eventMouseEnter' in $$props) $$invalidate(20, eventMouseEnter = $$props.eventMouseEnter);
	    if ('eventMouseLeave' in $$props) $$invalidate(21, eventMouseLeave = $$props.eventMouseLeave);
	    if ('slotEventOverlap' in $$props) $$invalidate(22, slotEventOverlap = $$props.slotEventOverlap);
	    if ('slotDuration' in $$props) $$invalidate(23, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(24, slotHeight = $$props.slotHeight);
	    if ('theme' in $$props) $$invalidate(25, theme = $$props.theme);
	    if ('_view' in $$props) $$invalidate(26, _view = $$props._view);
	    if ('_intlEventTime' in $$props) $$invalidate(27, _intlEventTime = $$props._intlEventTime);
	    if ('_interaction' in $$props) $$invalidate(28, _interaction = $$props._interaction);
	    if ('_iClasses' in $$props) $$invalidate(29, _iClasses = $$props._iClasses);
	    if ('_resBgColor' in $$props) $$invalidate(30, _resBgColor = $$props._resBgColor);
	    if ('_resTxtColor' in $$props) $$invalidate(31, _resTxtColor = $$props._resTxtColor);
	    if ('_slotTimeLimits' in $$props) $$invalidate(32, _slotTimeLimits = $$props._slotTimeLimits);
	    if ('_tasks' in $$props) _tasks = $$props._tasks;
	    if ('el' in $$props) $$invalidate(3, el = $$props.el);
	    if ('event' in $$props) $$invalidate(0, event = $$props.event);
	    if ('display' in $$props) $$invalidate(1, display = $$props.display);
	    if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
	    if ('style' in $$props) $$invalidate(5, style = $$props.style);
	    if ('content' in $$props) $$invalidate(6, content = $$props.content);
	    if ('timeText' in $$props) timeText = $$props.timeText;
	    if ('onclick' in $$props) $$invalidate(7, onclick = $$props.onclick);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/32) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, display, $theme*/39 | $$self.$$.dirty[1] & /*$slotDuration, $_slotTimeLimits, chunk, date, $slotHeight, $_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, $slotEventOverlap, $_iClasses, $eventClassNames, $_view*/4192432) {
	      {
	        $$invalidate(1, display = event.display);

	        // Style
	        let step = $slotDuration.seconds / 60;
	        let offset = $_slotTimeLimits.min.seconds / 60;
	        let start = (chunk.start - date) / 1000 / 60;
	        let end = (chunk.end - date) / 1000 / 60;
	        let top = (start - offset) / step * $slotHeight;
	        let height = (end - start) / step * $slotHeight;
	        let maxHeight = ($_slotTimeLimits.max.seconds / 60 - start) / step * $slotHeight;
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `top:${top}px;` + `min-height:${height}px;` + `height:${height}px;` + `max-height:${maxHeight}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        if (!bgEvent(display) && !helperEvent(display) || ghostEvent(display)) {
	          $$invalidate(5, style += `z-index:${chunk.column + 1};` + `left:${100 / chunk.group.columns.length * chunk.column}%;` + `width:${100 / chunk.group.columns.length * ($slotEventOverlap ? 0.5 * (1 + chunk.group.columns.length - chunk.column) : 1)}%;`);
	        }

	        // Class
	        $$invalidate(4, classes = [bgEvent(display) ? $theme.bgEvent : $theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/1952) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/64) {
	      // Onclick handler
	      $$invalidate(7, onclick = !bgEvent(display) && createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventColor, eventContent, eventClick, eventDidMount, eventClassNames, eventMouseEnter, eventMouseLeave, slotEventOverlap, slotDuration, slotHeight, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, _slotTimeLimits, createHandler, createDragHandler, date, chunk, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $slotEventOverlap, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, $slotHeight, $_slotTimeLimits, $slotDuration, article_binding];
	}
	let Event$1 = class Event extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
	      date: 35,
	      chunk: 36
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Event",
	      options,
	      id: create_fragment$6.name
	    });
	  }
	  get date() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get chunk() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunk(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/time-grid/src/NowIndicator.svelte generated by Svelte v4.2.16 */
	const file$4 = "packages/time-grid/src/NowIndicator.svelte";
	function create_fragment$5(ctx) {
	  let div;
	  let div_class_value;
	  const block = {
	    c: function create() {
	      div = element("div");
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[1].nowIndicator);
	      set_style(div, "top", /*top*/ctx[0] + "px");
	      add_location(div, file$4, 17, 0, 424);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	    },
	    p: function update(ctx, _ref5) {
	      let [dirty] = _ref5;
	      if (dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].nowIndicator)) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (dirty & /*top*/1) {
	        set_style(div, "top", /*top*/ctx[0] + "px");
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$5.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$5($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let $slotDuration;
	  let $_today;
	  let $_now;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('NowIndicator', slots, []);
	  let {
	    slotDuration,
	    slotHeight,
	    theme,
	    _now,
	    _today,
	    _slotTimeLimits
	  } = getContext('state');
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(11, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(9, $slotHeight = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  validate_store(_now, '_now');
	  component_subscribe($$self, _now, value => $$invalidate(13, $_now = value));
	  validate_store(_today, '_today');
	  component_subscribe($$self, _today, value => $$invalidate(12, $_today = value));
	  validate_store(_slotTimeLimits, '_slotTimeLimits');
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(10, $_slotTimeLimits = value));
	  let start;
	  let top = 0;
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NowIndicator> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    slotDuration,
	    slotHeight,
	    theme,
	    _now,
	    _today,
	    _slotTimeLimits,
	    start,
	    top,
	    $slotHeight,
	    $_slotTimeLimits,
	    $slotDuration,
	    $_today,
	    $_now,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('slotDuration' in $$props) $$invalidate(2, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(3, slotHeight = $$props.slotHeight);
	    if ('theme' in $$props) $$invalidate(4, theme = $$props.theme);
	    if ('_now' in $$props) $$invalidate(5, _now = $$props._now);
	    if ('_today' in $$props) $$invalidate(6, _today = $$props._today);
	    if ('_slotTimeLimits' in $$props) $$invalidate(7, _slotTimeLimits = $$props._slotTimeLimits);
	    if ('start' in $$props) $$invalidate(8, start = $$props.start);
	    if ('top' in $$props) $$invalidate(0, top = $$props.top);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_now, $_today*/12288) {
	      $$invalidate(8, start = ($_now - $_today) / 1000 / 60);
	    }
	    if ($$self.$$.dirty & /*$slotDuration, $_slotTimeLimits, start, $slotHeight*/3840) {
	      {
	        // Style
	        let step = $slotDuration.seconds / 60;
	        let offset = $_slotTimeLimits.min.seconds / 60;
	        $$invalidate(0, top = (start - offset) / step * $slotHeight);
	      }
	    }
	  };
	  return [top, $theme, slotDuration, slotHeight, theme, _now, _today, _slotTimeLimits, start, $slotHeight, $_slotTimeLimits, $slotDuration, $_today, $_now];
	}
	class NowIndicator extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "NowIndicator",
	      options,
	      id: create_fragment$5.name
	    });
	  }
	}

	/* packages/time-grid/src/Day.svelte generated by Svelte v4.2.16 */
	const file$3 = "packages/time-grid/src/Day.svelte";
	function get_each_context$3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[33] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[33] = list[i];
	  return child_ctx;
	}

	// (90:8) {#each bgChunks as chunk (chunk.event)}
	function create_each_block_1$1(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*chunk*/ctx[33]
	    },
	    $$inline: true
	  });
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*bgChunks*/8) event_changes.chunk = /*chunk*/ctx[33];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1$1.name,
	    type: "each",
	    source: "(90:8) {#each bgChunks as chunk (chunk.event)}",
	    ctx
	  });
	  return block;
	}

	// (96:8) {#if iChunks[1]}
	function create_if_block_2$1(ctx) {
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*iChunks*/ctx[4][1]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(event.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*iChunks*/16) event_changes.chunk = /*iChunks*/ctx[4][1];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2$1.name,
	    type: "if",
	    source: "(96:8) {#if iChunks[1]}",
	    ctx
	  });
	  return block;
	}

	// (99:8) {#each chunks as chunk (chunk.event)}
	function create_each_block$3(key_1, ctx) {
	  let first;
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*chunk*/ctx[33]
	    },
	    $$inline: true
	  });
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*chunks*/4) event_changes.chunk = /*chunk*/ctx[33];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$3.name,
	    type: "each",
	    source: "(99:8) {#each chunks as chunk (chunk.event)}",
	    ctx
	  });
	  return block;
	}

	// (103:8) {#if iChunks[0] && !iChunks[0].event.allDay}
	function create_if_block_1$1(ctx) {
	  let event;
	  let current;
	  event = new Event$1({
	    props: {
	      date: /*date*/ctx[0],
	      chunk: /*iChunks*/ctx[4][0]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(event.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const event_changes = {};
	      if (dirty[0] & /*date*/1) event_changes.date = /*date*/ctx[0];
	      if (dirty[0] & /*iChunks*/16) event_changes.chunk = /*iChunks*/ctx[4][0];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1$1.name,
	    type: "if",
	    source: "(103:8) {#if iChunks[0] && !iChunks[0].event.allDay}",
	    ctx
	  });
	  return block;
	}

	// (109:8) {#if $nowIndicator && isToday}
	function create_if_block$2$1(ctx) {
	  let nowindicator;
	  let current;
	  nowindicator = new NowIndicator({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(nowindicator.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(nowindicator, target, anchor);
	      current = true;
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(nowindicator.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(nowindicator.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(nowindicator, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$2$1.name,
	    type: "if",
	    source: "(109:8) {#if $nowIndicator && isToday}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$4$1(ctx) {
	  let div3;
	  let div0;
	  let each_blocks_1 = [];
	  let each0_lookup = new Map();
	  let div0_class_value;
	  let t0;
	  let div1;
	  let t1;
	  let each_blocks = [];
	  let each1_lookup = new Map();
	  let t2;
	  let div1_class_value;
	  let t3;
	  let div2;
	  let div2_class_value;
	  let div3_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value_1 = ensure_array_like_dev( /*bgChunks*/ctx[3]);
	  const get_key = ctx => /*chunk*/ctx[33].event;
	  validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
	    let key = get_key(child_ctx);
	    each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$1(key, child_ctx));
	  }
	  let if_block0 = /*iChunks*/ctx[4][1] && create_if_block_2$1(ctx);
	  let each_value = ensure_array_like_dev( /*chunks*/ctx[2]);
	  const get_key_1 = ctx => /*chunk*/ctx[33].event;
	  validate_each_keys(ctx, each_value, get_each_context$3, get_key_1);
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$3(ctx, each_value, i);
	    let key = get_key_1(child_ctx);
	    each1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	  }
	  let if_block1 = /*iChunks*/ctx[4][0] && ! /*iChunks*/ctx[4][0].event.allDay && create_if_block_1$1(ctx);
	  let if_block2 = /*$nowIndicator*/ctx[9] && /*isToday*/ctx[5] && create_if_block$2$1(ctx);
	  const block = {
	    c: function create() {
	      div3 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        each_blocks_1[i].c();
	      }
	      t0 = space();
	      div1 = element("div");
	      if (if_block0) if_block0.c();
	      t1 = space();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t2 = space();
	      if (if_block1) if_block1.c();
	      t3 = space();
	      div2 = element("div");
	      if (if_block2) if_block2.c();
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[7].bgEvents);
	      add_location(div0, file$3, 88, 4, 2611);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[7].events);
	      add_location(div1, file$3, 93, 4, 2758);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[7].extra);
	      add_location(div2, file$3, 106, 4, 3165);
	      attr_dev(div3, "class", div3_class_value = "" + ( /*$theme*/ctx[7].day + " " + /*$theme*/ctx[7].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[7].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[7].highlight : '')));
	      attr_dev(div3, "role", "cell");
	      add_location(div3, file$3, 80, 0, 2262);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div3, anchor);
	      append_dev(div3, div0);
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        if (each_blocks_1[i]) {
	          each_blocks_1[i].m(div0, null);
	        }
	      }
	      append_dev(div3, t0);
	      append_dev(div3, div1);
	      if (if_block0) if_block0.m(div1, null);
	      append_dev(div1, t1);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div1, null);
	        }
	      }
	      append_dev(div1, t2);
	      if (if_block1) if_block1.m(div1, null);
	      append_dev(div3, t3);
	      append_dev(div3, div2);
	      if (if_block2) if_block2.m(div2, null);
	      /*div3_binding*/
	      ctx[29](div3);
	      current = true;
	      if (!mounted) {
	        dispose = [listen_dev(div3, "pointerenter", function () {
	          if (is_function( /*createPointerEnterHandler*/ctx[20]( /*$_interaction*/ctx[8]))) /*createPointerEnterHandler*/ctx[20]( /*$_interaction*/ctx[8]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(div3, "pointerleave", function () {
	          if (is_function( /*$_interaction*/ctx[8].pointer?.leave)) /*$_interaction*/ctx[8].pointer?.leave.apply(this, arguments);
	        }, false, false, false, false), listen_dev(div3, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[8].action?.select)) /*$_interaction*/ctx[8].action?.select.apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*date, bgChunks*/9) {
	        each_value_1 = ensure_array_like_dev( /*bgChunks*/ctx[3]);
	        group_outros();
	        validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
	        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div0_class_value !== (div0_class_value = /*$theme*/ctx[7].bgEvents)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if ( /*iChunks*/ctx[4][1]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	          if (dirty[0] & /*iChunks*/16) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_2$1(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div1, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, () => {
	          if_block0 = null;
	        });
	        check_outros();
	      }
	      if (dirty[0] & /*date, chunks*/5) {
	        each_value = ensure_array_like_dev( /*chunks*/ctx[2]);
	        group_outros();
	        validate_each_keys(ctx, each_value, get_each_context$3, get_key_1);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, outro_and_destroy_block, create_each_block$3, t2, get_each_context$3);
	        check_outros();
	      }
	      if ( /*iChunks*/ctx[4][0] && ! /*iChunks*/ctx[4][0].event.allDay) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*iChunks*/16) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_1$1(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div1, null);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div1_class_value !== (div1_class_value = /*$theme*/ctx[7].events)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if ( /*$nowIndicator*/ctx[9] && /*isToday*/ctx[5]) {
	        if (if_block2) {
	          if (dirty[0] & /*$nowIndicator, isToday*/544) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block$2$1(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div2, null);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, () => {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/128 && div2_class_value !== (div2_class_value = /*$theme*/ctx[7].extra)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	      if (!current || dirty[0] & /*$theme, date, isToday, highlight*/225 && div3_class_value !== (div3_class_value = "" + ( /*$theme*/ctx[7].day + " " + /*$theme*/ctx[7].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[7].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[7].highlight : '')))) {
	        attr_dev(div3, "class", div3_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks_1[i]);
	      }
	      transition_in(if_block0);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      transition_in(if_block1);
	      transition_in(if_block2);
	      current = true;
	    },
	    o: function outro(local) {
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        transition_out(each_blocks_1[i]);
	      }
	      transition_out(if_block0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      transition_out(if_block1);
	      transition_out(if_block2);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div3);
	      }
	      for (let i = 0; i < each_blocks_1.length; i += 1) {
	        each_blocks_1[i].d();
	      }
	      if (if_block0) if_block0.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      /*div3_binding*/
	      ctx[29](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$4$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$4$1($$self, $$props, $$invalidate) {
	  let $slotHeight;
	  let $slotDuration;
	  let $_slotTimeLimits;
	  let $highlightedDates;
	  let $_today;
	  let $_iEvents;
	  let $_events;
	  let $theme;
	  let $_interaction;
	  let $nowIndicator;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Day', slots, []);
	  let {
	    date
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    highlightedDates,
	    nowIndicator,
	    slotDuration,
	    slotHeight,
	    theme,
	    _interaction,
	    _today,
	    _slotTimeLimits
	  } = getContext('state');
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(28, $_events = value));
	  validate_store(_iEvents, '_iEvents');
	  component_subscribe($$self, _iEvents, value => $$invalidate(27, $_iEvents = value));
	  validate_store(highlightedDates, 'highlightedDates');
	  component_subscribe($$self, highlightedDates, value => $$invalidate(25, $highlightedDates = value));
	  validate_store(nowIndicator, 'nowIndicator');
	  component_subscribe($$self, nowIndicator, value => $$invalidate(9, $nowIndicator = value));
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(31, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(30, $slotHeight = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(7, $theme = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(8, $_interaction = value));
	  validate_store(_today, '_today');
	  component_subscribe($$self, _today, value => $$invalidate(26, $_today = value));
	  validate_store(_slotTimeLimits, '_slotTimeLimits');
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(24, $_slotTimeLimits = value));
	  let el;
	  let chunks,
	    bgChunks,
	    iChunks = [];
	  let isToday, highlight;
	  let start, end;
	  function dateFromPoint(y) {
	    y -= rect(el).top;
	    return {
	      allDay: false,
	      date: addDuration(addDuration(cloneDate(date), $_slotTimeLimits.min), $slotDuration, floor(y / $slotHeight)),
	      resource,
	      dayEl: el
	    };
	  }
	  function createPointerEnterHandler(interaction) {
	    return interaction.pointer ? jsEvent => interaction.pointer.enterTimeGrid(date, el, jsEvent, resource) : undefined;
	  }
	  $$self.$$.on_mount.push(function () {
	    if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
	      console.warn("<Day> was created without expected prop 'date'");
	    }
	  });
	  const writable_props = ['date', 'resource'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Day> was created with unknown prop '${key}'`);
	  });
	  function div3_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(1, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('resource' in $$props) $$invalidate(21, resource = $$props.resource);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    cloneDate,
	    addDuration,
	    datesEqual,
	    createEventChunk,
	    eventIntersects,
	    floor,
	    rect,
	    setPayload,
	    groupEventChunks,
	    Event: Event$1,
	    NowIndicator,
	    date,
	    resource,
	    _events,
	    _iEvents,
	    highlightedDates,
	    nowIndicator,
	    slotDuration,
	    slotHeight,
	    theme,
	    _interaction,
	    _today,
	    _slotTimeLimits,
	    el,
	    chunks,
	    bgChunks,
	    iChunks,
	    isToday,
	    highlight,
	    start,
	    end,
	    dateFromPoint,
	    createPointerEnterHandler,
	    $slotHeight,
	    $slotDuration,
	    $_slotTimeLimits,
	    $highlightedDates,
	    $_today,
	    $_iEvents,
	    $_events,
	    $theme,
	    $_interaction,
	    $nowIndicator
	  });
	  $$self.$inject_state = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('resource' in $$props) $$invalidate(21, resource = $$props.resource);
	    if ('_events' in $$props) $$invalidate(10, _events = $$props._events);
	    if ('_iEvents' in $$props) $$invalidate(11, _iEvents = $$props._iEvents);
	    if ('highlightedDates' in $$props) $$invalidate(12, highlightedDates = $$props.highlightedDates);
	    if ('nowIndicator' in $$props) $$invalidate(13, nowIndicator = $$props.nowIndicator);
	    if ('slotDuration' in $$props) $$invalidate(14, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(15, slotHeight = $$props.slotHeight);
	    if ('theme' in $$props) $$invalidate(16, theme = $$props.theme);
	    if ('_interaction' in $$props) $$invalidate(17, _interaction = $$props._interaction);
	    if ('_today' in $$props) $$invalidate(18, _today = $$props._today);
	    if ('_slotTimeLimits' in $$props) $$invalidate(19, _slotTimeLimits = $$props._slotTimeLimits);
	    if ('el' in $$props) $$invalidate(1, el = $$props.el);
	    if ('chunks' in $$props) $$invalidate(2, chunks = $$props.chunks);
	    if ('bgChunks' in $$props) $$invalidate(3, bgChunks = $$props.bgChunks);
	    if ('iChunks' in $$props) $$invalidate(4, iChunks = $$props.iChunks);
	    if ('isToday' in $$props) $$invalidate(5, isToday = $$props.isToday);
	    if ('highlight' in $$props) $$invalidate(6, highlight = $$props.highlight);
	    if ('start' in $$props) $$invalidate(22, start = $$props.start);
	    if ('end' in $$props) $$invalidate(23, end = $$props.end);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*date, $_slotTimeLimits*/16777217) {
	      {
	        $$invalidate(22, start = addDuration(cloneDate(date), $_slotTimeLimits.min));
	        $$invalidate(23, end = addDuration(cloneDate(date), $_slotTimeLimits.max));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_events, start, end, resource, bgChunks, chunks*/283115532) {
	      {
	        $$invalidate(2, chunks = []);
	        $$invalidate(3, bgChunks = []);
	        for (let event of $_events) {
	          if (!event.allDay && eventIntersects(event, start, end, resource, true)) {
	            let chunk = createEventChunk(event, start, end);
	            switch (event.display) {
	              case 'background':
	                bgChunks.push(chunk);
	                break;
	              default:
	                chunks.push(chunk);
	            }
	          }
	        }
	        groupEventChunks(chunks);
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$_iEvents, start, end, resource*/148897792) {
	      $$invalidate(4, iChunks = $_iEvents.map(event => event && eventIntersects(event, start, end, resource, true) ? createEventChunk(event, start, end) : null));
	    }
	    if ($$self.$$.dirty[0] & /*date, $_today*/67108865) {
	      $$invalidate(5, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty[0] & /*$highlightedDates, date*/33554433) {
	      $$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty[0] & /*el*/2) {
	      if (el) {
	        setPayload(el, dateFromPoint);
	      }
	    }
	  };
	  return [date, el, chunks, bgChunks, iChunks, isToday, highlight, $theme, $_interaction, $nowIndicator, _events, _iEvents, highlightedDates, nowIndicator, slotDuration, slotHeight, theme, _interaction, _today, _slotTimeLimits, createPointerEnterHandler, resource, start, end, $_slotTimeLimits, $highlightedDates, $_today, $_iEvents, $_events, div3_binding];
	}
	let Day$1 = class Day extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$4$1, create_fragment$4$1, safe_not_equal, {
	      date: 0,
	      resource: 21
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Day",
	      options,
	      id: create_fragment$4$1.name
	    });
	  }
	  get date() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get resource() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set resource(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	/* packages/time-grid/src/all-day/Event.svelte generated by Svelte v4.2.16 */

	const file$2$1 = "packages/time-grid/src/all-day/Event.svelte";
	function create_fragment$3$1(ctx) {
	  let article;
	  let div;
	  let div_class_value;
	  let setContent_action;
	  let t;
	  let switch_instance;
	  let article_role_value;
	  let article_tabindex_value;
	  let current;
	  let mounted;
	  let dispose;
	  var switch_value = /*$_interaction*/ctx[10].resizer;
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        event: /*event*/ctx[0]
	      },
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	    switch_instance.$on("pointerdown", function () {
	      if (is_function( /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	    });
	  }
	  const block = {
	    c: function create() {
	      article = element("article");
	      div = element("div");
	      t = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[2].eventBody);
	      add_location(div, file$2$1, 115, 4, 3474);
	      attr_dev(article, "class", /*classes*/ctx[4]);
	      attr_dev(article, "style", /*style*/ctx[5]);
	      attr_dev(article, "role", article_role_value = /*onclick*/ctx[7] ? 'button' : undefined);
	      attr_dev(article, "tabindex", article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined);
	      add_location(article, file$2$1, 103, 0, 3051);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, article, anchor);
	      append_dev(article, div);
	      append_dev(article, t);
	      if (switch_instance) mount_component(switch_instance, article, null);
	      /*article_binding*/
	      ctx[47](article);
	      current = true;
	      if (!mounted) {
	        dispose = [action_destroyer(setContent_action = setContent.call(null, div, /*content*/ctx[6])), listen_dev(article, "click", function () {
	          if (is_function( /*onclick*/ctx[7])) /*onclick*/ctx[7].apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "keydown", function () {
	          if (is_function( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7]))) ( /*onclick*/ctx[7] && keyEnter( /*onclick*/ctx[7])).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseenter", function () {
	          if (is_function( /*createHandler*/ctx[29]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]))) /*createHandler*/ctx[29]( /*$eventMouseEnter*/ctx[8], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "mouseleave", function () {
	          if (is_function( /*createHandler*/ctx[29]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]))) /*createHandler*/ctx[29]( /*$eventMouseLeave*/ctx[9], /*display*/ctx[1]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(article, "pointerdown", function () {
	          if (is_function(!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10]))) (!helperEvent( /*display*/ctx[1]) && /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10])).apply(this, arguments);
	        }, false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (!current || dirty[0] & /*$theme*/4 && div_class_value !== (div_class_value = /*$theme*/ctx[2].eventBody)) {
	        attr_dev(div, "class", div_class_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/64) setContent_action.update.call(null, /*content*/ctx[6]);
	      if (dirty[0] & /*$_interaction*/1024 && switch_value !== (switch_value = /*$_interaction*/ctx[10].resizer)) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	          switch_instance.$on("pointerdown", function () {
	            if (is_function( /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10], true))) /*createDragHandler*/ctx[30]( /*$_interaction*/ctx[10], true).apply(this, arguments);
	          });
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, article, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty[0] & /*event*/1) switch_instance_changes.event = /*event*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	      if (!current || dirty[0] & /*classes*/16) {
	        attr_dev(article, "class", /*classes*/ctx[4]);
	      }
	      if (!current || dirty[0] & /*style*/32) {
	        attr_dev(article, "style", /*style*/ctx[5]);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_role_value !== (article_role_value = /*onclick*/ctx[7] ? 'button' : undefined)) {
	        attr_dev(article, "role", article_role_value);
	      }
	      if (!current || dirty[0] & /*onclick*/128 && article_tabindex_value !== (article_tabindex_value = /*onclick*/ctx[7] ? 0 : undefined)) {
	        attr_dev(article, "tabindex", article_tabindex_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(article);
	      }
	      if (switch_instance) destroy_component(switch_instance);
	      /*article_binding*/
	      ctx[47](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$3$1($$self, $$props, $$invalidate) {
	  let $eventClick;
	  let $_view;
	  let $eventAllUpdated;
	  let $eventDidMount;
	  let $_intlEventTime;
	  let $theme;
	  let $eventContent;
	  let $displayEventEnd;
	  let $eventClassNames;
	  let $_iClasses;
	  let $eventTextColor;
	  let $_resTxtColor;
	  let $eventColor;
	  let $eventBackgroundColor;
	  let $_resBgColor;
	  let $eventMouseEnter;
	  let $eventMouseLeave;
	  let $_interaction;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Event', slots, []);
	  let {
	    chunk
	  } = $$props;
	  let {
	    longChunks = {}
	  } = $$props;
	  let {
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _tasks
	  } = getContext('state');
	  validate_store(displayEventEnd, 'displayEventEnd');
	  component_subscribe($$self, displayEventEnd, value => $$invalidate(39, $displayEventEnd = value));
	  validate_store(eventAllUpdated, 'eventAllUpdated');
	  component_subscribe($$self, eventAllUpdated, value => $$invalidate(49, $eventAllUpdated = value));
	  validate_store(eventBackgroundColor, 'eventBackgroundColor');
	  component_subscribe($$self, eventBackgroundColor, value => $$invalidate(45, $eventBackgroundColor = value));
	  validate_store(eventTextColor, 'eventTextColor');
	  component_subscribe($$self, eventTextColor, value => $$invalidate(42, $eventTextColor = value));
	  validate_store(eventClick, 'eventClick');
	  component_subscribe($$self, eventClick, value => $$invalidate(35, $eventClick = value));
	  validate_store(eventColor, 'eventColor');
	  component_subscribe($$self, eventColor, value => $$invalidate(44, $eventColor = value));
	  validate_store(eventContent, 'eventContent');
	  component_subscribe($$self, eventContent, value => $$invalidate(38, $eventContent = value));
	  validate_store(eventClassNames, 'eventClassNames');
	  component_subscribe($$self, eventClassNames, value => $$invalidate(40, $eventClassNames = value));
	  validate_store(eventDidMount, 'eventDidMount');
	  component_subscribe($$self, eventDidMount, value => $$invalidate(50, $eventDidMount = value));
	  validate_store(eventMouseEnter, 'eventMouseEnter');
	  component_subscribe($$self, eventMouseEnter, value => $$invalidate(8, $eventMouseEnter = value));
	  validate_store(eventMouseLeave, 'eventMouseLeave');
	  component_subscribe($$self, eventMouseLeave, value => $$invalidate(9, $eventMouseLeave = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(36, $_view = value));
	  validate_store(_intlEventTime, '_intlEventTime');
	  component_subscribe($$self, _intlEventTime, value => $$invalidate(37, $_intlEventTime = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(10, $_interaction = value));
	  validate_store(_iClasses, '_iClasses');
	  component_subscribe($$self, _iClasses, value => $$invalidate(41, $_iClasses = value));
	  validate_store(_resBgColor, '_resBgColor');
	  component_subscribe($$self, _resBgColor, value => $$invalidate(46, $_resBgColor = value));
	  validate_store(_resTxtColor, '_resTxtColor');
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(43, $_resTxtColor = value));
	  let el;
	  let event;
	  let classes;
	  let style;
	  let content;
	  let timeText;
	  let margin = 1;
	  let display;
	  let onclick;
	  onMount(() => {
	    if (is_function($eventDidMount)) {
	      $eventDidMount({
	        event: toEventWithLocalDates(event),
	        timeText,
	        el,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (is_function($eventAllUpdated) && !helperEvent(display)) {
	      task(() => $eventAllUpdated({
	        view: toViewWithLocalDates($_view)
	      }), 'eau', _tasks);
	    }
	  });
	  function createHandler(fn, display) {
	    return !helperEvent(display) && is_function(fn) ? jsEvent => fn({
	      event: toEventWithLocalDates(event),
	      el,
	      jsEvent,
	      view: toViewWithLocalDates($_view)
	    }) : undefined;
	  }
	  function createDragHandler(interaction, resize) {
	    return interaction.action ? jsEvent => interaction.action.drag(event, jsEvent, resize) : undefined;
	  }
	  function reposition() {
	    if (!el) {
	      return;
	    }
	    $$invalidate(34, margin = repositionEvent(chunk, longChunks, height(el)));
	  }
	  $$self.$$.on_mount.push(function () {
	    if (chunk === undefined && !('chunk' in $$props || $$self.$$.bound[$$self.$$.props['chunk']])) {
	      console.warn("<Event> was created without expected prop 'chunk'");
	    }
	  });
	  const writable_props = ['chunk', 'longChunks'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Event> was created with unknown prop '${key}'`);
	  });
	  function article_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('chunk' in $$props) $$invalidate(31, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(32, longChunks = $$props.longChunks);
	  };
	  $$self.$capture_state = () => ({
	    afterUpdate,
	    getContext,
	    onMount,
	    is_function,
	    createEventClasses,
	    createEventContent,
	    height,
	    toEventWithLocalDates,
	    toViewWithLocalDates,
	    setContent,
	    repositionEvent,
	    helperEvent,
	    keyEnter,
	    task,
	    chunk,
	    longChunks,
	    displayEventEnd,
	    eventAllUpdated,
	    eventBackgroundColor,
	    eventTextColor,
	    eventClick,
	    eventColor,
	    eventContent,
	    eventClassNames,
	    eventDidMount,
	    eventMouseEnter,
	    eventMouseLeave,
	    theme,
	    _view,
	    _intlEventTime,
	    _interaction,
	    _iClasses,
	    _resBgColor,
	    _resTxtColor,
	    _tasks,
	    el,
	    event,
	    classes,
	    style,
	    content,
	    timeText,
	    margin,
	    display,
	    onclick,
	    createHandler,
	    createDragHandler,
	    reposition,
	    $eventClick,
	    $_view,
	    $eventAllUpdated,
	    $eventDidMount,
	    $_intlEventTime,
	    $theme,
	    $eventContent,
	    $displayEventEnd,
	    $eventClassNames,
	    $_iClasses,
	    $eventTextColor,
	    $_resTxtColor,
	    $eventColor,
	    $eventBackgroundColor,
	    $_resBgColor,
	    $eventMouseEnter,
	    $eventMouseLeave,
	    $_interaction
	  });
	  $$self.$inject_state = $$props => {
	    if ('chunk' in $$props) $$invalidate(31, chunk = $$props.chunk);
	    if ('longChunks' in $$props) $$invalidate(32, longChunks = $$props.longChunks);
	    if ('displayEventEnd' in $$props) $$invalidate(11, displayEventEnd = $$props.displayEventEnd);
	    if ('eventAllUpdated' in $$props) $$invalidate(12, eventAllUpdated = $$props.eventAllUpdated);
	    if ('eventBackgroundColor' in $$props) $$invalidate(13, eventBackgroundColor = $$props.eventBackgroundColor);
	    if ('eventTextColor' in $$props) $$invalidate(14, eventTextColor = $$props.eventTextColor);
	    if ('eventClick' in $$props) $$invalidate(15, eventClick = $$props.eventClick);
	    if ('eventColor' in $$props) $$invalidate(16, eventColor = $$props.eventColor);
	    if ('eventContent' in $$props) $$invalidate(17, eventContent = $$props.eventContent);
	    if ('eventClassNames' in $$props) $$invalidate(18, eventClassNames = $$props.eventClassNames);
	    if ('eventDidMount' in $$props) $$invalidate(19, eventDidMount = $$props.eventDidMount);
	    if ('eventMouseEnter' in $$props) $$invalidate(20, eventMouseEnter = $$props.eventMouseEnter);
	    if ('eventMouseLeave' in $$props) $$invalidate(21, eventMouseLeave = $$props.eventMouseLeave);
	    if ('theme' in $$props) $$invalidate(22, theme = $$props.theme);
	    if ('_view' in $$props) $$invalidate(23, _view = $$props._view);
	    if ('_intlEventTime' in $$props) $$invalidate(24, _intlEventTime = $$props._intlEventTime);
	    if ('_interaction' in $$props) $$invalidate(25, _interaction = $$props._interaction);
	    if ('_iClasses' in $$props) $$invalidate(26, _iClasses = $$props._iClasses);
	    if ('_resBgColor' in $$props) $$invalidate(27, _resBgColor = $$props._resBgColor);
	    if ('_resTxtColor' in $$props) $$invalidate(28, _resTxtColor = $$props._resTxtColor);
	    if ('_tasks' in $$props) _tasks = $$props._tasks;
	    if ('el' in $$props) $$invalidate(3, el = $$props.el);
	    if ('event' in $$props) $$invalidate(0, event = $$props.event);
	    if ('classes' in $$props) $$invalidate(4, classes = $$props.classes);
	    if ('style' in $$props) $$invalidate(5, style = $$props.style);
	    if ('content' in $$props) $$invalidate(6, content = $$props.content);
	    if ('timeText' in $$props) timeText = $$props.timeText;
	    if ('margin' in $$props) $$invalidate(34, margin = $$props.margin);
	    if ('display' in $$props) $$invalidate(1, display = $$props.display);
	    if ('onclick' in $$props) $$invalidate(7, onclick = $$props.onclick);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[1] & /*chunk*/1) {
	      $$invalidate(0, event = chunk.event);
	    }
	    if ($$self.$$.dirty[0] & /*event, style, $theme*/37 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, $_resTxtColor, $eventTextColor, chunk, margin, $_iClasses, $eventClassNames, $_view*/65065) {
	      {
	        $$invalidate(1, display = event.display);

	        // Class & Style
	        let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
	        let txtColor = event.textColor || $_resTxtColor(event) || $eventTextColor;
	        $$invalidate(5, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);
	        if (bgColor) {
	          $$invalidate(5, style += `background-color:${bgColor};`);
	        }
	        if (txtColor) {
	          $$invalidate(5, style += `color:${txtColor};`);
	        }
	        $$invalidate(4, classes = [$theme.event, ...$_iClasses([], event), ...createEventClasses($eventClassNames, event, $_view)].join(' '));
	      }
	    }
	    if ($$self.$$.dirty[0] & /*$theme*/4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/481) {
	      // Content
	      $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
	    }
	    if ($$self.$$.dirty[0] & /*display*/2 | $$self.$$.dirty[1] & /*$eventClick*/16) {
	      // Onclick handler
	      $$invalidate(7, onclick = createHandler($eventClick, display));
	    }
	  };
	  return [event, display, $theme, el, classes, style, content, onclick, $eventMouseEnter, $eventMouseLeave, $_interaction, displayEventEnd, eventAllUpdated, eventBackgroundColor, eventTextColor, eventClick, eventColor, eventContent, eventClassNames, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _iClasses, _resBgColor, _resTxtColor, createHandler, createDragHandler, chunk, longChunks, reposition, margin, $eventClick, $_view, $_intlEventTime, $eventContent, $displayEventEnd, $eventClassNames, $_iClasses, $eventTextColor, $_resTxtColor, $eventColor, $eventBackgroundColor, $_resBgColor, article_binding];
	}
	class Event extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3$1, create_fragment$3$1, safe_not_equal, {
	      chunk: 31,
	      longChunks: 32,
	      reposition: 33
	    }, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Event",
	      options,
	      id: create_fragment$3$1.name
	    });
	  }
	  get chunk() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunk(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get longChunks() {
	    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set longChunks(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get reposition() {
	    return this.$$.ctx[33];
	  }
	  set reposition(value) {
	    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/time-grid/src/all-day/Day.svelte generated by Svelte v4.2.16 */
	const file$1$1 = "packages/time-grid/src/all-day/Day.svelte";
	function get_each_context$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  child_ctx[22] = list;
	  child_ctx[23] = i;
	  return child_ctx;
	}

	// (49:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
	function create_if_block$1$1(ctx) {
	  let div;
	  let event;
	  let div_class_value;
	  let current;
	  event = new Event({
	    props: {
	      chunk: /*iChunks*/ctx[2][0]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(event.$$.fragment);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[8].events + " " + /*$theme*/ctx[8].preview));
	      add_location(div, file$1$1, 49, 8, 1319);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(event, div, null);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const event_changes = {};
	      if (dirty & /*iChunks*/4) event_changes.chunk = /*iChunks*/ctx[2][0];
	      event.$set(event_changes);
	      if (!current || dirty & /*$theme*/256 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[8].events + " " + /*$theme*/ctx[8].preview))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(event);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1$1.name,
	    type: "if",
	    source: "(49:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}",
	    ctx
	  });
	  return block;
	}

	// (55:8) {#each dayChunks as chunk, i (chunk.event)}
	function create_each_block$2(key_1, ctx) {
	  let first;
	  let event;
	  let i = /*i*/ctx[23];
	  let current;
	  const assign_event = () => /*event_binding*/ctx[19](event, i);
	  const unassign_event = () => /*event_binding*/ctx[19](null, i);
	  let event_props = {
	    chunk: /*chunk*/ctx[21],
	    longChunks: /*longChunks*/ctx[1]
	  };
	  event = new Event({
	    props: event_props,
	    $$inline: true
	  });
	  assign_event();
	  const block = {
	    key: key_1,
	    first: null,
	    c: function create() {
	      first = empty();
	      create_component(event.$$.fragment);
	      this.first = first;
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, first, anchor);
	      mount_component(event, target, anchor);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (i !== /*i*/ctx[23]) {
	        unassign_event();
	        i = /*i*/ctx[23];
	        assign_event();
	      }
	      const event_changes = {};
	      if (dirty & /*dayChunks*/16) event_changes.chunk = /*chunk*/ctx[21];
	      if (dirty & /*longChunks*/2) event_changes.longChunks = /*longChunks*/ctx[1];
	      event.$set(event_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(event.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(event.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(first);
	      }
	      unassign_event();
	      destroy_component(event, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$2.name,
	    type: "each",
	    source: "(55:8) {#each dayChunks as chunk, i (chunk.event)}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$2$2(ctx) {
	  let div1;
	  let show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	  let t;
	  let div0;
	  let each_blocks = [];
	  let each_1_lookup = new Map();
	  let div0_class_value;
	  let div1_class_value;
	  let current;
	  let mounted;
	  let dispose;
	  let if_block = show_if && create_if_block$1$1(ctx);
	  let each_value = ensure_array_like_dev( /*dayChunks*/ctx[4]);
	  const get_key = ctx => /*chunk*/ctx[21].event;
	  validate_each_keys(ctx, each_value, get_each_context$2, get_key);
	  for (let i = 0; i < each_value.length; i += 1) {
	    let child_ctx = get_each_context$2(ctx, each_value, i);
	    let key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	  }
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      if (if_block) if_block.c();
	      t = space();
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[8].events);
	      add_location(div0, file$1$1, 53, 4, 1435);
	      attr_dev(div1, "class", div1_class_value = "" + ( /*$theme*/ctx[8].day + " " + /*$theme*/ctx[8].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[8].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[8].highlight : '')));
	      attr_dev(div1, "role", "cell");
	      add_location(div1, file$1$1, 41, 0, 987);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      if (if_block) if_block.m(div1, null);
	      append_dev(div1, t);
	      append_dev(div1, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }

	      /*div1_binding*/
	      ctx[20](div1);
	      current = true;
	      if (!mounted) {
	        dispose = listen_dev(div1, "pointerdown", function () {
	          if (is_function( /*$_interaction*/ctx[9].action?.select)) /*$_interaction*/ctx[9].action?.select.apply(this, arguments);
	        }, false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, _ref6) {
	      let [dirty] = _ref6;
	      ctx = new_ctx;
	      if (dirty & /*iChunks, date*/5) show_if = /*iChunks*/ctx[2][0] && datesEqual( /*iChunks*/ctx[2][0].date, /*date*/ctx[0]);
	      if (show_if) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*iChunks, date*/5) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$1$1(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(div1, t);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      if (dirty & /*dayChunks, longChunks, refs*/146) {
	        each_value = ensure_array_like_dev( /*dayChunks*/ctx[4]);
	        group_outros();
	        validate_each_keys(ctx, each_value, get_each_context$2, get_key);
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
	        check_outros();
	      }
	      if (!current || dirty & /*$theme*/256 && div0_class_value !== (div0_class_value = /*$theme*/ctx[8].events)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme, date, isToday, highlight*/353 && div1_class_value !== (div1_class_value = "" + ( /*$theme*/ctx[8].day + " " + /*$theme*/ctx[8].weekdays?.[/*date*/ctx[0].getUTCDay()] + ( /*isToday*/ctx[5] ? ' ' + /*$theme*/ctx[8].today : '') + ( /*highlight*/ctx[6] ? ' ' + /*$theme*/ctx[8].highlight : '')))) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	      }
	      if (if_block) if_block.d();
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].d();
	      }

	      /*div1_binding*/
	      ctx[20](null);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2$2($$self, $$props, $$invalidate) {
	  let $highlightedDates;
	  let $_today;
	  let $theme;
	  let $_interaction;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Day', slots, []);
	  let {
	    date
	  } = $$props;
	  let {
	    chunks
	  } = $$props;
	  let {
	    longChunks
	  } = $$props;
	  let {
	    iChunks = []
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    highlightedDates,
	    theme,
	    _interaction,
	    _today
	  } = getContext('state');
	  validate_store(highlightedDates, 'highlightedDates');
	  component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(8, $theme = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(9, $_interaction = value));
	  validate_store(_today, '_today');
	  component_subscribe($$self, _today, value => $$invalidate(18, $_today = value));
	  let el;
	  let dayChunks;
	  let isToday;
	  let highlight;
	  let refs = [];
	  function reposition() {
	    runReposition(refs, dayChunks);
	  }
	  $$self.$$.on_mount.push(function () {
	    if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
	      console.warn("<Day> was created without expected prop 'date'");
	    }
	    if (chunks === undefined && !('chunks' in $$props || $$self.$$.bound[$$self.$$.props['chunks']])) {
	      console.warn("<Day> was created without expected prop 'chunks'");
	    }
	    if (longChunks === undefined && !('longChunks' in $$props || $$self.$$.bound[$$self.$$.props['longChunks']])) {
	      console.warn("<Day> was created without expected prop 'longChunks'");
	    }
	  });
	  const writable_props = ['date', 'chunks', 'longChunks', 'iChunks', 'resource'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Day> was created with unknown prop '${key}'`);
	  });
	  function event_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(7, refs);
	    });
	  }
	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(3, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(14, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	    if ('resource' in $$props) $$invalidate(15, resource = $$props.resource);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    datesEqual,
	    runReposition,
	    setPayload,
	    Event,
	    date,
	    chunks,
	    longChunks,
	    iChunks,
	    resource,
	    highlightedDates,
	    theme,
	    _interaction,
	    _today,
	    el,
	    dayChunks,
	    isToday,
	    highlight,
	    refs,
	    reposition,
	    $highlightedDates,
	    $_today,
	    $theme,
	    $_interaction
	  });
	  $$self.$inject_state = $$props => {
	    if ('date' in $$props) $$invalidate(0, date = $$props.date);
	    if ('chunks' in $$props) $$invalidate(14, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	    if ('resource' in $$props) $$invalidate(15, resource = $$props.resource);
	    if ('highlightedDates' in $$props) $$invalidate(10, highlightedDates = $$props.highlightedDates);
	    if ('theme' in $$props) $$invalidate(11, theme = $$props.theme);
	    if ('_interaction' in $$props) $$invalidate(12, _interaction = $$props._interaction);
	    if ('_today' in $$props) $$invalidate(13, _today = $$props._today);
	    if ('el' in $$props) $$invalidate(3, el = $$props.el);
	    if ('dayChunks' in $$props) $$invalidate(4, dayChunks = $$props.dayChunks);
	    if ('isToday' in $$props) $$invalidate(5, isToday = $$props.isToday);
	    if ('highlight' in $$props) $$invalidate(6, highlight = $$props.highlight);
	    if ('refs' in $$props) $$invalidate(7, refs = $$props.refs);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*chunks, date, dayChunks*/16401) {
	      {
	        $$invalidate(4, dayChunks = []);
	        for (let chunk of chunks) {
	          if (datesEqual(chunk.date, date)) {
	            dayChunks.push(chunk);
	          }
	        }
	      }
	    }
	    if ($$self.$$.dirty & /*date, $_today*/262145) {
	      $$invalidate(5, isToday = datesEqual(date, $_today));
	    }
	    if ($$self.$$.dirty & /*$highlightedDates, date*/131073) {
	      $$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
	    }
	    if ($$self.$$.dirty & /*el, date, resource*/32777) {
	      // dateFromPoint
	      if (el) {
	        setPayload(el, () => ({
	          allDay: true,
	          date,
	          resource,
	          dayEl: el
	        }));
	      }
	    }
	  };
	  return [date, longChunks, iChunks, el, dayChunks, isToday, highlight, refs, $theme, $_interaction, highlightedDates, theme, _interaction, _today, chunks, resource, reposition, $highlightedDates, $_today, event_binding, div1_binding];
	}
	class Day extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2$2, create_fragment$2$2, safe_not_equal, {
	      date: 0,
	      chunks: 14,
	      longChunks: 1,
	      iChunks: 2,
	      resource: 15,
	      reposition: 16
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Day",
	      options,
	      id: create_fragment$2$2.name
	    });
	  }
	  get date() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get chunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set chunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get longChunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set longChunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get iChunks() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set iChunks(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get resource() {
	    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set resource(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get reposition() {
	    return this.$$.ctx[16];
	  }
	  set reposition(value) {
	    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/time-grid/src/all-day/Week.svelte generated by Svelte v4.2.16 */

	function get_each_context$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[18] = list[i];
	  child_ctx[19] = list;
	  child_ctx[20] = i;
	  return child_ctx;
	}

	// (59:0) {#each dates as date, i}
	function create_each_block$1(ctx) {
	  let day;
	  let i = /*i*/ctx[20];
	  let current;
	  const assign_day = () => /*day_binding*/ctx[15](day, i);
	  const unassign_day = () => /*day_binding*/ctx[15](null, i);
	  let day_props = {
	    date: /*date*/ctx[18],
	    chunks: /*chunks*/ctx[2],
	    longChunks: /*longChunks*/ctx[3],
	    iChunks: /*iChunks*/ctx[4],
	    resource: /*resource*/ctx[1]
	  };
	  day = new Day({
	    props: day_props,
	    $$inline: true
	  });
	  assign_day();
	  const block = {
	    c: function create() {
	      create_component(day.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (i !== /*i*/ctx[20]) {
	        unassign_day();
	        i = /*i*/ctx[20];
	        assign_day();
	      }
	      const day_changes = {};
	      if (dirty & /*dates*/1) day_changes.date = /*date*/ctx[18];
	      if (dirty & /*chunks*/4) day_changes.chunks = /*chunks*/ctx[2];
	      if (dirty & /*longChunks*/8) day_changes.longChunks = /*longChunks*/ctx[3];
	      if (dirty & /*iChunks*/16) day_changes.iChunks = /*iChunks*/ctx[4];
	      if (dirty & /*resource*/2) day_changes.resource = /*resource*/ctx[1];
	      day.$set(day_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      unassign_day();
	      destroy_component(day, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1.name,
	    type: "each",
	    source: "(59:0) {#each dates as date, i}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1$2(ctx) {
	  let each_1_anchor;
	  let current;
	  let mounted;
	  let dispose;
	  let each_value = ensure_array_like_dev( /*dates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	      if (!mounted) {
	        dispose = listen_dev(window, "resize", /*reposition*/ctx[9], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref7) {
	      let [dirty] = _ref7;
	      if (dirty & /*dates, chunks, longChunks, iChunks, resource, refs*/63) {
	        each_value = ensure_array_like_dev( /*dates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1$2($$self, $$props, $$invalidate) {
	  let $hiddenDays;
	  let $_iEvents;
	  let $_events;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Week', slots, []);
	  let {
	    dates
	  } = $$props;
	  let {
	    resource = undefined
	  } = $$props;
	  let {
	    _events,
	    _iEvents,
	    _queue2,
	    hiddenDays
	  } = getContext('state');
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(14, $_events = value));
	  validate_store(_iEvents, '_iEvents');
	  component_subscribe($$self, _iEvents, value => $$invalidate(13, $_iEvents = value));
	  validate_store(hiddenDays, 'hiddenDays');
	  component_subscribe($$self, hiddenDays, value => $$invalidate(12, $hiddenDays = value));
	  let chunks,
	    longChunks,
	    iChunks = [];
	  let start;
	  let end;
	  let refs = [];
	  let debounceHandle = {};
	  function reposition() {
	    debounce(() => runReposition(refs, dates), debounceHandle, _queue2);
	  }
	  $$self.$$.on_mount.push(function () {
	    if (dates === undefined && !('dates' in $$props || $$self.$$.bound[$$self.$$.props['dates']])) {
	      console.warn("<Week> was created without expected prop 'dates'");
	    }
	  });
	  const writable_props = ['dates', 'resource'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Week> was created with unknown prop '${key}'`);
	  });
	  function day_binding($$value, i) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      refs[i] = $$value;
	      $$invalidate(5, refs);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	    if ('resource' in $$props) $$invalidate(1, resource = $$props.resource);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    cloneDate,
	    addDay,
	    createEventChunk,
	    prepareEventChunks,
	    eventIntersects,
	    debounce,
	    runReposition,
	    Day,
	    dates,
	    resource,
	    _events,
	    _iEvents,
	    _queue2,
	    hiddenDays,
	    chunks,
	    longChunks,
	    iChunks,
	    start,
	    end,
	    refs,
	    debounceHandle,
	    reposition,
	    $hiddenDays,
	    $_iEvents,
	    $_events
	  });
	  $$self.$inject_state = $$props => {
	    if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	    if ('resource' in $$props) $$invalidate(1, resource = $$props.resource);
	    if ('_events' in $$props) $$invalidate(6, _events = $$props._events);
	    if ('_iEvents' in $$props) $$invalidate(7, _iEvents = $$props._iEvents);
	    if ('_queue2' in $$props) _queue2 = $$props._queue2;
	    if ('hiddenDays' in $$props) $$invalidate(8, hiddenDays = $$props.hiddenDays);
	    if ('chunks' in $$props) $$invalidate(2, chunks = $$props.chunks);
	    if ('longChunks' in $$props) $$invalidate(3, longChunks = $$props.longChunks);
	    if ('iChunks' in $$props) $$invalidate(4, iChunks = $$props.iChunks);
	    if ('start' in $$props) $$invalidate(10, start = $$props.start);
	    if ('end' in $$props) $$invalidate(11, end = $$props.end);
	    if ('refs' in $$props) $$invalidate(5, refs = $$props.refs);
	    if ('debounceHandle' in $$props) debounceHandle = $$props.debounceHandle;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*dates*/1) {
	      {
	        $$invalidate(10, start = dates[0]);
	        $$invalidate(11, end = addDay(cloneDate(dates[dates.length - 1])));
	      }
	    }
	    if ($$self.$$.dirty & /*$_events, start, end, resource, chunks, $hiddenDays*/23558) {
	      {
	        $$invalidate(2, chunks = []);
	        for (let event of $_events) {
	          if (event.allDay && event.display !== 'background' && eventIntersects(event, start, end, resource)) {
	            let chunk = createEventChunk(event, start, end);
	            chunks.push(chunk);
	          }
	        }
	        $$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));

	        // Run reposition only when events get changed
	        reposition();
	      }
	    }
	    if ($$self.$$.dirty & /*$_iEvents, start, end, resource, $hiddenDays*/15362) {
	      $$invalidate(4, iChunks = $_iEvents.map(event => {
	        let chunk;
	        if (event && event.allDay && eventIntersects(event, start, end, resource)) {
	          chunk = createEventChunk(event, start, end);
	          prepareEventChunks([chunk], $hiddenDays);
	        } else {
	          chunk = null;
	        }
	        return chunk;
	      }));
	    }
	  };
	  return [dates, resource, chunks, longChunks, iChunks, refs, _events, _iEvents, hiddenDays, reposition, start, end, $hiddenDays, $_iEvents, $_events, day_binding];
	}
	class Week extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1$2, create_fragment$1$2, safe_not_equal, {
	      dates: 0,
	      resource: 1
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Week",
	      options,
	      id: create_fragment$1$2.name
	    });
	  }
	  get dates() {
	    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set dates(value) {
	    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get resource() {
	    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set resource(value) {
	    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/time-grid/src/View.svelte generated by Svelte v4.2.16 */
	const file$8 = "packages/time-grid/src/View.svelte";
	function get_each_context$6(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}
	function get_each_context_1$2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[10] = list[i];
	  return child_ctx;
	}

	// (14:8) {#each $_viewDates as date}
	function create_each_block_1$2(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      time = element("time");
	      t = space();
	      attr_dev(time, "datetime", time_datetime_value = toISOString( /*date*/ctx[10], 10));
	      attr_dev(time, "aria-label", time_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*date*/ctx[10]));
	      add_location(time, file$8, 15, 16, 580);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*date*/ctx[10].getUTCDay()]));
	      attr_dev(div, "role", "columnheader");
	      add_location(div, file$8, 14, 12, 479);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, time);
	      append_dev(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[3].format( /*date*/ctx[10])));
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty & /*$_viewDates*/2 && time_datetime_value !== (time_datetime_value = toISOString( /*date*/ctx[10], 10))) {
	        attr_dev(time, "datetime", time_datetime_value);
	      }
	      if (dirty & /*$_intlDayHeaderAL, $_viewDates*/6 && time_aria_label_value !== (time_aria_label_value = /*$_intlDayHeaderAL*/ctx[2].format( /*date*/ctx[10]))) {
	        attr_dev(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_intlDayHeader, $_viewDates*/10) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[3].format( /*date*/ctx[10]));
	      if (dirty & /*$theme, $_viewDates*/3 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[0].day + " " + /*$theme*/ctx[0].weekdays?.[/*date*/ctx[10].getUTCDay()]))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1$2.name,
	    type: "each",
	    source: "(14:8) {#each $_viewDates as date}",
	    ctx
	  });
	  return block;
	}

	// (13:4) <Section>
	function create_default_slot_2$1(ctx) {
	  let each_1_anchor;
	  let each_value_1 = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	  }
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme, $_viewDates, $_intlDayHeaderAL, $_intlDayHeader*/15) {
	        each_value_1 = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1$2(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	          } else {
	            each_blocks[i] = create_each_block_1$2(child_ctx);
	            each_blocks[i].c();
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        for (; i < each_blocks.length; i += 1) {
	          each_blocks[i].d(1);
	        }
	        each_blocks.length = each_value_1.length;
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_2$1.name,
	    type: "slot",
	    source: "(13:4) <Section>",
	    ctx
	  });
	  return block;
	}

	// (26:0) {#if $allDaySlot}
	function create_if_block$3(ctx) {
	  let div2;
	  let div1;
	  let section;
	  let t;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_1$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div2 = element("div");
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t = space();
	      div0 = element("div");
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].hiddenScroll);
	      add_location(div0, file$8, 31, 12, 1093);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[0].content);
	      add_location(div1, file$8, 27, 8, 961);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[0].allDay);
	      add_location(div2, file$8, 26, 4, 923);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div1);
	      mount_component(section, div1, null);
	      append_dev(div1, t);
	      append_dev(div1, div0);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const section_changes = {};
	      if (dirty & /*$$scope, $_viewDates*/32770) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].content)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div2_class_value !== (div2_class_value = /*$theme*/ctx[0].allDay)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div2);
	      }
	      destroy_component(section);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$3.name,
	    type: "if",
	    source: "(26:0) {#if $allDaySlot}",
	    ctx
	  });
	  return block;
	}

	// (29:12) <Section>
	function create_default_slot_1$1(ctx) {
	  let week;
	  let current;
	  week = new Week({
	    props: {
	      dates: /*$_viewDates*/ctx[1]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(week.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const week_changes = {};
	      if (dirty & /*$_viewDates*/2) week_changes.dates = /*$_viewDates*/ctx[1];
	      week.$set(week_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_1$1.name,
	    type: "slot",
	    source: "(29:12) <Section>",
	    ctx
	  });
	  return block;
	}

	// (37:0) {#each $_viewDates as date}
	function create_each_block$6(ctx) {
	  let day;
	  let current;
	  day = new Day$1({
	    props: {
	      date: /*date*/ctx[10]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(day.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const day_changes = {};
	      if (dirty & /*$_viewDates*/2) day_changes.date = /*date*/ctx[10];
	      day.$set(day_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$6.name,
	    type: "each",
	    source: "(37:0) {#each $_viewDates as date}",
	    ctx
	  });
	  return block;
	}

	// (36:0) <Body>
	function create_default_slot$2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$_viewDates*/2) {
	        each_value = ensure_array_like_dev( /*$_viewDates*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$6(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$6(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot$2.name,
	    type: "slot",
	    source: "(36:0) <Body>",
	    ctx
	  });
	  return block;
	}
	function create_fragment$9(ctx) {
	  let div1;
	  let section;
	  let t0;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let t1;
	  let t2;
	  let body;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_2$1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  let if_block = /*$allDaySlot*/ctx[4] && create_if_block$3(ctx);
	  body = new Body({
	    props: {
	      $$slots: {
	        default: [create_default_slot$2]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t0 = space();
	      div0 = element("div");
	      t1 = space();
	      if (if_block) if_block.c();
	      t2 = space();
	      create_component(body.$$.fragment);
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[0].hiddenScroll);
	      add_location(div0, file$8, 23, 4, 852);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[0].header);
	      add_location(div1, file$8, 11, 0, 387);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      mount_component(section, div1, null);
	      append_dev(div1, t0);
	      append_dev(div1, div0);
	      insert_dev(target, t1, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, t2, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref8) {
	      let [dirty] = _ref8;
	      const section_changes = {};
	      if (dirty & /*$$scope, $_viewDates, $theme, $_intlDayHeaderAL, $_intlDayHeader*/32783) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty & /*$theme*/1 && div0_class_value !== (div0_class_value = /*$theme*/ctx[0].hiddenScroll)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty & /*$theme*/1 && div1_class_value !== (div1_class_value = /*$theme*/ctx[0].header)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if ( /*$allDaySlot*/ctx[4]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*$allDaySlot*/16) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$3(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t2.parentNode, t2);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      const body_changes = {};
	      if (dirty & /*$$scope, $_viewDates*/32770) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      transition_in(if_block);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(section.$$.fragment, local);
	      transition_out(if_block);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	        detach_dev(t1);
	        detach_dev(t2);
	      }
	      destroy_component(section);
	      if (if_block) if_block.d(detaching);
	      destroy_component(body, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$9.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$9($$self, $$props, $$invalidate) {
	  let $theme;
	  let $_viewDates;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let $allDaySlot;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('View', slots, []);
	  let {
	    _viewDates,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme
	  } = getContext('state');
	  validate_store(_viewDates, '_viewDates');
	  component_subscribe($$self, _viewDates, value => $$invalidate(1, $_viewDates = value));
	  validate_store(_intlDayHeader, '_intlDayHeader');
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	  validate_store(_intlDayHeaderAL, '_intlDayHeaderAL');
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(2, $_intlDayHeaderAL = value));
	  validate_store(allDaySlot, 'allDaySlot');
	  component_subscribe($$self, allDaySlot, value => $$invalidate(4, $allDaySlot = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<View> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    setContent,
	    toISOString,
	    Section,
	    Body,
	    Day: Day$1,
	    Week,
	    _viewDates,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme,
	    $theme,
	    $_viewDates,
	    $_intlDayHeaderAL,
	    $_intlDayHeader,
	    $allDaySlot
	  });
	  $$self.$inject_state = $$props => {
	    if ('_viewDates' in $$props) $$invalidate(5, _viewDates = $$props._viewDates);
	    if ('_intlDayHeader' in $$props) $$invalidate(6, _intlDayHeader = $$props._intlDayHeader);
	    if ('_intlDayHeaderAL' in $$props) $$invalidate(7, _intlDayHeaderAL = $$props._intlDayHeaderAL);
	    if ('allDaySlot' in $$props) $$invalidate(8, allDaySlot = $$props.allDaySlot);
	    if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [$theme, $_viewDates, $_intlDayHeaderAL, $_intlDayHeader, $allDaySlot, _viewDates, _intlDayHeader, _intlDayHeaderAL, allDaySlot, theme];
	}
	let View$1 = class View extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "View",
	      options,
	      id: create_fragment$9.name
	    });
	  }
	};
	var index$3 = {
	  createOptions(options) {
	    // Common options
	    options.buttonText.timeGridDay = 'day';
	    options.buttonText.timeGridWeek = 'week';
	    options.view = 'timeGridWeek';
	    options.views.timeGridDay = {
	      buttonText: btnTextDay,
	      component: View$1,
	      dayHeaderFormat: {
	        weekday: 'long'
	      },
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-time-grid ec-day-view'),
	      titleFormat: {
	        year: 'numeric',
	        month: 'long',
	        day: 'numeric'
	      }
	    };
	    options.views.timeGridWeek = {
	      buttonText: btnTextWeek,
	      component: View$1,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-time-grid ec-week-view')
	    };
	  },
	  createStores(state) {
	    state._slotTimeLimits = slotTimeLimits(state); // flexible limits
	    state._times = times(state);
	  }
	};

	function createResources(input) {
	  return input.map(resource => ({
	    id: String(resource.id),
	    title: resource.title || '',
	    titleHTML: resource.titleHTML || '',
	    eventBackgroundColor: resource.eventBackgroundColor,
	    eventTextColor: resource.eventTextColor
	  }));
	}
	function viewResources(state) {
	  return derived([state.resources, state.filterResourcesWithEvents, state._events, state._activeRange], _ref => {
	    let [$resources, $filterResourcesWithEvents, $_events, $_activeRange] = _ref;
	    let result = $resources;
	    if ($filterResourcesWithEvents) {
	      result = $resources.filter(resource => {
	        for (let event of $_events) {
	          if (event.display !== 'background' && event.resourceIds.includes(resource.id) && event.start < $_activeRange.end && event.end > $_activeRange.start) {
	            return true;
	          }
	        }
	        return false;
	      });
	    }
	    if (!result.length) {
	      result = createResources([{}]);
	    }
	    return result;
	  });
	}

	/* packages/resource-time-grid/src/Label.svelte generated by Svelte v4.2.16 */
	const file$1 = "packages/resource-time-grid/src/Label.svelte";
	function create_fragment$2$1(ctx) {
	  let span;
	  let setContent_action;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      span = element("span");
	      attr_dev(span, "aria-label", /*ariaLabel*/ctx[2]);
	      add_location(span, file$1, 48, 0, 1339);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, span, anchor);
	      /*span_binding*/
	      ctx[9](span);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, span, /*content*/ctx[1]));
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref2) {
	      let [dirty] = _ref2;
	      if (dirty & /*ariaLabel*/4) {
	        attr_dev(span, "aria-label", /*ariaLabel*/ctx[2]);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/2) setContent_action.update.call(null, /*content*/ctx[1]);
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(span);
	      }

	      /*span_binding*/
	      ctx[9](null);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2$1($$self, $$props, $$invalidate) {
	  let $_intlDayHeaderAL;
	  let $resourceLabelDidMount;
	  let $resourceLabelContent;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Label', slots, []);
	  let {
	    resource
	  } = $$props;
	  let {
	    date = undefined
	  } = $$props;
	  let {
	    resourceLabelContent,
	    resourceLabelDidMount,
	    _intlDayHeaderAL
	  } = getContext('state');
	  validate_store(resourceLabelContent, 'resourceLabelContent');
	  component_subscribe($$self, resourceLabelContent, value => $$invalidate(8, $resourceLabelContent = value));
	  validate_store(resourceLabelDidMount, 'resourceLabelDidMount');
	  component_subscribe($$self, resourceLabelDidMount, value => $$invalidate(11, $resourceLabelDidMount = value));
	  validate_store(_intlDayHeaderAL, '_intlDayHeaderAL');
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(10, $_intlDayHeaderAL = value));
	  const dispatch = createEventDispatcher();
	  let el;
	  let content;
	  let ariaLabel;
	  onMount(() => {
	    if (is_function($resourceLabelDidMount)) {
	      $resourceLabelDidMount({
	        resource,
	        date: date ? toLocalDate(date) : undefined,
	        el
	      });
	    }
	  });
	  afterUpdate(() => {
	    if (date) {
	      $$invalidate(2, ariaLabel = $_intlDayHeaderAL.format(date) + ', ' + el.innerText);
	    } else {
	      $$invalidate(2, ariaLabel = undefined);
	      dispatch('text', el.innerText);
	    }
	  });
	  $$self.$$.on_mount.push(function () {
	    if (resource === undefined && !('resource' in $$props || $$self.$$.bound[$$self.$$.props['resource']])) {
	      console.warn("<Label> was created without expected prop 'resource'");
	    }
	  });
	  const writable_props = ['resource', 'date'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Label> was created with unknown prop '${key}'`);
	  });
	  function span_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      el = $$value;
	      $$invalidate(0, el);
	    });
	  }
	  $$self.$$set = $$props => {
	    if ('resource' in $$props) $$invalidate(6, resource = $$props.resource);
	    if ('date' in $$props) $$invalidate(7, date = $$props.date);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    onMount,
	    afterUpdate,
	    createEventDispatcher,
	    is_function,
	    setContent,
	    toLocalDate,
	    resource,
	    date,
	    resourceLabelContent,
	    resourceLabelDidMount,
	    _intlDayHeaderAL,
	    dispatch,
	    el,
	    content,
	    ariaLabel,
	    $_intlDayHeaderAL,
	    $resourceLabelDidMount,
	    $resourceLabelContent
	  });
	  $$self.$inject_state = $$props => {
	    if ('resource' in $$props) $$invalidate(6, resource = $$props.resource);
	    if ('date' in $$props) $$invalidate(7, date = $$props.date);
	    if ('resourceLabelContent' in $$props) $$invalidate(3, resourceLabelContent = $$props.resourceLabelContent);
	    if ('resourceLabelDidMount' in $$props) $$invalidate(4, resourceLabelDidMount = $$props.resourceLabelDidMount);
	    if ('_intlDayHeaderAL' in $$props) $$invalidate(5, _intlDayHeaderAL = $$props._intlDayHeaderAL);
	    if ('el' in $$props) $$invalidate(0, el = $$props.el);
	    if ('content' in $$props) $$invalidate(1, content = $$props.content);
	    if ('ariaLabel' in $$props) $$invalidate(2, ariaLabel = $$props.ariaLabel);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$resourceLabelContent, resource, date*/448) {
	      // Content
	      if ($resourceLabelContent) {
	        $$invalidate(1, content = is_function($resourceLabelContent) ? $resourceLabelContent({
	          resource,
	          date: date ? toLocalDate(date) : undefined
	        }) : $resourceLabelContent);
	      } else {
	        $$invalidate(1, content = resource.titleHTML ? {
	          html: resource.titleHTML
	        } : resource.title);
	      }
	    }
	  };
	  return [el, content, ariaLabel, resourceLabelContent, resourceLabelDidMount, _intlDayHeaderAL, resource, date, $resourceLabelContent, span_binding];
	}
	class Label extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2$1, create_fragment$2$1, safe_not_equal, {
	      resource: 6,
	      date: 7
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Label",
	      options,
	      id: create_fragment$2$1.name
	    });
	  }
	  get resource() {
	    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set resource(value) {
	    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get date() {
	    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set date(value) {
	    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/resource-time-grid/src/View.svelte generated by Svelte v4.2.16 */
	const file$2 = "packages/resource-time-grid/src/View.svelte";
	function get_each_context(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[17] = list[i];
	  return child_ctx;
	}
	function get_each_context_1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}
	function get_each_context_4(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[26] = list[i];
	  return child_ctx;
	}
	function get_each_context_2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[23] = list[i];
	  return child_ctx;
	}
	function get_each_context_3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[26] = list[i];
	  return child_ctx;
	}
	function get_each_context_5(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[17] = list[i];
	  child_ctx[32] = i;
	  return child_ctx;
	}
	function get_each_context_6(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	// (28:16) {:else}
	function create_else_block_2(ctx) {
	  let div;
	  let label;
	  let div_class_value;
	  let current;
	  function text_handler() {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    return /*text_handler*/ctx[16]( /*i*/ctx[32], ...args);
	  }
	  label = new Label({
	    props: {
	      resource: /*item0*/ctx[17]
	    },
	    $$inline: true
	  });
	  label.$on("text", text_handler);
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(label.$$.fragment);
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].day);
	      add_location(div, file$2, 28, 20, 1164);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(label, div, null);
	      current = true;
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      const label_changes = {};
	      if (dirty[0] & /*loops*/8) label_changes.resource = /*item0*/ctx[17];
	      label.$set(label_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].day)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(label.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(label.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(label);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block_2.name,
	    type: "else",
	    source: "(28:16) {:else}",
	    ctx
	  });
	  return block;
	}

	// (20:16) {#if $datesAboveResources}
	function create_if_block_4(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      time = element("time");
	      attr_dev(time, "datetime", time_datetime_value = toISOString( /*item0*/ctx[17], 10));
	      attr_dev(time, "aria-label", time_aria_label_value = /*$_intlDayHeaderAL*/ctx[6].format( /*item0*/ctx[17]));
	      add_location(time, file$2, 21, 24, 840);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item0*/ctx[17].getUTCDay()]));
	      add_location(div, file$2, 20, 20, 750);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, time);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[7].format( /*item0*/ctx[17])));
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*loops*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*item0*/ctx[17], 10))) {
	        attr_dev(time, "datetime", time_datetime_value);
	      }
	      if (dirty[0] & /*$_intlDayHeaderAL, loops*/72 && time_aria_label_value !== (time_aria_label_value = /*$_intlDayHeaderAL*/ctx[6].format( /*item0*/ctx[17]))) {
	        attr_dev(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayHeader, loops*/136) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[7].format( /*item0*/ctx[17]));
	      if (dirty[0] & /*$theme, loops*/40 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item0*/ctx[17].getUTCDay()]))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_4.name,
	    type: "if",
	    source: "(20:16) {#if $datesAboveResources}",
	    ctx
	  });
	  return block;
	}

	// (33:16) {#if loops[1].length > 1}
	function create_if_block_2(ctx) {
	  let div;
	  let div_class_value;
	  let current;
	  let each_value_6 = ensure_array_like_dev( /*loops*/ctx[3][1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_6.length; i += 1) {
	    each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].days);
	      add_location(div, file$2, 33, 20, 1404);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252) {
	        each_value_6 = ensure_array_like_dev( /*loops*/ctx[3][1]);
	        let i;
	        for (i = 0; i < each_value_6.length; i += 1) {
	          const child_ctx = get_each_context_6(ctx, each_value_6, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_6(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, null);
	          }
	        }
	        group_outros();
	        for (i = each_value_6.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].days)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_6.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_2.name,
	    type: "if",
	    source: "(33:16) {#if loops[1].length > 1}",
	    ctx
	  });
	  return block;
	}

	// (40:28) {:else}
	function create_else_block_1(ctx) {
	  let div;
	  let time;
	  let time_datetime_value;
	  let time_aria_label_value;
	  let setContent_action;
	  let t;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      time = element("time");
	      t = space();
	      attr_dev(time, "datetime", time_datetime_value = toISOString( /*item1*/ctx[20], 10));
	      attr_dev(time, "aria-label", time_aria_label_value = "" + ( /*resourceLabels*/ctx[4][/*i*/ctx[32]] + /*$_intlDayHeaderAL*/ctx[6].format( /*item1*/ctx[20])));
	      add_location(time, file$2, 41, 36, 1921);
	      attr_dev(div, "class", div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item1*/ctx[20].getUTCDay()]));
	      attr_dev(div, "role", "columnheader");
	      add_location(div, file$2, 40, 32, 1799);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, time);
	      append_dev(div, t);
	      if (!mounted) {
	        dispose = action_destroyer(setContent_action = setContent.call(null, time, /*$_intlDayHeader*/ctx[7].format( /*item1*/ctx[20])));
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] & /*loops*/8 && time_datetime_value !== (time_datetime_value = toISOString( /*item1*/ctx[20], 10))) {
	        attr_dev(time, "datetime", time_datetime_value);
	      }
	      if (dirty[0] & /*resourceLabels, $_intlDayHeaderAL, loops*/88 && time_aria_label_value !== (time_aria_label_value = "" + ( /*resourceLabels*/ctx[4][/*i*/ctx[32]] + /*$_intlDayHeaderAL*/ctx[6].format( /*item1*/ctx[20])))) {
	        attr_dev(time, "aria-label", time_aria_label_value);
	      }
	      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*$_intlDayHeader, loops*/136) setContent_action.update.call(null, /*$_intlDayHeader*/ctx[7].format( /*item1*/ctx[20]));
	      if (dirty[0] & /*$theme, loops*/40 && div_class_value !== (div_class_value = "" + ( /*$theme*/ctx[5].day + " " + /*$theme*/ctx[5].weekdays?.[/*item1*/ctx[20].getUTCDay()]))) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block_1.name,
	    type: "else",
	    source: "(40:28) {:else}",
	    ctx
	  });
	  return block;
	}

	// (36:28) {#if $datesAboveResources}
	function create_if_block_3(ctx) {
	  let div;
	  let label;
	  let t;
	  let div_class_value;
	  let current;
	  label = new Label({
	    props: {
	      resource: /*item1*/ctx[20],
	      date: /*item0*/ctx[17]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(label.$$.fragment);
	      t = space();
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].day);
	      attr_dev(div, "role", "columnheader");
	      add_location(div, file$2, 36, 32, 1569);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(label, div, null);
	      append_dev(div, t);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const label_changes = {};
	      if (dirty[0] & /*loops*/8) label_changes.resource = /*item1*/ctx[20];
	      if (dirty[0] & /*loops*/8) label_changes.date = /*item0*/ctx[17];
	      label.$set(label_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].day)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(label.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(label.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(label);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_3.name,
	    type: "if",
	    source: "(36:28) {#if $datesAboveResources}",
	    ctx
	  });
	  return block;
	}

	// (35:24) {#each loops[1] as item1}
	function create_each_block_6(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block_3, create_else_block_1];
	  const if_blocks = [];
	  function select_block_type_1(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type_1(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  const block = {
	    c: function create() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type_1(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_6.name,
	    type: "each",
	    source: "(35:24) {#each loops[1] as item1}",
	    ctx
	  });
	  return block;
	}

	// (18:8) {#each loops[0] as item0, i}
	function create_each_block_5(ctx) {
	  let div;
	  let current_block_type_index;
	  let if_block0;
	  let t0;
	  let t1;
	  let div_class_value;
	  let current;
	  const if_block_creators = [create_if_block_4, create_else_block_2];
	  const if_blocks = [];
	  function select_block_type(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type(ctx);
	  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  let if_block1 = /*loops*/ctx[3][1].length > 1 && create_if_block_2(ctx);
	  const block = {
	    c: function create() {
	      div = element("div");
	      if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	      add_location(div, file$2, 18, 12, 655);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if_blocks[current_block_type_index].m(div, null);
	      append_dev(div, t0);
	      if (if_block1) if_block1.m(div, null);
	      append_dev(div, t1);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block0 = if_blocks[current_block_type_index];
	        if (!if_block0) {
	          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block0.c();
	        } else {
	          if_block0.p(ctx, dirty);
	        }
	        transition_in(if_block0, 1);
	        if_block0.m(div, t0);
	      }
	      if ( /*loops*/ctx[3][1].length > 1) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	          if (dirty[0] & /*loops*/8) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_2(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div, t1);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, () => {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      if_blocks[current_block_type_index].d();
	      if (if_block1) if_block1.d();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_5.name,
	    type: "each",
	    source: "(18:8) {#each loops[0] as item0, i}",
	    ctx
	  });
	  return block;
	}

	// (17:4) <Section>
	function create_default_slot_2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_5 = ensure_array_like_dev( /*loops*/ctx[3][0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_5.length; i += 1) {
	    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252) {
	        each_value_5 = ensure_array_like_dev( /*loops*/ctx[3][0]);
	        let i;
	        for (i = 0; i < each_value_5.length; i += 1) {
	          const child_ctx = get_each_context_5(ctx, each_value_5, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_5(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_5.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_2.name,
	    type: "slot",
	    source: "(17:4) <Section>",
	    ctx
	  });
	  return block;
	}

	// (57:0) {#if $allDaySlot}
	function create_if_block$2(ctx) {
	  let div2;
	  let div1;
	  let section;
	  let t;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let div2_class_value;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_1]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div2 = element("div");
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t = space();
	      div0 = element("div");
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[5].hiddenScroll);
	      add_location(div0, file$2, 76, 12, 3302);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[5].content);
	      add_location(div1, file$2, 58, 8, 2558);
	      attr_dev(div2, "class", div2_class_value = /*$theme*/ctx[5].allDay);
	      add_location(div2, file$2, 57, 4, 2520);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div2, anchor);
	      append_dev(div2, div1);
	      mount_component(section, div1, null);
	      append_dev(div1, t);
	      append_dev(div1, div0);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const section_changes = {};
	      if (dirty[0] & /*$_viewDates, $theme, $_viewResources, $datesAboveResources*/39 | dirty[1] & /*$$scope*/16) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div0_class_value !== (div0_class_value = /*$theme*/ctx[5].hiddenScroll)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div1_class_value !== (div1_class_value = /*$theme*/ctx[5].content)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div2_class_value !== (div2_class_value = /*$theme*/ctx[5].allDay)) {
	        attr_dev(div2, "class", div2_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(section.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div2);
	      }
	      destroy_component(section);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$2.name,
	    type: "if",
	    source: "(57:0) {#if $allDaySlot}",
	    ctx
	  });
	  return block;
	}

	// (69:16) {:else}
	function create_else_block(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_4 = ensure_array_like_dev( /*$_viewResources*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_4.length; i += 1) {
	    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, $_viewDates, $_viewResources*/35) {
	        each_value_4 = ensure_array_like_dev( /*$_viewResources*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_4.length; i += 1) {
	          const child_ctx = get_each_context_4(ctx, each_value_4, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_4(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_4.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_else_block.name,
	    type: "else",
	    source: "(69:16) {:else}",
	    ctx
	  });
	  return block;
	}

	// (61:16) {#if $datesAboveResources}
	function create_if_block_1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_2 = ensure_array_like_dev( /*$_viewDates*/ctx[0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, $_viewResources, $_viewDates*/35) {
	        each_value_2 = ensure_array_like_dev( /*$_viewDates*/ctx[0]);
	        let i;
	        for (i = 0; i < each_value_2.length; i += 1) {
	          const child_ctx = get_each_context_2(ctx, each_value_2, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_2(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_2.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block_1.name,
	    type: "if",
	    source: "(61:16) {#if $datesAboveResources}",
	    ctx
	  });
	  return block;
	}

	// (70:20) {#each $_viewResources as resource}
	function create_each_block_4(ctx) {
	  let div;
	  let week;
	  let t;
	  let div_class_value;
	  let current;
	  week = new Week({
	    props: {
	      dates: /*$_viewDates*/ctx[0],
	      resource: /*resource*/ctx[26]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      create_component(week.$$.fragment);
	      t = space();
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	      add_location(div, file$2, 70, 24, 3087);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      mount_component(week, div, null);
	      append_dev(div, t);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const week_changes = {};
	      if (dirty[0] & /*$_viewDates*/1) week_changes.dates = /*$_viewDates*/ctx[0];
	      if (dirty[0] & /*$_viewResources*/2) week_changes.resource = /*resource*/ctx[26];
	      week.$set(week_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(week);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_4.name,
	    type: "each",
	    source: "(70:20) {#each $_viewResources as resource}",
	    ctx
	  });
	  return block;
	}

	// (64:28) {#each $_viewResources as resource}
	function create_each_block_3(ctx) {
	  let week;
	  let current;
	  week = new Week({
	    props: {
	      dates: [/*date*/ctx[23]],
	      resource: /*resource*/ctx[26]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(week.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(week, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const week_changes = {};
	      if (dirty[0] & /*$_viewDates*/1) week_changes.dates = [/*date*/ctx[23]];
	      if (dirty[0] & /*$_viewResources*/2) week_changes.resource = /*resource*/ctx[26];
	      week.$set(week_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(week.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(week.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(week, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_3.name,
	    type: "each",
	    source: "(64:28) {#each $_viewResources as resource}",
	    ctx
	  });
	  return block;
	}

	// (62:20) {#each $_viewDates as date}
	function create_each_block_2(ctx) {
	  let div;
	  let t;
	  let div_class_value;
	  let current;
	  let each_value_3 = ensure_array_like_dev( /*$_viewResources*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_3.length; i += 1) {
	    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	      add_location(div, file$2, 62, 24, 2726);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append_dev(div, t);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$_viewDates, $_viewResources*/3) {
	        each_value_3 = ensure_array_like_dev( /*$_viewResources*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value_3.length; i += 1) {
	          const child_ctx = get_each_context_3(ctx, each_value_3, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_3.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_2.name,
	    type: "each",
	    source: "(62:20) {#each $_viewDates as date}",
	    ctx
	  });
	  return block;
	}

	// (60:12) <Section>
	function create_default_slot_1(ctx) {
	  let current_block_type_index;
	  let if_block;
	  let if_block_anchor;
	  let current;
	  const if_block_creators = [create_if_block_1, create_else_block];
	  const if_blocks = [];
	  function select_block_type_2(ctx, dirty) {
	    if ( /*$datesAboveResources*/ctx[2]) return 0;
	    return 1;
	  }
	  current_block_type_index = select_block_type_2(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  const block = {
	    c: function create() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      let previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type_2(ctx);
	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, () => {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];
	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }
	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if_blocks[current_block_type_index].d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot_1.name,
	    type: "slot",
	    source: "(60:12) <Section>",
	    ctx
	  });
	  return block;
	}

	// (84:8) {#each loops[1] as item1}
	function create_each_block_1(ctx) {
	  let day;
	  let current;
	  day = new Day$1({
	    props: {
	      date: /*$datesAboveResources*/ctx[2] ? /*item0*/ctx[17] : /*item1*/ctx[20],
	      resource: /*$datesAboveResources*/ctx[2] ? /*item1*/ctx[20] : /*item0*/ctx[17]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(day.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(day, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const day_changes = {};
	      if (dirty[0] & /*$datesAboveResources, loops*/12) day_changes.date = /*$datesAboveResources*/ctx[2] ? /*item0*/ctx[17] : /*item1*/ctx[20];
	      if (dirty[0] & /*$datesAboveResources, loops*/12) day_changes.resource = /*$datesAboveResources*/ctx[2] ? /*item1*/ctx[20] : /*item0*/ctx[17];
	      day.$set(day_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(day.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(day.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(day, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1.name,
	    type: "each",
	    source: "(84:8) {#each loops[1] as item1}",
	    ctx
	  });
	  return block;
	}

	// (82:0) {#each loops[0] as item0}
	function create_each_block(ctx) {
	  let div;
	  let t;
	  let div_class_value;
	  let current;
	  let each_value_1 = ensure_array_like_dev( /*loops*/ctx[3][1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t = space();
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[5].resource);
	      add_location(div, file$2, 82, 4, 3413);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div, null);
	        }
	      }
	      append_dev(div, t);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$datesAboveResources, loops*/12) {
	        each_value_1 = ensure_array_like_dev( /*loops*/ctx[3][1]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div, t);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div_class_value !== (div_class_value = /*$theme*/ctx[5].resource)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block.name,
	    type: "each",
	    source: "(82:0) {#each loops[0] as item0}",
	    ctx
	  });
	  return block;
	}

	// (81:0) <Body>
	function create_default_slot(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value = ensure_array_like_dev( /*loops*/ctx[3][0]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty[0] & /*$theme, loops, $datesAboveResources*/44) {
	        each_value = ensure_array_like_dev( /*loops*/ctx[3][0]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_default_slot.name,
	    type: "slot",
	    source: "(81:0) <Body>",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1$1(ctx) {
	  let div1;
	  let section;
	  let t0;
	  let div0;
	  let div0_class_value;
	  let div1_class_value;
	  let t1;
	  let t2;
	  let body;
	  let current;
	  section = new Section({
	    props: {
	      $$slots: {
	        default: [create_default_slot_2]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  let if_block = /*$allDaySlot*/ctx[8] && create_if_block$2(ctx);
	  body = new Body({
	    props: {
	      $$slots: {
	        default: [create_default_slot]
	      },
	      $$scope: {
	        ctx
	      }
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      create_component(section.$$.fragment);
	      t0 = space();
	      div0 = element("div");
	      t1 = space();
	      if (if_block) if_block.c();
	      t2 = space();
	      create_component(body.$$.fragment);
	      attr_dev(div0, "class", div0_class_value = /*$theme*/ctx[5].hiddenScroll);
	      add_location(div0, file$2, 54, 4, 2449);
	      attr_dev(div1, "class", div1_class_value = /*$theme*/ctx[5].header);
	      add_location(div1, file$2, 15, 0, 562);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      mount_component(section, div1, null);
	      append_dev(div1, t0);
	      append_dev(div1, div0);
	      insert_dev(target, t1, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, t2, anchor);
	      mount_component(body, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const section_changes = {};
	      if (dirty[0] & /*loops, $theme, $datesAboveResources, resourceLabels, $_intlDayHeaderAL, $_intlDayHeader*/252 | dirty[1] & /*$$scope*/16) {
	        section_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      section.$set(section_changes);
	      if (!current || dirty[0] & /*$theme*/32 && div0_class_value !== (div0_class_value = /*$theme*/ctx[5].hiddenScroll)) {
	        attr_dev(div0, "class", div0_class_value);
	      }
	      if (!current || dirty[0] & /*$theme*/32 && div1_class_value !== (div1_class_value = /*$theme*/ctx[5].header)) {
	        attr_dev(div1, "class", div1_class_value);
	      }
	      if ( /*$allDaySlot*/ctx[8]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty[0] & /*$allDaySlot*/256) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t2.parentNode, t2);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      const body_changes = {};
	      if (dirty[0] & /*loops, $theme, $datesAboveResources*/44 | dirty[1] & /*$$scope*/16) {
	        body_changes.$$scope = {
	          dirty,
	          ctx
	        };
	      }
	      body.$set(body_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(section.$$.fragment, local);
	      transition_in(if_block);
	      transition_in(body.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(section.$$.fragment, local);
	      transition_out(if_block);
	      transition_out(body.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	        detach_dev(t1);
	        detach_dev(t2);
	      }
	      destroy_component(section);
	      if (if_block) if_block.d(detaching);
	      destroy_component(body, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1$1($$self, $$props, $$invalidate) {
	  let $_viewDates;
	  let $_viewResources;
	  let $datesAboveResources;
	  let $theme;
	  let $_intlDayHeaderAL;
	  let $_intlDayHeader;
	  let $allDaySlot;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('View', slots, []);
	  let {
	    datesAboveResources,
	    _viewDates,
	    _viewResources,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme
	  } = getContext('state');
	  validate_store(datesAboveResources, 'datesAboveResources');
	  component_subscribe($$self, datesAboveResources, value => $$invalidate(2, $datesAboveResources = value));
	  validate_store(_viewDates, '_viewDates');
	  component_subscribe($$self, _viewDates, value => $$invalidate(0, $_viewDates = value));
	  validate_store(_viewResources, '_viewResources');
	  component_subscribe($$self, _viewResources, value => $$invalidate(1, $_viewResources = value));
	  validate_store(_intlDayHeader, '_intlDayHeader');
	  component_subscribe($$self, _intlDayHeader, value => $$invalidate(7, $_intlDayHeader = value));
	  validate_store(_intlDayHeaderAL, '_intlDayHeaderAL');
	  component_subscribe($$self, _intlDayHeaderAL, value => $$invalidate(6, $_intlDayHeaderAL = value));
	  validate_store(allDaySlot, 'allDaySlot');
	  component_subscribe($$self, allDaySlot, value => $$invalidate(8, $allDaySlot = value));
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(5, $theme = value));
	  let loops;
	  let resourceLabels = [];
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<View> was created with unknown prop '${key}'`);
	  });
	  const text_handler = (i, e) => $$invalidate(4, resourceLabels[i] = e.detail + ', ', resourceLabels);
	  $$self.$capture_state = () => ({
	    getContext,
	    setContent,
	    Section,
	    Body,
	    Day: Day$1,
	    Week,
	    Label,
	    toISOString,
	    datesAboveResources,
	    _viewDates,
	    _viewResources,
	    _intlDayHeader,
	    _intlDayHeaderAL,
	    allDaySlot,
	    theme,
	    loops,
	    resourceLabels,
	    $_viewDates,
	    $_viewResources,
	    $datesAboveResources,
	    $theme,
	    $_intlDayHeaderAL,
	    $_intlDayHeader,
	    $allDaySlot
	  });
	  $$self.$inject_state = $$props => {
	    if ('datesAboveResources' in $$props) $$invalidate(9, datesAboveResources = $$props.datesAboveResources);
	    if ('_viewDates' in $$props) $$invalidate(10, _viewDates = $$props._viewDates);
	    if ('_viewResources' in $$props) $$invalidate(11, _viewResources = $$props._viewResources);
	    if ('_intlDayHeader' in $$props) $$invalidate(12, _intlDayHeader = $$props._intlDayHeader);
	    if ('_intlDayHeaderAL' in $$props) $$invalidate(13, _intlDayHeaderAL = $$props._intlDayHeaderAL);
	    if ('allDaySlot' in $$props) $$invalidate(14, allDaySlot = $$props.allDaySlot);
	    if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
	    if ('loops' in $$props) $$invalidate(3, loops = $$props.loops);
	    if ('resourceLabels' in $$props) $$invalidate(4, resourceLabels = $$props.resourceLabels);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty[0] & /*$datesAboveResources, $_viewDates, $_viewResources*/7) {
	      $$invalidate(3, loops = $datesAboveResources ? [$_viewDates, $_viewResources] : [$_viewResources, $_viewDates]);
	    }
	  };
	  return [$_viewDates, $_viewResources, $datesAboveResources, loops, resourceLabels, $theme, $_intlDayHeaderAL, $_intlDayHeader, $allDaySlot, datesAboveResources, _viewDates, _viewResources, _intlDayHeader, _intlDayHeaderAL, allDaySlot, theme, text_handler];
	}
	class View extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1$1, create_fragment$1$1, safe_not_equal, {}, null, [-1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "View",
	      options,
	      id: create_fragment$1$1.name
	    });
	  }
	}

	/* packages/resource-time-grid/src/Auxiliary.svelte generated by Svelte v4.2.16 */

	function create_fragment$4(ctx) {
	  const block = {
	    c: noop,
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: noop,
	    p: noop,
	    i: noop,
	    o: noop,
	    d: noop
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$4($$self, $$props, $$invalidate) {
	  let $resources;
	  let $_resTxtColor;
	  let $_resBgColor;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Auxiliary', slots, []);
	  let {
	    resources,
	    _resBgColor,
	    _resTxtColor
	  } = getContext('state');
	  validate_store(resources, 'resources');
	  component_subscribe($$self, resources, value => $$invalidate(3, $resources = value));
	  validate_store(_resBgColor, '_resBgColor');
	  component_subscribe($$self, _resBgColor, value => $$invalidate(5, $_resBgColor = value));
	  validate_store(_resTxtColor, '_resTxtColor');
	  component_subscribe($$self, _resTxtColor, value => $$invalidate(4, $_resTxtColor = value));
	  set_store_value(_resBgColor, $_resBgColor = event => {
	    let resource = $resources.find(res => event.resourceIds.includes(res.id));
	    return resource?.eventBackgroundColor;
	  }, $_resBgColor);
	  set_store_value(_resTxtColor, $_resTxtColor = event => {
	    let resource = $resources.find(res => event.resourceIds.includes(res.id));
	    return resource?.eventTextColor;
	  }, $_resTxtColor);
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    resources,
	    _resBgColor,
	    _resTxtColor,
	    $resources,
	    $_resTxtColor,
	    $_resBgColor
	  });
	  $$self.$inject_state = $$props => {
	    if ('resources' in $$props) $$invalidate(0, resources = $$props.resources);
	    if ('_resBgColor' in $$props) $$invalidate(1, _resBgColor = $$props._resBgColor);
	    if ('_resTxtColor' in $$props) $$invalidate(2, _resTxtColor = $$props._resTxtColor);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [resources, _resBgColor, _resTxtColor];
	}
	let Auxiliary$1 = class Auxiliary extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Auxiliary",
	      options,
	      id: create_fragment$4.name
	    });
	  }
	};
	var index$2 = {
	  createOptions(options) {
	    options.resources = [];
	    options.datesAboveResources = false;
	    options.filterResourcesWithEvents = false;
	    options.resourceLabelContent = undefined;
	    options.resourceLabelDidMount = undefined;
	    // Common options
	    options.buttonText.resourceTimeGridDay = 'day';
	    options.buttonText.resourceTimeGridWeek = 'week';
	    options.theme.resource = 'ec-resource';
	    options.theme.resourceTitle = 'ec-resource-title';
	    options.view = 'resourceTimeGridWeek';
	    options.views.resourceTimeGridDay = {
	      buttonText: btnTextDay,
	      component: View,
	      duration: {
	        days: 1
	      },
	      theme: themeView('ec-time-grid ec-resource-day-view')
	    };
	    options.views.resourceTimeGridWeek = {
	      buttonText: btnTextWeek,
	      component: View,
	      duration: {
	        weeks: 1
	      },
	      theme: themeView('ec-time-grid ec-resource-week-view')
	    };
	  },
	  createParsers(parsers) {
	    parsers.resources = createResources;
	  },
	  createStores(state) {
	    if (!('_times' in state)) {
	      index$3.createStores(state);
	    }
	    state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary$1]);
	    state._viewResources = viewResources(state);
	  }
	};

	let busy = false;
	function animate(fn) {
	  if (!busy) {
	    busy = true;
	    window.requestAnimationFrame(() => {
	      fn();
	      busy = false;
	    });
	  }
	}
	function limit(value, minLimit, maxLimit) {
	  return max(minLimit, min(maxLimit, value));
	}

	/* packages/interaction/src/Action.svelte generated by Svelte v4.2.16 */

	const {
	  window: window_1
	} = globals;
	function create_fragment$3(ctx) {
	  let mounted;
	  let dispose;
	  const block = {
	    c: noop,
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      if (!mounted) {
	        dispose = [listen_dev(window_1, "pointermove", /*handlePointerMove*/ctx[31], false, false, false, false), listen_dev(window_1, "pointerup", /*handlePointerUp*/ctx[32], false, false, false, false), listen_dev(window_1, "pointercancel", /*handlePointerUp*/ctx[32], false, false, false, false), listen_dev(window_1, "scroll", /*handleScroll*/ctx[0], false, false, false, false), listen_dev(window_1, "selectstart", createPreventDefaultHandler( /*complexAction*/ctx[33]), false, false, false, false), listen_dev(window_1, "contextmenu", function () {
	          if (is_function(createPreventDefaultHandler( /*contextmenu_handler*/ctx[41]))) createPreventDefaultHandler( /*contextmenu_handler*/ctx[41]).apply(this, arguments);
	        }, false, false, false, false), listen_dev(window_1, "touchstart", /*handleTouchStart*/ctx[34], false, false, false, false), listen_dev(window_1, "touchmove", /*touchmove_handler*/ctx[40], {
	          passive: false
	        }, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(new_ctx, dirty) {
	      ctx = new_ctx;
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	const ACTION_DRAG = 1;
	const ACTION_RESIZE = 2;
	const ACTION_SELECT = 3;
	const ACTION_CLICK = 4;
	const ACTION_NO_ACTION = 5;
	function validJsEvent(jsEvent) {
	  return jsEvent.isPrimary && (jsEvent.pointerType !== 'mouse' || jsEvent.buttons & 1);
	}
	function createPreventDefaultHandler(condition) {
	  return jsEvent => {
	    if (condition()) {
	      jsEvent.preventDefault();
	    }
	  };
	}
	function instance$3($$self, $$props, $$invalidate) {
	  let $_view;
	  let $unselectFn;
	  let $_events;
	  let $_iEvents;
	  let $selectBackgroundColor;
	  let $_dayGrid;
	  let $_iClass;
	  let $dateClick;
	  let $eventDrop;
	  let $eventResize;
	  let $eventDragStop;
	  let $eventResizeStop;
	  let $selectFn;
	  let $unselectCancel;
	  let $unselectAuto;
	  let $slotHeight;
	  let $dragScroll;
	  let $eventDragStart;
	  let $eventResizeStart;
	  let $eventDragMinDistance;
	  let $selectMinDistance;
	  let $longPressDelay;
	  let $eventLongPressDelay;
	  let $selectLongPressDelay;
	  let $datesAboveResources;
	  let $slotDuration;
	  let $view;
	  let $selectable;
	  let $_draggable;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Action', slots, []);
	  let {
	    _iEvents,
	    _iClass,
	    _events,
	    _view,
	    _dayGrid,
	    _draggable,
	    dateClick,
	    dragScroll,
	    datesAboveResources,
	    eventDragMinDistance,
	    eventDragStart,
	    eventDragStop,
	    eventDrop,
	    eventLongPressDelay,
	    eventResizeStart,
	    eventResizeStop,
	    eventResize,
	    longPressDelay,
	    selectable,
	    select: selectFn,
	    selectBackgroundColor,
	    selectLongPressDelay,
	    selectMinDistance,
	    slotDuration,
	    slotHeight,
	    unselect: unselectFn,
	    unselectAuto,
	    unselectCancel,
	    view
	  } = getContext('state');
	  validate_store(_iEvents, '_iEvents');
	  component_subscribe($$self, _iEvents, value => $$invalidate(69, $_iEvents = value));
	  validate_store(_iClass, '_iClass');
	  component_subscribe($$self, _iClass, value => $$invalidate(72, $_iClass = value));
	  validate_store(_events, '_events');
	  component_subscribe($$self, _events, value => $$invalidate(68, $_events = value));
	  validate_store(_view, '_view');
	  component_subscribe($$self, _view, value => $$invalidate(66, $_view = value));
	  validate_store(_dayGrid, '_dayGrid');
	  component_subscribe($$self, _dayGrid, value => $$invalidate(71, $_dayGrid = value));
	  validate_store(_draggable, '_draggable');
	  component_subscribe($$self, _draggable, value => $$invalidate(94, $_draggable = value));
	  validate_store(dateClick, 'dateClick');
	  component_subscribe($$self, dateClick, value => $$invalidate(73, $dateClick = value));
	  validate_store(dragScroll, 'dragScroll');
	  component_subscribe($$self, dragScroll, value => $$invalidate(82, $dragScroll = value));
	  validate_store(datesAboveResources, 'datesAboveResources');
	  component_subscribe($$self, datesAboveResources, value => $$invalidate(90, $datesAboveResources = value));
	  validate_store(eventDragMinDistance, 'eventDragMinDistance');
	  component_subscribe($$self, eventDragMinDistance, value => $$invalidate(85, $eventDragMinDistance = value));
	  validate_store(eventDragStart, 'eventDragStart');
	  component_subscribe($$self, eventDragStart, value => $$invalidate(83, $eventDragStart = value));
	  validate_store(eventDragStop, 'eventDragStop');
	  component_subscribe($$self, eventDragStop, value => $$invalidate(76, $eventDragStop = value));
	  validate_store(eventDrop, 'eventDrop');
	  component_subscribe($$self, eventDrop, value => $$invalidate(74, $eventDrop = value));
	  validate_store(eventLongPressDelay, 'eventLongPressDelay');
	  component_subscribe($$self, eventLongPressDelay, value => $$invalidate(88, $eventLongPressDelay = value));
	  validate_store(eventResizeStart, 'eventResizeStart');
	  component_subscribe($$self, eventResizeStart, value => $$invalidate(84, $eventResizeStart = value));
	  validate_store(eventResizeStop, 'eventResizeStop');
	  component_subscribe($$self, eventResizeStop, value => $$invalidate(77, $eventResizeStop = value));
	  validate_store(eventResize, 'eventResize');
	  component_subscribe($$self, eventResize, value => $$invalidate(75, $eventResize = value));
	  validate_store(longPressDelay, 'longPressDelay');
	  component_subscribe($$self, longPressDelay, value => $$invalidate(87, $longPressDelay = value));
	  validate_store(selectable, 'selectable');
	  component_subscribe($$self, selectable, value => $$invalidate(93, $selectable = value));
	  validate_store(selectFn, 'selectFn');
	  component_subscribe($$self, selectFn, value => $$invalidate(78, $selectFn = value));
	  validate_store(selectBackgroundColor, 'selectBackgroundColor');
	  component_subscribe($$self, selectBackgroundColor, value => $$invalidate(70, $selectBackgroundColor = value));
	  validate_store(selectLongPressDelay, 'selectLongPressDelay');
	  component_subscribe($$self, selectLongPressDelay, value => $$invalidate(89, $selectLongPressDelay = value));
	  validate_store(selectMinDistance, 'selectMinDistance');
	  component_subscribe($$self, selectMinDistance, value => $$invalidate(86, $selectMinDistance = value));
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(91, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(81, $slotHeight = value));
	  validate_store(unselectFn, 'unselectFn');
	  component_subscribe($$self, unselectFn, value => $$invalidate(67, $unselectFn = value));
	  validate_store(unselectAuto, 'unselectAuto');
	  component_subscribe($$self, unselectAuto, value => $$invalidate(80, $unselectAuto = value));
	  validate_store(unselectCancel, 'unselectCancel');
	  component_subscribe($$self, unselectCancel, value => $$invalidate(79, $unselectCancel = value));
	  validate_store(view, 'view');
	  component_subscribe($$self, view, value => $$invalidate(92, $view = value));
	  let action;
	  let interacting;
	  let event;
	  let display;
	  let date, newDate;
	  let resource, newResource;
	  let fromX, fromY;
	  let toX, toY;
	  let bodyEl, bodyRect, clipEl, clipRect;
	  let delta;
	  let allDay;
	  let iClass;
	  let minEnd; // minimum end time when resizing
	  let selectStep; // minimum selection step
	  let selected; // whether selection has been made
	  let noDateClick; // do not perform date click
	  let timer; // timer for long press delays
	  let viewport;
	  function drag(eventToDrag, jsEvent, resize, forceDate) {
	    if (!action) {
	      action = validJsEvent(jsEvent) ? resize ? ACTION_RESIZE : $_draggable(eventToDrag) ? ACTION_DRAG : ACTION_NO_ACTION : ACTION_NO_ACTION;
	      if (complexAction()) {
	        event = eventToDrag;
	        common(jsEvent);
	        if (forceDate) {
	          // Force date in popup
	          date = forceDate;
	        }
	        iClass = resize ? allDay ? 'resizingX' : 'resizingY' : 'dragging';
	        if (resize) {
	          minEnd = cloneDate(event.start);
	          if (allDay) {
	            minEnd.setUTCHours(event.end.getUTCHours(), event.end.getUTCMinutes(), event.end.getUTCSeconds(), 0);
	            if (minEnd < event.start) {
	              addDay(minEnd);
	            } // minEnd = addDuration(cloneDate(event.start), $slotDuration);  alternative version
	          } else {
	            addDuration(minEnd, $slotDuration);
	          }
	        }
	        move(jsEvent);
	      }
	    }
	  }
	  function select(jsEvent) {
	    if (!action) {
	      action = validJsEvent(jsEvent) ? $selectable && !listView($view) ? ACTION_SELECT : ACTION_CLICK : ACTION_NO_ACTION;
	      if (complexAction()) {
	        common(jsEvent);
	        iClass = 'selecting';
	        selectStep = allDay ? createDuration({
	          day: 1
	        }) : $slotDuration;

	        // Create dummy source event
	        event = {
	          allDay,
	          start: date,
	          end: addDuration(cloneDate(date), selectStep),
	          resourceIds: resource ? [resource.id] : []
	        };
	        move(jsEvent);
	      }
	    }
	  }
	  function noAction() {
	    if (!action) {
	      action = ACTION_NO_ACTION;
	    }
	  }
	  function common(jsEvent) {
	    window.getSelection().removeAllRanges();
	    fromX = toX = jsEvent.clientX;
	    fromY = toY = jsEvent.clientY;
	    let dayEl = getElementWithPayload(toX, toY);
	    ({
	      allDay,
	      date,
	      resource
	    } = getPayload(dayEl)(toY));
	    bodyEl = ancestor(dayEl, resource ? 4 : 3);
	    clipEl = ancestor(dayEl, resource && (dragging() || $datesAboveResources) ? 2 : 1);
	    calcViewport();
	    if (jsEvent.pointerType !== 'mouse') {
	      // For touch devices init long press delay
	      $$invalidate(1, timer = setTimeout(() => {
	        if (action) {
	          interacting = true;
	          move(jsEvent);
	        }
	      }, (selecting() ? $selectLongPressDelay : $eventLongPressDelay) ?? $longPressDelay));
	    }
	  }
	  function move(jsEvent) {
	    if (interacting || jsEvent && jsEvent.pointerType === 'mouse' && distance() >= (selecting() ? $selectMinDistance : $eventDragMinDistance)) {
	      interacting = true;
	      unselect(jsEvent);
	      set_store_value(_iClass, $_iClass = iClass, $_iClass);
	      if (!$_iEvents[0]) {
	        if (selecting()) {
	          createIEventSelect();
	        } else {
	          createIEvent(jsEvent, resizing() ? $eventResizeStart : $eventDragStart);
	        }
	      }
	      let dayEl = findDayEl();
	      if (dayEl) {
	        let newAllDay;
	        ({
	          allDay: newAllDay,
	          date: newDate,
	          resource: newResource
	        } = getPayload(dayEl)(toY));
	        if (newAllDay === allDay) {
	          delta = createDuration((newDate - date) / 1000);
	          set_store_value(_iEvents, $_iEvents[0].end = addDuration(cloneDate(event.end), delta), $_iEvents);
	          if (resizing()) {
	            // Resizing
	            if ($_iEvents[0].end < minEnd) {
	              set_store_value(_iEvents, $_iEvents[0].end = minEnd, $_iEvents);
	            }
	          } else if (selecting()) {
	            // Selecting
	            if ($_iEvents[0].end < event.end) {
	              set_store_value(_iEvents, $_iEvents[0].start = subtractDuration($_iEvents[0].end, selectStep), $_iEvents);
	              set_store_value(_iEvents, $_iEvents[0].end = event.end, $_iEvents);
	            } else {
	              set_store_value(_iEvents, $_iEvents[0].start = event.start, $_iEvents);
	            }
	          } else {
	            // Dragging
	            set_store_value(_iEvents, $_iEvents[0].start = addDuration(cloneDate(event.start), delta), $_iEvents);
	            if (resource) {
	              set_store_value(_iEvents, $_iEvents[0].resourceIds = event.resourceIds.filter(id => id !== resource.id), $_iEvents);
	              $_iEvents[0].resourceIds.push(newResource.id);
	            }
	          }
	        }
	      }
	    }
	    if ($dragScroll) {
	      let threshold = $slotHeight * 2;
	      animate(() => {
	        if (bodyEl) {
	          if (toY < threshold) {
	            window.scrollBy(0, max(-10, (toY - threshold) / 3));
	          }
	          if (toY < bodyRect.top + threshold) {
	            bodyEl.scrollTop += max(-10, (toY - bodyRect.top - threshold) / 3);
	          }
	          if (toY > window.innerHeight - threshold) {
	            window.scrollBy(0, min(10, (toY - window.innerHeight + threshold) / 3));
	          }
	          if (toY > bodyRect.bottom - threshold) {
	            bodyEl.scrollTop += min(10, (toY - bodyRect.bottom + threshold) / 3);
	          }
	        }
	      });
	    }
	  }
	  function handleScroll() {
	    if (complexAction()) {
	      calcViewport();
	      move();
	    }
	  }
	  function handlePointerMove(jsEvent) {
	    if (complexAction() && jsEvent.isPrimary) {
	      toX = jsEvent.clientX;
	      toY = jsEvent.clientY;
	      move(jsEvent);
	    }
	  }
	  function handlePointerUp(jsEvent) {
	    if (selected && $unselectAuto && !($unselectCancel && jsEvent.target.closest($unselectCancel))) {
	      unselect(jsEvent);
	    }
	    if (action && jsEvent.isPrimary) {
	      if (interacting) {
	        if (selecting()) {
	          selected = true;
	          if (is_function($selectFn)) {
	            let {
	              start,
	              end
	            } = toEventWithLocalDates($_iEvents[0]);
	            $selectFn({
	              start,
	              end,
	              startStr: toISOString($_iEvents[0].start),
	              endStr: toISOString($_iEvents[0].end),
	              allDay,
	              jsEvent,
	              view: toViewWithLocalDates($_view),
	              resource
	            });
	          }
	        } else {
	          event.display = display;
	          let callback = resizing() ? $eventResizeStop : $eventDragStop;
	          if (is_function(callback)) {
	            callback({
	              event: toEventWithLocalDates(event),
	              jsEvent,
	              view: toViewWithLocalDates($_view)
	            });
	          }
	          let oldEvent = cloneEvent(event);
	          updateEvent(event, $_iEvents[0]);
	          destroyIEvent();
	          callback = resizing() ? $eventResize : $eventDrop;
	          if (is_function(callback)) {
	            let eventRef = event;
	            let info;
	            if (resizing()) {
	              info = {
	                endDelta: delta
	              };
	            } else {
	              info = {
	                delta,
	                oldResource: resource !== newResource ? resource : undefined,
	                newResource: resource !== newResource ? newResource : undefined
	              };
	            }
	            callback(assign(info, {
	              event: toEventWithLocalDates(event),
	              oldEvent: toEventWithLocalDates(oldEvent),
	              jsEvent,
	              view: toViewWithLocalDates($_view),
	              revert() {
	                updateEvent(eventRef, oldEvent);
	              }
	            }));
	          }
	        }
	      } else {
	        if (clicking() || selecting()) {
	          // Perform date click
	          if (is_function($dateClick) && !noDateClick) {
	            toX = jsEvent.clientX;
	            toY = jsEvent.clientY;
	            let dayEl = getElementWithPayload(toX, toY);
	            if (dayEl) {
	              let {
	                allDay,
	                date,
	                resource
	              } = getPayload(dayEl)(toY);
	              $dateClick({
	                allDay,
	                date: toLocalDate(date),
	                dateStr: toISOString(date),
	                dayEl,
	                jsEvent,
	                view: toViewWithLocalDates($_view),
	                resource
	              });
	            }
	          }
	        }
	      }
	      interacting = false;
	      action = fromX = fromY = toX = toY = event = display = date = newDate = resource = newResource = delta = allDay = set_store_value(_iClass, $_iClass = minEnd = selectStep = undefined, $_iClass);
	      bodyEl = clipEl = bodyRect = clipRect = undefined;
	      if (timer) {
	        clearTimeout(timer);
	        $$invalidate(1, timer = undefined);
	      }
	    }
	    noDateClick = false;
	  }
	  function findDayEl() {
	    // Limit coordinates to viewport
	    return getElementWithPayload(limit(toX, viewport[0], viewport[1]), limit(toY, viewport[2], viewport[3]));
	  }
	  function calcViewport() {
	    bodyRect = rect(bodyEl);
	    clipRect = rect(clipEl);
	    viewport = [max(0, clipRect.left + ($_dayGrid ? 0 : 8)), min(document.documentElement.clientWidth, clipRect.right) - 2, max(0, bodyRect.top // top
	    ), min(document.documentElement.clientHeight, bodyRect.bottom) - 2]; // bottom
	  }
	  function createIEvent(jsEvent, callback) {
	    if (is_function(callback)) {
	      callback({
	        event: toEventWithLocalDates(event),
	        jsEvent,
	        view: toViewWithLocalDates($_view)
	      });
	    }
	    display = event.display;
	    event.display = 'preview';
	    set_store_value(_iEvents, $_iEvents[0] = cloneEvent(event), $_iEvents);
	    event.display = 'ghost';
	    _events.set($_events);
	  }
	  function createIEventSelect() {
	    set_store_value(_iEvents, $_iEvents[0] = {
	      id: '{select}',
	      allDay: event.allDay,
	      start: event.start,
	      title: '',
	      display: 'preview',
	      extendedProps: {},
	      backgroundColor: $selectBackgroundColor,
	      resourceIds: event.resourceIds
	    }, $_iEvents);
	  }
	  function destroyIEvent() {
	    set_store_value(_iEvents, $_iEvents[0] = null, $_iEvents);
	  }
	  function updateEvent(target, source) {
	    target.start = source.start;
	    target.end = source.end;
	    target.resourceIds = source.resourceIds;
	    _events.set($_events);
	  }
	  function distance() {
	    return Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
	  }
	  function dragging() {
	    return action === ACTION_DRAG;
	  }
	  function resizing() {
	    return action === ACTION_RESIZE;
	  }
	  function clicking() {
	    return action === ACTION_CLICK;
	  }
	  function selecting() {
	    return action === ACTION_SELECT;
	  }
	  function complexAction() {
	    return action && action < ACTION_CLICK;
	  }
	  function unselect(jsEvent) {
	    if (selected) {
	      selected = false;
	      destroyIEvent();
	      if (is_function($unselectFn)) {
	        $unselectFn({
	          jsEvent,
	          view: toViewWithLocalDates($_view)
	        });
	      }
	    }
	  }
	  function noClick() {
	    noDateClick = true;
	  }

	  // Clear selection on view params change
	  _view.subscribe(unselect);
	  function handleTouchStart(jsEvent) {
	    if (complexAction()) {
	      let target = jsEvent.target;
	      let stops = [];
	      let stop = () => run_all(stops);
	      stops.push(listen(target, 'touchmove', createPreventDefaultHandler(() => interacting)));
	      stops.push(listen(target, 'touchend', stop));
	      stops.push(listen(target, 'touchcancel', stop));
	    }
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Action> was created with unknown prop '${key}'`);
	  });
	  function touchmove_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  const contextmenu_handler = () => timer;
	  $$self.$capture_state = () => ({
	    getContext,
	    is_function,
	    listen,
	    run_all,
	    addDay,
	    addDuration,
	    ancestor,
	    assign,
	    cloneDate,
	    cloneEvent,
	    createDuration,
	    getElementWithPayload,
	    getPayload,
	    min,
	    max,
	    rect,
	    subtractDuration,
	    toEventWithLocalDates,
	    toISOString,
	    toLocalDate,
	    toViewWithLocalDates,
	    listView,
	    animate,
	    limit,
	    _iEvents,
	    _iClass,
	    _events,
	    _view,
	    _dayGrid,
	    _draggable,
	    dateClick,
	    dragScroll,
	    datesAboveResources,
	    eventDragMinDistance,
	    eventDragStart,
	    eventDragStop,
	    eventDrop,
	    eventLongPressDelay,
	    eventResizeStart,
	    eventResizeStop,
	    eventResize,
	    longPressDelay,
	    selectable,
	    selectFn,
	    selectBackgroundColor,
	    selectLongPressDelay,
	    selectMinDistance,
	    slotDuration,
	    slotHeight,
	    unselectFn,
	    unselectAuto,
	    unselectCancel,
	    view,
	    ACTION_DRAG,
	    ACTION_RESIZE,
	    ACTION_SELECT,
	    ACTION_CLICK,
	    ACTION_NO_ACTION,
	    action,
	    interacting,
	    event,
	    display,
	    date,
	    newDate,
	    resource,
	    newResource,
	    fromX,
	    fromY,
	    toX,
	    toY,
	    bodyEl,
	    bodyRect,
	    clipEl,
	    clipRect,
	    delta,
	    allDay,
	    iClass,
	    minEnd,
	    selectStep,
	    selected,
	    noDateClick,
	    timer,
	    viewport,
	    drag,
	    select,
	    noAction,
	    common,
	    move,
	    handleScroll,
	    handlePointerMove,
	    handlePointerUp,
	    findDayEl,
	    calcViewport,
	    createIEvent,
	    createIEventSelect,
	    destroyIEvent,
	    updateEvent,
	    distance,
	    dragging,
	    resizing,
	    clicking,
	    selecting,
	    complexAction,
	    validJsEvent,
	    unselect,
	    noClick,
	    handleTouchStart,
	    createPreventDefaultHandler,
	    $_view,
	    $unselectFn,
	    $_events,
	    $_iEvents,
	    $selectBackgroundColor,
	    $_dayGrid,
	    $_iClass,
	    $dateClick,
	    $eventDrop,
	    $eventResize,
	    $eventDragStop,
	    $eventResizeStop,
	    $selectFn,
	    $unselectCancel,
	    $unselectAuto,
	    $slotHeight,
	    $dragScroll,
	    $eventDragStart,
	    $eventResizeStart,
	    $eventDragMinDistance,
	    $selectMinDistance,
	    $longPressDelay,
	    $eventLongPressDelay,
	    $selectLongPressDelay,
	    $datesAboveResources,
	    $slotDuration,
	    $view,
	    $selectable,
	    $_draggable
	  });
	  $$self.$inject_state = $$props => {
	    if ('_iEvents' in $$props) $$invalidate(2, _iEvents = $$props._iEvents);
	    if ('_iClass' in $$props) $$invalidate(3, _iClass = $$props._iClass);
	    if ('_events' in $$props) $$invalidate(4, _events = $$props._events);
	    if ('_view' in $$props) $$invalidate(5, _view = $$props._view);
	    if ('_dayGrid' in $$props) $$invalidate(6, _dayGrid = $$props._dayGrid);
	    if ('_draggable' in $$props) $$invalidate(7, _draggable = $$props._draggable);
	    if ('dateClick' in $$props) $$invalidate(8, dateClick = $$props.dateClick);
	    if ('dragScroll' in $$props) $$invalidate(9, dragScroll = $$props.dragScroll);
	    if ('datesAboveResources' in $$props) $$invalidate(10, datesAboveResources = $$props.datesAboveResources);
	    if ('eventDragMinDistance' in $$props) $$invalidate(11, eventDragMinDistance = $$props.eventDragMinDistance);
	    if ('eventDragStart' in $$props) $$invalidate(12, eventDragStart = $$props.eventDragStart);
	    if ('eventDragStop' in $$props) $$invalidate(13, eventDragStop = $$props.eventDragStop);
	    if ('eventDrop' in $$props) $$invalidate(14, eventDrop = $$props.eventDrop);
	    if ('eventLongPressDelay' in $$props) $$invalidate(15, eventLongPressDelay = $$props.eventLongPressDelay);
	    if ('eventResizeStart' in $$props) $$invalidate(16, eventResizeStart = $$props.eventResizeStart);
	    if ('eventResizeStop' in $$props) $$invalidate(17, eventResizeStop = $$props.eventResizeStop);
	    if ('eventResize' in $$props) $$invalidate(18, eventResize = $$props.eventResize);
	    if ('longPressDelay' in $$props) $$invalidate(19, longPressDelay = $$props.longPressDelay);
	    if ('selectable' in $$props) $$invalidate(20, selectable = $$props.selectable);
	    if ('selectFn' in $$props) $$invalidate(21, selectFn = $$props.selectFn);
	    if ('selectBackgroundColor' in $$props) $$invalidate(22, selectBackgroundColor = $$props.selectBackgroundColor);
	    if ('selectLongPressDelay' in $$props) $$invalidate(23, selectLongPressDelay = $$props.selectLongPressDelay);
	    if ('selectMinDistance' in $$props) $$invalidate(24, selectMinDistance = $$props.selectMinDistance);
	    if ('slotDuration' in $$props) $$invalidate(25, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(26, slotHeight = $$props.slotHeight);
	    if ('unselectFn' in $$props) $$invalidate(27, unselectFn = $$props.unselectFn);
	    if ('unselectAuto' in $$props) $$invalidate(28, unselectAuto = $$props.unselectAuto);
	    if ('unselectCancel' in $$props) $$invalidate(29, unselectCancel = $$props.unselectCancel);
	    if ('view' in $$props) $$invalidate(30, view = $$props.view);
	    if ('action' in $$props) action = $$props.action;
	    if ('interacting' in $$props) interacting = $$props.interacting;
	    if ('event' in $$props) event = $$props.event;
	    if ('display' in $$props) display = $$props.display;
	    if ('date' in $$props) date = $$props.date;
	    if ('newDate' in $$props) newDate = $$props.newDate;
	    if ('resource' in $$props) resource = $$props.resource;
	    if ('newResource' in $$props) newResource = $$props.newResource;
	    if ('fromX' in $$props) fromX = $$props.fromX;
	    if ('fromY' in $$props) fromY = $$props.fromY;
	    if ('toX' in $$props) toX = $$props.toX;
	    if ('toY' in $$props) toY = $$props.toY;
	    if ('bodyEl' in $$props) bodyEl = $$props.bodyEl;
	    if ('bodyRect' in $$props) bodyRect = $$props.bodyRect;
	    if ('clipEl' in $$props) clipEl = $$props.clipEl;
	    if ('clipRect' in $$props) clipRect = $$props.clipRect;
	    if ('delta' in $$props) delta = $$props.delta;
	    if ('allDay' in $$props) allDay = $$props.allDay;
	    if ('iClass' in $$props) iClass = $$props.iClass;
	    if ('minEnd' in $$props) minEnd = $$props.minEnd;
	    if ('selectStep' in $$props) selectStep = $$props.selectStep;
	    if ('selected' in $$props) selected = $$props.selected;
	    if ('noDateClick' in $$props) noDateClick = $$props.noDateClick;
	    if ('timer' in $$props) $$invalidate(1, timer = $$props.timer);
	    if ('viewport' in $$props) viewport = $$props.viewport;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [handleScroll, timer, _iEvents, _iClass, _events, _view, _dayGrid, _draggable, dateClick, dragScroll, datesAboveResources, eventDragMinDistance, eventDragStart, eventDragStop, eventDrop, eventLongPressDelay, eventResizeStart, eventResizeStop, eventResize, longPressDelay, selectable, selectFn, selectBackgroundColor, selectLongPressDelay, selectMinDistance, slotDuration, slotHeight, unselectFn, unselectAuto, unselectCancel, view, handlePointerMove, handlePointerUp, complexAction, handleTouchStart, drag, select, noAction, unselect, noClick, touchmove_handler, contextmenu_handler];
	}
	class Action extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3, create_fragment$3, safe_not_equal, {
	      drag: 35,
	      select: 36,
	      noAction: 37,
	      handleScroll: 0,
	      unselect: 38,
	      noClick: 39
	    }, null, [-1, -1, -1, -1]);
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Action",
	      options,
	      id: create_fragment$3.name
	    });
	  }
	  get drag() {
	    return this.$$.ctx[35];
	  }
	  set drag(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get select() {
	    return this.$$.ctx[36];
	  }
	  set select(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get noAction() {
	    return this.$$.ctx[37];
	  }
	  set noAction(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get handleScroll() {
	    return this.$$.ctx[0];
	  }
	  set handleScroll(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get unselect() {
	    return this.$$.ctx[38];
	  }
	  set unselect(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get noClick() {
	    return this.$$.ctx[39];
	  }
	  set noClick(value) {
	    throw new Error("<Action>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/interaction/src/Pointer.svelte generated by Svelte v4.2.16 */

	function create_fragment$2(ctx) {
	  let mounted;
	  let dispose;
	  const block = {
	    c: noop,
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      if (!mounted) {
	        dispose = [listen_dev(window, "pointermove", /*handlePointerMove*/ctx[5], false, false, false, false), listen_dev(window, "scroll", /*handleScroll*/ctx[0], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: noop,
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function validEvent(jsEvent) {
	  return jsEvent.isPrimary && jsEvent.pointerType === 'mouse';
	}
	function instance$2($$self, $$props, $$invalidate) {
	  let $_iEvents;
	  let $slotDuration;
	  let $slotHeight;
	  let $_slotTimeLimits;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Pointer', slots, []);
	  let {
	    _iEvents,
	    _events,
	    _viewDates,
	    _slotTimeLimits,
	    slotDuration,
	    slotHeight,
	    hiddenDays,
	    _view,
	    datesAboveResources,
	    theme
	  } = getContext('state');
	  validate_store(_iEvents, '_iEvents');
	  component_subscribe($$self, _iEvents, value => $$invalidate(9, $_iEvents = value));
	  validate_store(_slotTimeLimits, '_slotTimeLimits');
	  component_subscribe($$self, _slotTimeLimits, value => $$invalidate(18, $_slotTimeLimits = value));
	  validate_store(slotDuration, 'slotDuration');
	  component_subscribe($$self, slotDuration, value => $$invalidate(16, $slotDuration = value));
	  validate_store(slotHeight, 'slotHeight');
	  component_subscribe($$self, slotHeight, value => $$invalidate(17, $slotHeight = value));
	  let y;
	  let colDate;
	  let colEl;
	  let colRect;
	  let resource;
	  let date;
	  function enterTimeGrid(date, el, jsEvent, resourceObj) {
	    if (validEvent(jsEvent)) {
	      colDate = date;
	      colEl = el;
	      colRect = rect(colEl);
	      y = jsEvent.clientY;
	      resource = resourceObj;
	    }
	  }
	  function enterDayGrid(date, jsEvent) {
	    if (validEvent(jsEvent)) {
	      colDate = date;
	      colEl = null;
	      y = resource = undefined;
	    }
	  }
	  function leave(jsEvent) {
	    if (validEvent(jsEvent)) {
	      removePointerEvent();
	    }
	  }
	  function move() {
	    if (!colDate) {
	      return;
	    }
	    if (colEl) {
	      // timeGrid
	      let ry = y - colRect.top;
	      date = addDuration(addDuration(cloneDate(colDate), $_slotTimeLimits.min), $slotDuration, floor(ry / $slotHeight));
	    } else {
	      // dayGrid
	      date = colDate;
	    }
	    if (!$_iEvents[1]) {
	      createPointerEvent();
	    }
	    set_store_value(_iEvents, $_iEvents[1].start = date, $_iEvents);
	    set_store_value(_iEvents, $_iEvents[1].end = addDuration(cloneDate(date), $slotDuration), $_iEvents);
	    set_store_value(_iEvents, $_iEvents[1].resourceIds = resource ? [resource.id] : [], $_iEvents);
	  }
	  function handleScroll() {
	    if (colEl) {
	      colRect = rect(colEl);
	      move();
	    }
	  }
	  function handlePointerMove(jsEvent) {
	    if (validEvent(jsEvent)) {
	      y = jsEvent.clientY;
	      move();
	    }
	  }
	  function createPointerEvent() {
	    set_store_value(_iEvents, $_iEvents[1] = {
	      id: '{pointer}',
	      title: '',
	      display: 'pointer',
	      extendedProps: {},
	      backgroundColor: 'transparent'
	    }, $_iEvents);
	  }
	  function removePointerEvent() {
	    colDate = colEl = set_store_value(_iEvents, $_iEvents[1] = null, $_iEvents);
	  }
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pointer> was created with unknown prop '${key}'`);
	  });
	  $$self.$capture_state = () => ({
	    getContext,
	    addDuration,
	    cloneDate,
	    floor,
	    rect,
	    _iEvents,
	    _events,
	    _viewDates,
	    _slotTimeLimits,
	    slotDuration,
	    slotHeight,
	    hiddenDays,
	    _view,
	    datesAboveResources,
	    theme,
	    y,
	    colDate,
	    colEl,
	    colRect,
	    resource,
	    date,
	    enterTimeGrid,
	    enterDayGrid,
	    leave,
	    move,
	    handleScroll,
	    handlePointerMove,
	    createPointerEvent,
	    removePointerEvent,
	    validEvent,
	    $_iEvents,
	    $slotDuration,
	    $slotHeight,
	    $_slotTimeLimits
	  });
	  $$self.$inject_state = $$props => {
	    if ('_iEvents' in $$props) $$invalidate(1, _iEvents = $$props._iEvents);
	    if ('_events' in $$props) _events = $$props._events;
	    if ('_viewDates' in $$props) _viewDates = $$props._viewDates;
	    if ('_slotTimeLimits' in $$props) $$invalidate(2, _slotTimeLimits = $$props._slotTimeLimits);
	    if ('slotDuration' in $$props) $$invalidate(3, slotDuration = $$props.slotDuration);
	    if ('slotHeight' in $$props) $$invalidate(4, slotHeight = $$props.slotHeight);
	    if ('hiddenDays' in $$props) hiddenDays = $$props.hiddenDays;
	    if ('_view' in $$props) _view = $$props._view;
	    if ('datesAboveResources' in $$props) datesAboveResources = $$props.datesAboveResources;
	    if ('theme' in $$props) theme = $$props.theme;
	    if ('y' in $$props) y = $$props.y;
	    if ('colDate' in $$props) colDate = $$props.colDate;
	    if ('colEl' in $$props) colEl = $$props.colEl;
	    if ('colRect' in $$props) colRect = $$props.colRect;
	    if ('resource' in $$props) resource = $$props.resource;
	    if ('date' in $$props) date = $$props.date;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$_iEvents*/512) {
	      if ($_iEvents[0]) {
	        removePointerEvent();
	      }
	    }
	  };
	  return [handleScroll, _iEvents, _slotTimeLimits, slotDuration, slotHeight, handlePointerMove, enterTimeGrid, enterDayGrid, leave, $_iEvents];
	}
	class Pointer extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
	      enterTimeGrid: 6,
	      enterDayGrid: 7,
	      leave: 8,
	      handleScroll: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Pointer",
	      options,
	      id: create_fragment$2.name
	    });
	  }
	  get enterTimeGrid() {
	    return this.$$.ctx[6];
	  }
	  set enterTimeGrid(value) {
	    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get enterDayGrid() {
	    return this.$$.ctx[7];
	  }
	  set enterDayGrid(value) {
	    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get leave() {
	    return this.$$.ctx[8];
	  }
	  set leave(value) {
	    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get handleScroll() {
	    return this.$$.ctx[0];
	  }
	  set handleScroll(value) {
	    throw new Error("<Pointer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/interaction/src/Resizer.svelte generated by Svelte v4.2.16 */
	const file = "packages/interaction/src/Resizer.svelte";

	// (17:0) {#if resizable}
	function create_if_block$1(ctx) {
	  let div;
	  let div_class_value;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div = element("div");
	      attr_dev(div, "class", div_class_value = /*$theme*/ctx[1].resizer);
	      add_location(div, file, 17, 4, 463);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      if (!mounted) {
	        dispose = listen_dev(div, "pointerdown", /*pointerdown_handler*/ctx[8], false, false, false, false);
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*$theme*/2 && div_class_value !== (div_class_value = /*$theme*/ctx[1].resizer)) {
	        attr_dev(div, "class", div_class_value);
	      }
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1.name,
	    type: "if",
	    source: "(17:0) {#if resizable}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$1(ctx) {
	  let if_block_anchor;
	  let if_block = /*resizable*/ctx[0] && create_if_block$1(ctx);
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if ( /*resizable*/ctx[0]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$1(ctx);
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1($$self, $$props, $$invalidate) {
	  let $editable;
	  let $eventDurationEditable;
	  let $theme;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Resizer', slots, []);
	  let {
	    event
	  } = $$props;
	  let {
	    theme,
	    eventDurationEditable,
	    editable
	  } = getContext('state');
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	  validate_store(eventDurationEditable, 'eventDurationEditable');
	  component_subscribe($$self, eventDurationEditable, value => $$invalidate(7, $eventDurationEditable = value));
	  validate_store(editable, 'editable');
	  component_subscribe($$self, editable, value => $$invalidate(6, $editable = value));
	  let resizable;
	  $$self.$$.on_mount.push(function () {
	    if (event === undefined && !('event' in $$props || $$self.$$.bound[$$self.$$.props['event']])) {
	      console.warn("<Resizer> was created without expected prop 'event'");
	    }
	  });
	  const writable_props = ['event'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Resizer> was created with unknown prop '${key}'`);
	  });
	  function pointerdown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  $$self.$$set = $$props => {
	    if ('event' in $$props) $$invalidate(5, event = $$props.event);
	  };
	  $$self.$capture_state = () => ({
	    getContext,
	    bgEvent,
	    helperEvent,
	    event,
	    theme,
	    eventDurationEditable,
	    editable,
	    resizable,
	    $editable,
	    $eventDurationEditable,
	    $theme
	  });
	  $$self.$inject_state = $$props => {
	    if ('event' in $$props) $$invalidate(5, event = $$props.event);
	    if ('theme' in $$props) $$invalidate(2, theme = $$props.theme);
	    if ('eventDurationEditable' in $$props) $$invalidate(3, eventDurationEditable = $$props.eventDurationEditable);
	    if ('editable' in $$props) $$invalidate(4, editable = $$props.editable);
	    if ('resizable' in $$props) $$invalidate(0, resizable = $$props.resizable);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*event, $eventDurationEditable, $editable*/224) {
	      $$invalidate(0, resizable = !bgEvent(event.display) && !helperEvent(event.display) && ((event.durationEditable ?? $eventDurationEditable) || (event.editable ?? $editable)));
	    }
	  };
	  return [resizable, $theme, theme, eventDurationEditable, editable, event, $editable, $eventDurationEditable, pointerdown_handler];
	}
	class Resizer extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
	      event: 5
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Resizer",
	      options,
	      id: create_fragment$1.name
	    });
	  }
	  get event() {
	    throw new Error("<Resizer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set event(value) {
	    throw new Error("<Resizer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* packages/interaction/src/Auxiliary.svelte generated by Svelte v4.2.16 */

	const {
	  Object: Object_1
	} = globals;

	// (33:0) {#if $pointer}
	function create_if_block(ctx) {
	  let pointer_1;
	  let current;
	  let pointer_1_props = {};
	  pointer_1 = new Pointer({
	    props: pointer_1_props,
	    $$inline: true
	  });
	  /*pointer_1_binding*/
	  ctx[16](pointer_1);
	  const block = {
	    c: function create() {
	      create_component(pointer_1.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(pointer_1, target, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      const pointer_1_changes = {};
	      pointer_1.$set(pointer_1_changes);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(pointer_1.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(pointer_1.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      /*pointer_1_binding*/ctx[16](null);
	      destroy_component(pointer_1, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block.name,
	    type: "if",
	    source: "(33:0) {#if $pointer}",
	    ctx
	  });
	  return block;
	}
	function create_fragment(ctx) {
	  let action;
	  let t;
	  let if_block_anchor;
	  let current;
	  let action_props = {};
	  action = new Action({
	    props: action_props,
	    $$inline: true
	  });
	  /*action_binding*/
	  ctx[15](action);
	  let if_block = /*$pointer*/ctx[1] && create_if_block(ctx);
	  const block = {
	    c: function create() {
	      create_component(action.$$.fragment);
	      t = space();
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      mount_component(action, target, anchor);
	      insert_dev(target, t, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, _ref2) {
	      let [dirty] = _ref2;
	      const action_changes = {};
	      action.$set(action_changes);
	      if ( /*$pointer*/ctx[1]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	          if (dirty & /*$pointer*/2) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(action.$$.fragment, local);
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(action.$$.fragment, local);
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(t);
	        detach_dev(if_block_anchor);
	      }

	      /*action_binding*/
	      ctx[15](null);
	      destroy_component(action, detaching);
	      if (if_block) if_block.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance($$self, $$props, $$invalidate) {
	  let $_interaction;
	  let $_bodyEl;
	  let $theme;
	  let $_draggable;
	  let $_iClasses;
	  let $editable;
	  let $eventStartEditable;
	  let $pointer;
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Auxiliary', slots, []);
	  let {
	    theme,
	    editable,
	    eventStartEditable,
	    eventDurationEditable,
	    pointer,
	    _bodyEl,
	    _interaction,
	    _iClasses,
	    _draggable
	  } = getContext('state');
	  validate_store(theme, 'theme');
	  component_subscribe($$self, theme, value => $$invalidate(11, $theme = value));
	  validate_store(editable, 'editable');
	  component_subscribe($$self, editable, value => $$invalidate(13, $editable = value));
	  validate_store(eventStartEditable, 'eventStartEditable');
	  component_subscribe($$self, eventStartEditable, value => $$invalidate(14, $eventStartEditable = value));
	  validate_store(pointer, 'pointer');
	  component_subscribe($$self, pointer, value => $$invalidate(1, $pointer = value));
	  validate_store(_bodyEl, '_bodyEl');
	  component_subscribe($$self, _bodyEl, value => $$invalidate(10, $_bodyEl = value));
	  validate_store(_interaction, '_interaction');
	  component_subscribe($$self, _interaction, value => $$invalidate(0, $_interaction = value));
	  validate_store(_iClasses, '_iClasses');
	  component_subscribe($$self, _iClasses, value => $$invalidate(17, $_iClasses = value));
	  validate_store(_draggable, '_draggable');
	  component_subscribe($$self, _draggable, value => $$invalidate(12, $_draggable = value));
	  set_store_value(_interaction, $_interaction.resizer = Resizer, $_interaction);
	  function bodyScrollHandler() {
	    for (let component of Object.values($_interaction)) {
	      component?.handleScroll?.();
	    }
	  }
	  const writable_props = [];
	  Object_1.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
	  });
	  function action_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_interaction.action = $$value;
	      _interaction.set($_interaction);
	    });
	  }
	  function pointer_1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      $_interaction.pointer = $$value;
	      _interaction.set($_interaction);
	    });
	  }
	  $$self.$capture_state = () => ({
	    getContext,
	    listen,
	    bgEvent,
	    helperEvent,
	    Action,
	    Pointer,
	    Resizer,
	    theme,
	    editable,
	    eventStartEditable,
	    eventDurationEditable,
	    pointer,
	    _bodyEl,
	    _interaction,
	    _iClasses,
	    _draggable,
	    bodyScrollHandler,
	    $_interaction,
	    $_bodyEl,
	    $theme,
	    $_draggable,
	    $_iClasses,
	    $editable,
	    $eventStartEditable,
	    $pointer
	  });
	  $$self.$inject_state = $$props => {
	    if ('theme' in $$props) $$invalidate(2, theme = $$props.theme);
	    if ('editable' in $$props) $$invalidate(3, editable = $$props.editable);
	    if ('eventStartEditable' in $$props) $$invalidate(4, eventStartEditable = $$props.eventStartEditable);
	    if ('eventDurationEditable' in $$props) eventDurationEditable = $$props.eventDurationEditable;
	    if ('pointer' in $$props) $$invalidate(5, pointer = $$props.pointer);
	    if ('_bodyEl' in $$props) $$invalidate(6, _bodyEl = $$props._bodyEl);
	    if ('_interaction' in $$props) $$invalidate(7, _interaction = $$props._interaction);
	    if ('_iClasses' in $$props) $$invalidate(8, _iClasses = $$props._iClasses);
	    if ('_draggable' in $$props) $$invalidate(9, _draggable = $$props._draggable);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  $$self.$$.update = () => {
	    if ($$self.$$.dirty & /*$eventStartEditable, $editable*/24576) {
	      set_store_value(_draggable, $_draggable = event => (event.startEditable ?? $eventStartEditable) || (event.editable ?? $editable), $_draggable);
	    }
	    if ($$self.$$.dirty & /*$theme, $_draggable*/6144) {
	      set_store_value(_iClasses, $_iClasses = (className, event) => {
	        let {
	          display
	        } = event;
	        return helperEvent(display) ? [$theme[display]] : !bgEvent(display) && $_draggable(event) ? [$theme.draggable] : [];
	      }, $_iClasses);
	    }
	    if ($$self.$$.dirty & /*$_bodyEl*/1024) {
	      if ($_bodyEl) {
	        listen($_bodyEl, 'scroll', bodyScrollHandler);
	      }
	    }
	  };
	  return [$_interaction, $pointer, theme, editable, eventStartEditable, pointer, _bodyEl, _interaction, _iClasses, _draggable, $_bodyEl, $theme, $_draggable, $editable, $eventStartEditable, action_binding, pointer_1_binding];
	}
	class Auxiliary extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance, create_fragment, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Auxiliary",
	      options,
	      id: create_fragment.name
	    });
	  }
	}
	var index$1 = {
	  createOptions(options) {
	    options.dateClick = undefined;
	    options.dragScroll = true;
	    options.editable = false;
	    options.eventDragMinDistance = 5;
	    options.eventDragStart = undefined;
	    options.eventDragStop = undefined;
	    options.eventDrop = undefined;
	    options.eventDurationEditable = true;
	    options.eventLongPressDelay = undefined;
	    options.eventResizeStart = undefined;
	    options.eventResizeStop = undefined;
	    options.eventResize = undefined;
	    options.eventStartEditable = true;
	    options.longPressDelay = 1000;
	    options.pointer = false;
	    options.select = undefined;
	    options.selectBackgroundColor = undefined; // ec option
	    options.selectLongPressDelay = undefined;
	    options.selectMinDistance = 5;
	    options.unselect = undefined;
	    options.unselectAuto = true;
	    options.unselectCancel = '';
	    options.theme.draggable = 'ec-draggable';
	    options.theme.ghost = 'ec-ghost';
	    options.theme.preview = 'ec-preview';
	    options.theme.pointer = 'ec-pointer';
	    options.theme.resizer = 'ec-resizer';
	    options.theme.dragging = 'ec-dragging';
	    options.theme.resizingY = 'ec-resizing-y';
	    options.theme.resizingX = 'ec-resizing-x';
	    options.theme.selecting = 'ec-selecting';
	  },
	  createStores(state) {
	    state._draggable = writable(noop);
	    state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary]);
	  }
	};

	class index extends Calendar {
	  constructor(el, options) {
	    super({
	      target: el,
	      props: {
	        plugins: [index$5, index$4, index$3, index$2, index$1],
	        options
	      }
	    });
	  }
	  get view() {
	    return this.getView();
	  }
	}

	return index;

})();
//# sourceMappingURL=event-calendar.min.js.map
